diff --git a/arch/arm/configs/vorkKernelSVS_bravo_defconfig b/arch/arm/configs/vorkKernelSVS_bravo_defconfig
index 7ae3f80..dbf9230 100644
--- a/arch/arm/configs/vorkKernelSVS_bravo_defconfig
+++ b/arch/arm/configs/vorkKernelSVS_bravo_defconfig
@@ -1336,6 +1336,7 @@ CONFIG_MEDIA_SUPPORT=y
 # Qualcomm MSM Camera And Video
 #
 CONFIG_MSM_CAMERA=y
+CONFIG_720P_CAMERA=y
 # CONFIG_MSM_CAMERA_DEBUG is not set
 
 #
@@ -1345,6 +1346,10 @@ CONFIG_MSM_CAMERA=y
 # CONFIG_MT9D112 is not set
 # CONFIG_MT9P012 is not set
 CONFIG_S5K3E2FX=y
+# CONFIG_S5K6AAFX is not set
+# CONFIG_OV8810 is not set
+# CONFIG_OV9665 is not set
+# CONFIG_S5K3H1GX is not set
 # CONFIG_DAB is not set
 
 #
diff --git a/arch/arm/configs/vorkKernelSVSADV_bravo_defconfig b/arch/arm/configs/vorkKernelSVSADV_bravo_defconfig
index 910c9f4..633d2f0 100644
--- a/arch/arm/configs/vorkKernelSVSADV_bravo_defconfig
+++ b/arch/arm/configs/vorkKernelSVSADV_bravo_defconfig
@@ -1336,6 +1336,7 @@ CONFIG_MEDIA_SUPPORT=y
 # Qualcomm MSM Camera And Video
 #
 CONFIG_MSM_CAMERA=y
+CONFIG_720P_CAMERA=y
 # CONFIG_MSM_CAMERA_DEBUG is not set
 
 #
@@ -1345,6 +1346,10 @@ CONFIG_MSM_CAMERA=y
 # CONFIG_MT9D112 is not set
 # CONFIG_MT9P012 is not set
 CONFIG_S5K3E2FX=y
+# CONFIG_S5K6AAFX is not set
+# CONFIG_OV8810 is not set
+# CONFIG_OV9665 is not set
+# CONFIG_S5K3H1GX is not set
 # CONFIG_DAB is not set
 
 #
diff --git a/arch/arm/mach-msm/board-bravo.c b/arch/arm/mach-msm/board-bravo.c
index e7e1426..de8f6d8 100644
--- a/arch/arm/mach-msm/board-bravo.c
+++ b/arch/arm/mach-msm/board-bravo.c
@@ -611,13 +611,13 @@ static struct msm_camera_device_platform_data msm_camera_device_data = {
 	.ioext.appsz  = MSM_CLK_CTL_SIZE,
 };
 
-/*static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
-*	.camera_flash		= flashlight_control,
-*	.num_flash_levels	= FLASHLIGHT_NUM,
-*	.low_temp_limit		= 5,
-*	.low_cap_limit		= 15,
-*};
-*/
+static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
+	.camera_flash		= flashlight_control,
+	.num_flash_levels	= FLASHLIGHT_NUM,
+	.low_temp_limit		= 5,
+	.low_cap_limit		= 15,
+};
+
 static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
 	.sensor_name 	= "s5k3e2fx",
 	.sensor_reset 	= 144,  /* CAM1_RST */
@@ -626,8 +626,7 @@ static struct msm_camera_sensor_info msm_camera_sensor_s5k3e2fx_data = {
 	.pdata 		= &msm_camera_device_data,
 	.resource 	= msm_camera_resources,
 	.num_resources 	= ARRAY_SIZE(msm_camera_resources),
-	.camera_flash = flashlight_control,
-	.num_flash_levels = FLASHLIGHT_NUM,
+	.flash_cfg	= &msm_camera_sensor_flash_cfg,
 };
 
 static struct platform_device msm_camera_sensor_s5k3e2fx = {
diff --git a/arch/arm/mach-msm/include/mach/board.h b/arch/arm/mach-msm/include/mach/board.h
index f155870..913d1b6 100644
--- a/arch/arm/mach-msm/include/mach/board.h
+++ b/arch/arm/mach-msm/include/mach/board.h
@@ -19,11 +19,10 @@
 
 #include <linux/types.h>
 #include <mach/mmc.h>
+#include <asm/setup.h>
 
 /* platform device data structures */
-
-struct msm_acpu_clock_platform_data
-{
+struct msm_acpu_clock_platform_data {
 	uint32_t acpu_switch_time_us;
 	uint32_t max_speed_delta_khz;
 	uint32_t vdd_switch_time_us;
@@ -37,8 +36,11 @@ struct msm_camera_io_ext {
 	uint32_t mdcsz;
 	uint32_t appphy;
 	uint32_t appsz;
-	unsigned long camifpadphy;
-	unsigned long camifpadsz;
+	uint32_t camifpadphy;
+	uint32_t camifpadsz;
+	uint32_t csiphy;
+	uint32_t csisz;
+	uint32_t csiirq;
 };
 
 struct msm_camera_device_platform_data {
@@ -46,6 +48,18 @@ struct msm_camera_device_platform_data {
 	void (*camera_gpio_off)(void);
 	struct msm_camera_io_ext ioext;
 };
+enum msm_camera_csi_data_format {
+	CSI_8BIT,
+	CSI_10BIT,
+	CSI_12BIT,
+};
+struct msm_camera_csi_params {
+	enum msm_camera_csi_data_format data_format;
+	uint8_t lane_cnt;
+	uint8_t lane_assign;
+	uint8_t settle_cnt;
+	uint8_t dpcm_scheme;
+};
 
 struct msm_camera_legacy_device_platform_data {
 	int sensor_reset;
@@ -53,6 +67,52 @@ struct msm_camera_legacy_device_platform_data {
 	int vcm_pwd;
 	void (*config_gpio_on) (void);
 	void (*config_gpio_off)(void);
+	struct msm_camsensor_device_platform_data *sensor_info;
+};
+
+#define MSM_CAMERA_FLASH_NONE 0
+#define MSM_CAMERA_FLASH_LED  1
+#define MSM_CAMERA_FLASH_SRC_PMIC (0x00000001<<0)
+#define MSM_CAMERA_FLASH_SRC_PWM  (0x00000001<<1)
+
+struct msm_camera_sensor_flash_pmic {
+	uint32_t low_current;
+	uint32_t high_current;
+};
+
+struct msm_camera_sensor_flash_pwm {
+	uint32_t freq;
+	uint32_t max_load;
+	uint32_t low_load;
+	uint32_t high_load;
+	uint32_t channel;
+};
+
+struct msm_camera_sensor_flash_src {
+	int flash_sr_type;
+
+	union {
+		struct msm_camera_sensor_flash_pmic pmic_src;
+		struct msm_camera_sensor_flash_pwm pwm_src;
+	} _fsrc;
+};
+
+struct msm_camera_sensor_flash_data {
+	int flash_type;
+	struct msm_camera_sensor_flash_src *flash_src;
+};
+
+struct camera_flash_cfg {
+	int num_flash_levels;
+	int (*camera_flash)(int level);
+	uint16_t low_temp_limit;
+	uint16_t low_cap_limit;
+	uint8_t postpone_led_mode;
+};
+
+enum msm_camera_source{
+	MAIN_SOURCE,
+	SECOND_SOURCE,
 };
 
 struct msm_camera_sensor_info {
@@ -60,14 +120,37 @@ struct msm_camera_sensor_info {
 	int sensor_reset;
 	int sensor_pwd;
 	int vcm_pwd;
+	void(*camera_clk_switch)(void);
+	/*power*/
+	char *camera_analog_pwd;
+	char *camera_io_pwd;
+	char *camera_vcm_pwd;
+	char *camera_digital_pwd;
+	int analog_pwd1_gpio;
+	int (*camera_power_on)(void);
+	int (*camera_power_off)(void);
+	void(*camera_set_source)(enum msm_camera_source);
+	enum msm_camera_source(*camera_get_source)(void);
+	int (*camera_main_get_probe)(void);
+	void (*camera_main_set_probe)(int);
 	int mclk;
-	int num_flash_levels;
-	int (*camera_flash)(int level);
+	int flash_type; /* for back support */
+	uint8_t led_high_enabled;
 	int need_suspend;
 	struct msm_camera_device_platform_data *pdata;
 	struct resource *resource;
 	uint8_t num_resources;
+	uint32_t waked_up;
+	wait_queue_head_t event_wait;
+	uint32_t kpi_sensor_start;
+	uint32_t kpi_sensor_end;
+	struct camera_flash_cfg* flash_cfg;
+	int csi_if;
+	struct msm_camera_csi_params csi_params;
+	int sensor_lc_disable; /* for sensor lens correction support */
+	uint8_t (*preview_skip_frame)(void);
 };
+struct clk;
 
 struct snd_endpoint {
 	int id;
@@ -79,12 +162,9 @@ struct msm_snd_endpoints {
 	unsigned num;
 };
 
-struct clk;
-
 extern struct sys_timer msm_timer;
 
 /* common init routines for use by arch/arm/mach-msm/board-*.c */
-
 void __init msm_add_devices(void);
 void __init msm_map_common_io(void);
 void __init msm_init_irq(void);
diff --git a/arch/arm/mach-msm/include/mach/camera.h b/arch/arm/mach-msm/include/mach/camera.h
index 1da814f..a517d29 100644
--- a/arch/arm/mach-msm/include/mach/camera.h
+++ b/arch/arm/mach-msm/include/mach/camera.h
@@ -1,19 +1,5 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
+/*
+ * Copyright (C) 2008-2009 QUALCOMM Incorporated.
  */
 
 #ifndef __ASM__ARCH_CAMERA_H
@@ -54,27 +40,28 @@ enum vfe_resp_msg {
 	VFE_EVENT,
 	VFE_MSG_GENERAL,
 	VFE_MSG_SNAPSHOT,
+#ifndef CONFIG_720P_CAMERA
 	VFE_MSG_OUTPUT1,
 	VFE_MSG_OUTPUT2,
-	VFE_MSG_STATS_AF,
-	VFE_MSG_STATS_WE, /* AEC + AWB */
+#else
 	VFE_MSG_OUTPUT_P,   /* preview (continuous mode ) */
 	VFE_MSG_OUTPUT_T,   /* thumbnail (snapshot mode )*/
 	VFE_MSG_OUTPUT_S,   /* main image (snapshot mode )*/
 	VFE_MSG_OUTPUT_V,   /* video   (continuous mode ) */
-	VFE_MSG_STATS_AEC,
-	VFE_MSG_STATS_AWB,
-	VFE_MSG_STATS_RS,
-	VFE_MSG_STATS_CS,
-	VFE_MSG_STATS_IHIST,
-	VFE_MSG_STATS_SKIN,
+#endif
+	VFE_MSG_STATS_AF,
+	VFE_MSG_STATS_WE,
 };
 
+#define VFE31_OUTPUT_MODE_PT (0x1 << 0)
+#define VFE31_OUTPUT_MODE_S (0x1 << 1)
+#define VFE31_OUTPUT_MODE_V (0x1 << 2)
+
 struct msm_vfe_phy_info {
 	uint32_t sbuf_phy;
 	uint32_t y_phy;
 	uint32_t cbcr_phy;
-	uint8_t  output_id; /* OUTPUT_MODE_P/T/S/V */
+	uint8_t  output_id; /* VFE31_OUTPUT_MODE_PT/S/V */
 };
 
 struct msm_vfe_resp {
@@ -91,7 +78,6 @@ struct msm_vfe_callback {
 		gfp_t gfp);
 	void* (*vfe_alloc)(int, void *syncdata, gfp_t gfp);
 	void (*vfe_free)(void *ptr);
-	int (*flash_ctrl)(void *syncdata, int level);
 };
 
 struct msm_camvfe_fn {
@@ -104,9 +90,10 @@ struct msm_camvfe_fn {
 };
 
 struct msm_sensor_ctrl {
-	int (*s_init)(const struct msm_camera_sensor_info *);
+	int (*s_init)(struct msm_camera_sensor_info *);
 	int (*s_release)(void);
 	int (*s_config)(void __user *);
+	int node;
 };
 
 /* this structure is used in kernel */
@@ -118,6 +105,7 @@ struct msm_queue_cmd {
 	enum msm_queue type;
 	void *command;
 	int on_heap;
+	struct timespec ts;
 };
 
 struct msm_device_queue {
@@ -154,10 +142,12 @@ struct msm_sync {
 	 * interrupt context, and by the control thread.
 	 */
 	struct msm_device_queue pict_q;
+	int get_pic_abort;
 
 	struct msm_camera_sensor_info *sdata;
 	struct msm_camvfe_fn vfefn;
 	struct msm_sensor_ctrl sctrl;
+	struct wake_lock wake_suspend_lock;
 	struct wake_lock wake_lock;
 	struct platform_device *pdev;
 	uint8_t opencnt;
@@ -177,7 +167,6 @@ struct msm_sync {
 
 	struct mutex lock;
 	struct list_head list;
-	int get_pic_abort;
 };
 
 #define MSM_APPS_ID_V4L2 "msm_v4l2"
@@ -215,7 +204,9 @@ struct register_address_value_pair {
 struct msm_pmem_region {
 	struct hlist_node list;
 	unsigned long paddr;
+//#ifdef CONFIG_MSM_CAMERA_LEGACY
 	unsigned long kvaddr;
+//#endif
 	unsigned long len;
 	struct file *file;
 	struct msm_pmem_info info;
@@ -224,10 +215,25 @@ struct msm_pmem_region {
 struct axidata {
 	uint32_t bufnum1;
 	uint32_t bufnum2;
-	struct msm_pmem_region *region;
+//#ifdef CONFIG_720P_CAMERA
 	uint32_t bufnum3;
+//#endif
+	struct msm_pmem_region *region;
 };
 
+#ifdef CONFIG_MSM_CAMERA_FLASH
+	int msm_camera_flash_set_led_state(
+		struct msm_camera_sensor_flash_data *fdata,
+		unsigned led_state);
+#else
+	static inline int msm_camera_flash_set_led_state(
+		struct msm_camera_sensor_flash_data *fdata,
+		unsigned led_state)
+	{
+		return -ENOTSUPP;
+	}
+#endif
+
 #ifdef CONFIG_MSM_CAMERA_V4L2
 /* Below functions are added for V4L2 kernel APIs */
 struct msm_v4l2_driver {
@@ -251,7 +257,7 @@ void msm_camvfe_init(void);
 int msm_camvfe_check(void *);
 void msm_camvfe_fn_init(struct msm_camvfe_fn *, void *);
 int msm_camera_drv_start(struct platform_device *dev,
-		int (*sensor_probe)(const struct msm_camera_sensor_info *,
+		int (*sensor_probe)(struct msm_camera_sensor_info *,
 					struct msm_sensor_ctrl *));
 
 enum msm_camio_clk_type {
@@ -259,7 +265,8 @@ enum msm_camio_clk_type {
 	CAMIO_MDC_CLK,
 	CAMIO_VFE_CLK,
 	CAMIO_VFE_AXI_CLK,
-
+//#ifdef CONFIG_MSM_CAMERA_7X30
+	CAMIO_VFE_CLK_FOR_MIPI_2_LANE,
 	CAMIO_VFE_CAMIF_CLK,
 	CAMIO_VFE_PBDG_CLK,
 	CAMIO_CAM_MCLK_CLK,
@@ -267,6 +274,7 @@ enum msm_camio_clk_type {
 	CAMIO_CSI_CLK,
 	CAMIO_CSI_VFE_CLK,
 	CAMIO_CSI_PCLK,
+//#endif
 	CAMIO_MAX_CLK
 };
 
@@ -312,7 +320,6 @@ int  msm_camio_clk_disable(enum msm_camio_clk_type clk);
 int  msm_camio_clk_config(uint32_t freq);
 void msm_camio_clk_rate_set(int rate);
 void msm_camio_clk_axi_rate_set(int rate);
-void msm_disable_io_gpio_clk(struct platform_device *);
 
 void msm_camio_camif_pad_reg_reset(void);
 void msm_camio_camif_pad_reg_reset_2(void);
@@ -323,4 +330,22 @@ void msm_camio_clk_sel(enum msm_camio_clk_src_type);
 void msm_camio_disable(struct platform_device *);
 int msm_camio_probe_on(struct platform_device *);
 int msm_camio_probe_off(struct platform_device *);
+
+#ifdef CONFIG_MSM_CAMERA_7X30
+void msm_camio_clk_rate_set_2(struct clk *clk, int rate);
+void msm_disable_io_gpio_clk(struct platform_device *);
+int msm_camio_csi_config(struct msm_camera_csi_params *csi_params);
+int request_axi_qos(uint32_t freq);
+int update_axi_qos(uint32_t freq);
+void release_axi_qos(void);
+int msm_camio_read_camif_status(void);
+
+void msm_io_w(u32 data, void __iomem *addr);
+void msm_io_w_mb(u32 data, void __iomem *addr);
+u32 msm_io_r(void __iomem *addr);
+u32 msm_io_r_mb(void __iomem *addr);
+void msm_io_dump(void __iomem *addr, int size);
+void msm_io_memcpy(void __iomem *dest_addr, void __iomem *src_addr, u32 len);
+#endif
+
 #endif
diff --git a/arch/arm/mach-msm/include/mach/msm_flashlight.h b/arch/arm/mach-msm/include/mach/msm_flashlight.h
index bababa0..08efd10 100644
--- a/arch/arm/mach-msm/include/mach/msm_flashlight.h
+++ b/arch/arm/mach-msm/include/mach/msm_flashlight.h
@@ -50,6 +50,8 @@ struct flashlight_platform_data {
 };
 
 int flashlight_control(int mode);
+int aat1271_flashlight_control(int mode);
+int adp1650_flashlight_control(int mode);
 
 #undef __ASM_ARCH_MSM8X50_FLASHLIGHT_H
 #endif
diff --git a/drivers/media/video/msm/Kconfig b/drivers/media/video/msm/Kconfig
index b4796d3..142c286 100644
--- a/drivers/media/video/msm/Kconfig
+++ b/drivers/media/video/msm/Kconfig
@@ -7,10 +7,15 @@ menuconfig MSM_CAMERA
 	  Say Y here to enable selecting the video adapters for
 	  Qualcomm msm camera and video encoding
 
+config 720P_CAMERA
+	bool "Qualcomm MSM camera with 720P video support"
+	depends on MSM_CAMERA
+	help
+	  720P video support
+
 config MSM_CAMERA_V4L2
 	bool "Video For Linux interface to MSM camera"
 	depends on MSM_CAMERA && VIDEO_V4L2 && EXPERIMENTAL
-	default y
 	help
 	  Say Y here to enable the V4L2 interface for the MSM camera.
 	  Not everything works through this interface and it has not
@@ -41,8 +46,43 @@ config MT9P012
 	---help---
 	  MICRON 5M Bayer Sensor with Autofocus
 
+config MSM_CAMERA_AF_FOXCONN
+	bool "FOXCONN Module"
+	depends on MT9P012
+	---help---
+	  This driver supports FOXCONN AF module for 5M Bayer sensor
+
 config S5K3E2FX
 	bool "Sensor s5k3e2fx (Samsung 5M)"
 	depends on MSM_CAMERA
 	---help---
 	  Samsung 5M with Autofocus
+
+config S5K6AAFX
+	bool "Sensor s5k6aafx (Samsung 1.3M)"
+	depends on MSM_CAMERA
+	default n
+	---help---
+	  Samsung 1.3M without Autofocus
+
+config OV8810
+	bool "Sensor ov8810"
+	depends on MSM_CAMERA
+	default n
+	---help---
+	  OmniVision 8M Bayer Sensor
+
+config OV9665
+	bool "Sensor ov9665"
+	depends on MSM_CAMERA
+	default n
+	---help---
+	  OmniVision 3M YUV Sensor
+
+config S5K3H1GX
+	bool "Sensor s5k3h1gx"
+	depends on MSM_CAMERA
+	default n
+	---help---
+	  Samsung 8M 3H1 MIPI AF Sensor
+
diff --git a/drivers/media/video/msm/Makefile b/drivers/media/video/msm/Makefile
old mode 100755
new mode 100644
index 61e370c..26d7465
--- a/drivers/media/video/msm/Makefile
+++ b/drivers/media/video/msm/Makefile
@@ -1,9 +1,12 @@
 obj-$(CONFIG_MT9T013) += mt9t013.o mt9t013_reg.o
 obj-$(CONFIG_MT9D112) += mt9d112.o mt9d112_reg.o
+obj-$(CONFIG_OV9665) += ov9665.o ov9665_reg.o
 obj-$(CONFIG_MT9P012) += mt9p012_fox.o mt9p012_reg.o
 obj-$(CONFIG_MSM_CAMERA) += msm_camera.o
 obj-$(CONFIG_MSM_CAMERA_V4L2) += msm_v4l2.o
 obj-$(CONFIG_S5K3E2FX) += s5k3e2fx.o
-obj-$(CONFIG_ARCH_MSM7X00A) += msm_vfe7x.o msm_io7x.o
+obj-$(CONFIG_S5K6AAFX) += s5k6aafx.o s5k6aafx_reg_mecha.o
+obj-$(CONFIG_ARCH_MSM_ARM11) += msm_vfe7x.o msm_io7x.o
 obj-$(CONFIG_ARCH_QSD8X50) += msm_vfe8x.o msm_vfe8x_proc.o msm_io8x.o
-obj-$(CONFIG_ARCH_MSM7X30) += msm_vfe31.o msm_io_vfe31.o
+obj-$(CONFIG_OV8810) += ov8810.o
+obj-$(CONFIG_S5K3H1GX) += s5k3h1gx.o s5k3h1gx_reg.o
diff --git a/drivers/media/video/msm/msm_camera.c b/drivers/media/video/msm/msm_camera.c
index 42cd3ad..aace487 100644
--- a/drivers/media/video/msm/msm_camera.c
+++ b/drivers/media/video/msm/msm_camera.c
@@ -21,8 +21,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
 #include <mach/board.h>
 
 #include <linux/dma-mapping.h>
@@ -31,14 +29,15 @@
 #include <linux/uaccess.h>
 #include <linux/android_pmem.h>
 #include <linux/poll.h>
-#include <linux/time.h>
 #include <media/msm_camera.h>
 #include <mach/camera.h>
-
 #include <asm/cacheflush.h>
+#include <linux/rtc.h>
+#include <linux/slab.h>
+#include <mach/msm_flashlight.h>
+DEFINE_MUTEX(hlist_mut);
 
 #define MSM_MAX_CAMERA_SENSORS 5
-#define CAMERA_STOP_SNAPSHOT 42
 
 #define ERR_USER_COPY(to) pr_err("%s(%d): copy %s user\n", \
 				__func__, __LINE__, ((to) ? "to" : "from"))
@@ -85,6 +84,7 @@ static inline void free_qcmd(struct msm_queue_cmd *qcmd)
 {
 	if (!qcmd || !qcmd->on_heap)
 		return;
+	CDBG("%s qcmd->on_heap:%d\n",__func__,qcmd->on_heap);
 	if (!--qcmd->on_heap)
 		kfree(qcmd);
 }
@@ -105,10 +105,17 @@ static void msm_enqueue(struct msm_device_queue *queue,
 	unsigned long flags;
 	spin_lock_irqsave(&queue->lock, flags);
 	queue->len++;
+
 	if (queue->len > queue->max) {
 		queue->max = queue->len;
+#if 0
 		pr_info("%s: queue %s new max is %d\n", __func__,
 			queue->name, queue->max);
+#else
+		if(queue->max < 1024)
+			pr_info("%s: queue %s new max is %d\n", __func__,
+			queue->name, queue->max);
+#endif
 	}
 	list_add_tail(entry, &queue->list);
 	wake_up(&queue->wait);
@@ -117,33 +124,36 @@ static void msm_enqueue(struct msm_device_queue *queue,
 }
 
 #define msm_dequeue(queue, member) ({				\
-	unsigned long flags;					\
+	unsigned long flags;							\
 	struct msm_device_queue *__q = (queue);			\
-	struct msm_queue_cmd *qcmd = 0;				\
+	struct msm_queue_cmd *qcmd = 0;					\
 	spin_lock_irqsave(&__q->lock, flags);			\
-	if (!list_empty(&__q->list)) {				\
-		__q->len--;					\
-		qcmd = list_first_entry(&__q->list,		\
-				struct msm_queue_cmd, member);	\
-		list_del_init(&qcmd->member);			\
-	}							\
+	if (!list_empty(&__q->list)) {					\
+		__q->len--;									\
+		qcmd = list_first_entry(&__q->list,			\
+				struct msm_queue_cmd, member);		\
+				if (qcmd) {                         \
+					list_del_init(&qcmd->member);	\
+				}                                   \
+	}												\
 	spin_unlock_irqrestore(&__q->lock, flags);		\
-	qcmd;							\
+	qcmd;											\
 })
 
+
 #define msm_queue_drain(queue, member) do {			\
-	unsigned long flags;					\
+	unsigned long flags;							\
 	struct msm_device_queue *__q = (queue);			\
-	struct msm_queue_cmd *qcmd;				\
+	struct msm_queue_cmd *qcmd;						\
 	spin_lock_irqsave(&__q->lock, flags);			\
 	CDBG("%s: draining queue %s\n", __func__, __q->name);	\
-	while (!list_empty(&__q->list)) {			\
-		qcmd = list_first_entry(&__q->list,		\
-			struct msm_queue_cmd, member);		\
-		list_del_init(&qcmd->member);			\
-		free_qcmd(qcmd);				\
-	};							\
-	__q->len = 0;						\
+	while (!list_empty(&__q->list)) {				\
+		qcmd = list_first_entry(&__q->list,			\
+			struct msm_queue_cmd, member);			\
+		list_del_init(&qcmd->member);				\
+		free_qcmd(qcmd);							\
+	};												\
+	__q->len = 0;									\
 	spin_unlock_irqrestore(&__q->lock, flags);		\
 } while(0)
 
@@ -232,7 +242,7 @@ static int msm_pmem_table_add(struct hlist_head *ptype,
 		__func__,
 		info->type, paddr, (unsigned long)info->vaddr);
 
-	region = kmalloc(sizeof(struct msm_pmem_region), GFP_KERNEL);
+	region = kzalloc(sizeof(struct msm_pmem_region), GFP_KERNEL);
 	if (!region)
 		return -ENOMEM;
 
@@ -244,10 +254,6 @@ static int msm_pmem_table_add(struct hlist_head *ptype,
 	region->file = file;
 	memcpy(&region->info, info, sizeof(region->info));
 
-	if (info->vfe_can_write) {
-		dmac_map_area((void*)region->kvaddr, region->len, DMA_FROM_DEVICE);
-	}
-
 	hlist_add_head(&(region->list), ptype);
 
 	return 0;
@@ -264,7 +270,7 @@ static uint8_t msm_pmem_region_lookup(struct hlist_head *ptype,
 	uint8_t rc = 0;
 
 	regptr = reg;
-
+	mutex_lock(&hlist_mut);
 	hlist_for_each_entry_safe(region, node, n, ptype, list) {
 		if (region->info.type == pmem_type &&
 			region->info.vfe_can_write) {
@@ -275,7 +281,7 @@ static uint8_t msm_pmem_region_lookup(struct hlist_head *ptype,
 				regptr++;
 		}
 	}
-
+	mutex_unlock(&hlist_mut);
 	return rc;
 }
 
@@ -289,13 +295,19 @@ static int msm_pmem_frame_ptov_lookup(struct msm_sync *sync,
 
 	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
 		if (pyaddr == (region->paddr + region->info.y_off) &&
+#ifndef CONFIG_ARCH_MSM7225
 				pcbcraddr == (region->paddr +
 						region->info.cbcr_off) &&
+#endif
 				region->info.vfe_can_write) {
 			*pmem_region = region;
-			dmac_unmap_area((void*)region->kvaddr, region->len,
-					DMA_FROM_DEVICE);
 			region->info.vfe_can_write = !take_from_vfe;
+#ifdef CONFIG_ARCH_MSM7225
+			if (pcbcraddr != (region->paddr + region->info.cbcr_off)) {
+				pr_err("%s cbcr addr = %lx, NOT EQUAL to region->paddr + region->info.cbcr_off = %lx\n",
+					__func__, pcbcraddr, region->paddr + region->info.cbcr_off);
+			}
+#endif
 			return 0;
 		}
 	}
@@ -314,13 +326,22 @@ static unsigned long msm_pmem_stats_ptov_lookup(struct msm_sync *sync,
 			/* offset since we could pass vaddr inside a
 			 * registered pmem buffer */
 			*fd = region->info.fd;
-			dmac_unmap_area((void*)region->kvaddr, region->len,
-					DMA_FROM_DEVICE);
 			region->info.vfe_can_write = 0;
 			return (unsigned long)(region->info.vaddr);
 		}
 	}
-
+#if 1
+	printk("msm_pmem_stats_ptov_lookup: lookup vaddr..\n");
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_stats, list) {
+		if (addr == (unsigned long)(region->info.vaddr)) {
+			/* offset since we could pass vaddr inside a
+			 * registered pmem buffer */
+			*fd = region->info.fd;
+			region->info.vfe_can_write = 0;
+			return (unsigned long)(region->info.vaddr);
+		}
+	}
+#endif
 	return 0;
 }
 
@@ -338,7 +359,6 @@ static unsigned long msm_pmem_frame_vtop_lookup(struct msm_sync *sync,
 				(region->info.cbcr_off == cbcroff) &&
 				(region->info.fd == fd) &&
 				(region->info.vfe_can_write == 0)) {
-			dmac_map_area((void*)region->kvaddr, region->len, DMA_FROM_DEVICE);
 			region->info.vfe_can_write = 1;
 			return region->paddr;
 		}
@@ -359,7 +379,6 @@ static unsigned long msm_pmem_stats_vtop_lookup(
 		if (((unsigned long)(region->info.vaddr) == buffer) &&
 				(region->info.fd == fd) &&
 				region->info.vfe_can_write == 0) {
-			dmac_map_area((void*)region->kvaddr, region->len, DMA_FROM_DEVICE);
 			region->info.vfe_can_write = 1;
 			return region->paddr;
 		}
@@ -376,10 +395,13 @@ static int __msm_pmem_table_del(struct msm_sync *sync,
 	struct hlist_node *node, *n;
 
 	switch (pinfo->type) {
+#ifndef CONFIG_720P_CAMERA
 	case MSM_PMEM_OUTPUT1:
 	case MSM_PMEM_OUTPUT2:
+#else
 	case MSM_PMEM_VIDEO:
 	case MSM_PMEM_PREVIEW:
+#endif
 	case MSM_PMEM_THUMBNAIL:
 	case MSM_PMEM_MAINIMG:
 	case MSM_PMEM_RAW_MAINIMG:
@@ -391,10 +413,6 @@ static int __msm_pmem_table_del(struct msm_sync *sync,
 					pinfo->fd == region->info.fd) {
 				hlist_del(node);
 				put_pmem_file(region->file);
-				if (region->info.vfe_can_write) {
-					dmac_unmap_area((void*)region->kvaddr, region->len,
-							DMA_FROM_DEVICE);
-				}
 				kfree(region);
 			}
 		}
@@ -410,10 +428,6 @@ static int __msm_pmem_table_del(struct msm_sync *sync,
 					pinfo->fd == region->info.fd) {
 				hlist_del(node);
 				put_pmem_file(region->file);
-				if (region->info.vfe_can_write) {
-					dmac_unmap_area((void*)region->kvaddr, region->len,
-							DMA_FROM_DEVICE);
-				}
 				kfree(region);
 			}
 		}
@@ -449,7 +463,9 @@ static int __msm_get_frame(struct msm_sync *sync,
 	struct msm_vfe_resp *vdata;
 	struct msm_vfe_phy_info *pphy;
 
-	qcmd = msm_dequeue(&sync->frame_q, list_frame);
+	if (&sync->frame_q) {
+		qcmd = msm_dequeue(&sync->frame_q, list_frame);
+	}
 
 	if (!qcmd) {
 		pr_err("%s: no preview frame.\n", __func__);
@@ -479,7 +495,6 @@ static int __msm_get_frame(struct msm_sync *sync,
 	frame->cbcr_off = region->info.cbcr_off;
 	frame->fd = region->info.fd;
 	frame->path = vdata->phy.output_id;
-
 	CDBG("%s: y %x, cbcr %x, qcmd %x, virt_addr %x\n",
 		__func__,
 		pphy->y_phy, pphy->cbcr_phy, (int) qcmd, (int) frame->buffer);
@@ -598,7 +613,7 @@ static struct msm_queue_cmd *__msm_control(struct msm_sync *sync,
 			 * need to remove it.  Alternatively, qcmd may have
 			 * been dequeued and processed already, in which case
 			 * the list removal will be a no-op.
-			 */
+			*/
 			list_del_init(&qcmd->list_config);
 			return ERR_PTR(rc);
 		}
@@ -623,7 +638,7 @@ static struct msm_queue_cmd *__msm_control_nb(struct msm_sync *sync,
 	struct msm_ctrl_cmd *udata_to_copy = qcmd_to_copy->command;
 
 	struct msm_queue_cmd *qcmd =
-			kmalloc(sizeof(*qcmd_to_copy) +
+			kzalloc(sizeof(*qcmd_to_copy) +
 				sizeof(*udata_to_copy) +
 				udata_to_copy->length,
 				GFP_KERNEL);
@@ -665,8 +680,7 @@ static int msm_control(struct msm_control_device *ctrl_pmsm,
 
 	uptr = udata.value;
 	udata.value = data;
-	if (udata.type == CAMERA_STOP_SNAPSHOT)
-		sync->get_pic_abort = 1;
+
 	qcmd.on_heap = 0;
 	qcmd.type = MSM_CAM_Q_CTRL;
 	qcmd.command = &udata;
@@ -864,7 +878,7 @@ static int msm_get_stats(struct msm_sync *sync, void __user *arg)
 		if (rc == 0)
 			rc = -ETIMEDOUT;
 		if (rc < 0) {
-			pr_err("%s: error %d\n", __func__, rc);
+			pr_err("\n%s: error %d\n", __func__, rc);
 			return rc;
 		}
 	}
@@ -875,6 +889,13 @@ static int msm_get_stats(struct msm_sync *sync, void __user *arg)
 	qcmd = msm_dequeue(&sync->event_q, list_config);
 	BUG_ON(!qcmd);
 
+	/* HTC: check qcmd */
+	if (!qcmd) {
+		rc = -EFAULT;
+		pr_err("%s: qcmd is NULL, rc %d\n", __func__, rc);
+		return rc;
+	}
+
 	CDBG("%s: received from DSP %d\n", __func__, qcmd->type);
 
 	switch (qcmd->type) {
@@ -895,20 +916,22 @@ static int msm_get_stats(struct msm_sync *sync, void __user *arg)
 			se.stats_event.len,
 			se.stats_event.msg_id);
 
-		if (data->type == VFE_MSG_STATS_AF ||
-		    data->type ==  VFE_MSG_STATS_WE ||
-			(data->type >=  VFE_MSG_STATS_AEC &&
-			 data->type <= VFE_MSG_STATS_SKIN)) {
-			/* the check above includes all stats type. */
+		if ((data->type == VFE_MSG_STATS_AF) ||
+				(data->type == VFE_MSG_STATS_WE)) {
+
 			stats.buffer =
 			msm_pmem_stats_ptov_lookup(sync,
 					data->phy.sbuf_phy,
 					&(stats.fd));
 			if (!stats.buffer) {
-				pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
-					__func__);
+				pr_err("%s: msm_pmem_stats_ptov_lookup error, addr = %x\n",
+					__func__,data->phy.sbuf_phy);
+#if 1
+				se.resptype = MSM_CAM_RESP_MAX;
+#else
 				rc = -EINVAL;
 				goto failure;
+#endif
 			}
 
 			if (copy_to_user((void *)(se.stats_event.data),
@@ -928,16 +951,26 @@ static int msm_get_stats(struct msm_sync *sync, void __user *arg)
 				goto failure;
 			}
 		} else {
+#ifndef CONFIG_720P_CAMERA
 			if ((sync->pp_mask & PP_PREV) &&
-				(data->type == VFE_MSG_OUTPUT1 ||
-				 data->type == VFE_MSG_OUTPUT2 ||
-				 data->type == VFE_MSG_OUTPUT_P))
+					(data->type == VFE_MSG_OUTPUT1 ||
+					data->type == VFE_MSG_OUTPUT2))
+					rc = msm_divert_frame(sync, data, &se);
+			else if ((sync->pp_mask & (PP_SNAP|PP_RAW_SNAP)) &&
+				  data->type == VFE_MSG_SNAPSHOT)
+					rc = msm_divert_snapshot(sync,
+								data, &se);
+#else
+			if ((sync->pp_mask & PP_PREV) &&
+				(data->type == VFE_MSG_OUTPUT_P))
 					rc = msm_divert_frame(sync, data, &se);
 			else if ((sync->pp_mask & (PP_SNAP|PP_RAW_SNAP)) &&
 				  (data->type == VFE_MSG_SNAPSHOT ||
+				   data->type == VFE_MSG_OUTPUT_T ||
 				   data->type == VFE_MSG_OUTPUT_S))
 					rc = msm_divert_snapshot(sync,
 								data, &se);
+#endif
 		}
 		break;
 
@@ -1075,11 +1108,20 @@ static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
 		axi_data.bufnum1 =
 			msm_pmem_region_lookup(&sync->pmem_stats,
 					MSM_PMEM_AEC_AWB, &region[0],
-					NUM_STAT_OUTPUT_BUFFERS);
+					NUM_WB_EXP_STAT_OUTPUT_BUFFERS);
+
+	/* HTC: check axi_data.bufnum1 if out of bound of "region" array */
+	   if (!axi_data.bufnum1 || axi_data.bufnum1 >=
+			(sizeof(region)/sizeof(struct msm_pmem_region))) {
+		  pr_err("%s %d: pmem region lookup error or out of bound\n",
+				__func__, __LINE__);
+		  return -EINVAL;
+		}
+
 		axi_data.bufnum2 =
 			msm_pmem_region_lookup(&sync->pmem_stats,
 					MSM_PMEM_AF, &region[axi_data.bufnum1],
-					NUM_STAT_OUTPUT_BUFFERS);
+					NUM_AF_STAT_OUTPUT_BUFFERS);
 		if (!axi_data.bufnum1 || !axi_data.bufnum2) {
 			pr_err("%s: pmem region lookup error\n", __func__);
 			return -EINVAL;
@@ -1090,7 +1132,7 @@ static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
 		axi_data.bufnum1 =
 			msm_pmem_region_lookup(&sync->pmem_stats,
 					MSM_PMEM_AF, &region[0],
-					NUM_STAT_OUTPUT_BUFFERS);
+					NUM_AF_STAT_OUTPUT_BUFFERS);
 		if (!axi_data.bufnum1) {
 			pr_err("%s %d: pmem region lookup error\n",
 				__func__, __LINE__);
@@ -1098,35 +1140,12 @@ static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
 		}
 		axi_data.region = &region[0];
 		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+
 	case CMD_STATS_AEC_AWB_ENABLE:
 		axi_data.bufnum1 =
 			msm_pmem_region_lookup(&sync->pmem_stats,
 					MSM_PMEM_AEC_AWB, &region[0],
-					NUM_STAT_OUTPUT_BUFFERS);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		axi_data.region = &region[0];
-		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-	case CMD_STATS_AEC_ENABLE:
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_stats,
-			MSM_PMEM_AEC, &region[0],
-			NUM_STAT_OUTPUT_BUFFERS);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		axi_data.region = &region[0];
-		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-	case CMD_STATS_AWB_ENABLE:
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_stats,
-			MSM_PMEM_AWB, &region[0],
-			NUM_STAT_OUTPUT_BUFFERS);
+					NUM_WB_EXP_STAT_OUTPUT_BUFFERS);
 		if (!axi_data.bufnum1) {
 			pr_err("%s %d: pmem region lookup error\n",
 				__func__, __LINE__);
@@ -1134,47 +1153,6 @@ static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
 		}
 		axi_data.region = &region[0];
 		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-
-
-	case CMD_STATS_IHIST_ENABLE:
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_stats,
-			MSM_PMEM_IHIST, &region[0],
-			NUM_STAT_OUTPUT_BUFFERS);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		axi_data.region = &region[0];
-		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-
-	case CMD_STATS_RS_ENABLE:
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_stats,
-			MSM_PMEM_RS, &region[0],
-			NUM_STAT_OUTPUT_BUFFERS);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		axi_data.region = &region[0];
-		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-
-	case CMD_STATS_CS_ENABLE:
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_stats,
-			MSM_PMEM_CS, &region[0],
-			NUM_STAT_OUTPUT_BUFFERS);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		axi_data.region = &region[0];
-		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
-
 	case CMD_GENERAL:
 	case CMD_STATS_DISABLE:
 		return sync->vfefn.vfe_config(&cfgcmd, NULL);
@@ -1198,6 +1176,8 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 	memset(&axi_data, 0, sizeof(axi_data));
 
 	switch (cfgcmd->cmd_type) {
+
+#ifndef CONFIG_720P_CAMERA
 	case CMD_AXI_CFG_OUT1:
 		pmem_type = MSM_PMEM_OUTPUT1;
 		axi_data.bufnum1 =
@@ -1223,6 +1203,31 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 		}
 		break;
 
+	case CMD_AXI_CFG_SNAP_O1_AND_O2:
+		pmem_type = MSM_PMEM_THUMBNAIL;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], 8);
+
+	/* HTC: check axi_data.bufnum1 if out of bound of "region" array */
+		if (!axi_data.bufnum1 || axi_data.bufnum1 >=
+			(sizeof(region)/sizeof(struct msm_pmem_region))) {
+		  pr_err("%s %d: pmem region lookup error or out of bound\n",
+				__func__, __LINE__);
+		  return -EINVAL;
+		}
+
+		pmem_type = MSM_PMEM_MAINIMG;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[axi_data.bufnum1], 8);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+#else
 	case CMD_AXI_CFG_PREVIEW:
 		pmem_type = MSM_PMEM_PREVIEW;
 		axi_data.bufnum2 =
@@ -1259,31 +1264,8 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 		}
 		break;
 
-	case CMD_AXI_CFG_O1_AND_O2:
-		pmem_type = MSM_PMEM_OUTPUT1;
-		axi_data.bufnum1 =
-			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
-				&region[0], 8);
-		if (!axi_data.bufnum1) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-
-		pmem_type = MSM_PMEM_OUTPUT2;
-		axi_data.bufnum2 =
-			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
-				&region[axi_data.bufnum1],
-				(8-(axi_data.bufnum1)));
-		if (!axi_data.bufnum2) {
-			pr_err("%s %d: pmem region lookup error\n",
-				__func__, __LINE__);
-			return -EINVAL;
-		}
-		break;
 
 	case CMD_AXI_CFG_SNAP:
-	case CMD_AXI_CFG_SNAP_O1_AND_O2:
 		pmem_type = MSM_PMEM_THUMBNAIL;
 		axi_data.bufnum1 =
 			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
@@ -1305,7 +1287,7 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 			return -EINVAL;
 		}
 		break;
-
+#endif
 	case CMD_RAW_PICT_AXI_CFG:
 		pmem_type = MSM_PMEM_RAW_MAINIMG;
 		axi_data.bufnum2 =
@@ -1331,6 +1313,7 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 	axi_data.region = &region[0];
 
 	/* send the AXI configuration command to driver */
+
 	if (sync->vfefn.vfe_config)
 		rc = sync->vfefn.vfe_config(cfgcmd, data);
 
@@ -1356,7 +1339,7 @@ static int msm_get_sensor_info(struct msm_sync *sync, void __user *arg)
 	memcpy(&info.name[0],
 		sdata->sensor_name,
 		MAX_SENSOR_NAME);
-	info.flash_enabled = !!sdata->camera_flash;
+	info.flash_enabled = !!sdata->flash_cfg;
 
 	/* copy back to user space */
 	if (copy_to_user((void *)arg,
@@ -1387,12 +1370,12 @@ static int __msm_put_frame_buf(struct msm_sync *sync,
 			pb->buffer, pphy);
 		cfgcmd.cmd_type = CMD_FRAME_BUF_RELEASE;
 		cfgcmd.value    = (void *)pb;
-		if (sync->vfefn.vfe_config)
+		if (sync->vfefn.vfe_config) {
 			rc = sync->vfefn.vfe_config(&cfgcmd, &pphy);
+    }
 	} else {
-		pr_err("%s: msm_pmem_frame_vtop_lookup failed. "
-			"buffer=0x%lx, y_off=%d, cbcr_off=%d, fd=%d\n",
-			__func__, pb->buffer, pb->y_off, pb->cbcr_off, pb->fd);
+		pr_err("%s: msm_pmem_frame_vtop_lookup failed\n",
+			__func__);
 		rc = -EINVAL;
 	}
 
@@ -1419,10 +1402,13 @@ static int __msm_register_pmem(struct msm_sync *sync,
 	int rc = 0;
 
 	switch (pinfo->type) {
+#ifndef CONFIG_720P_CAMERA
 	case MSM_PMEM_OUTPUT1:
 	case MSM_PMEM_OUTPUT2:
+#else
 	case MSM_PMEM_VIDEO:
 	case MSM_PMEM_PREVIEW:
+#endif
 	case MSM_PMEM_THUMBNAIL:
 	case MSM_PMEM_MAINIMG:
 	case MSM_PMEM_RAW_MAINIMG:
@@ -1431,13 +1417,6 @@ static int __msm_register_pmem(struct msm_sync *sync,
 
 	case MSM_PMEM_AEC_AWB:
 	case MSM_PMEM_AF:
-	case MSM_PMEM_AEC:
-	case MSM_PMEM_AWB:
-	case MSM_PMEM_RS:
-	case MSM_PMEM_CS:
-	case MSM_PMEM_IHIST:
-	case MSM_PMEM_SKIN:
-
 		rc = msm_pmem_table_add(&sync->pmem_stats, pinfo);
 		break;
 
@@ -1492,7 +1471,7 @@ static int msm_stats_axi_cfg(struct msm_sync *sync,
 	if (cfgcmd->cmd_type != CMD_GENERAL) {
 		axi_data.bufnum1 =
 			msm_pmem_region_lookup(&sync->pmem_stats, pmem_type,
-				&region[0], NUM_STAT_OUTPUT_BUFFERS);
+				&region[0], NUM_WB_EXP_STAT_OUTPUT_BUFFERS);
 		if (!axi_data.bufnum1) {
 			pr_err("%s %d: pmem region lookup error\n",
 				__func__, __LINE__);
@@ -1502,6 +1481,7 @@ static int msm_stats_axi_cfg(struct msm_sync *sync,
 	}
 
 	/* send the AEC/AWB STATS configuration command to driver */
+
 	if (sync->vfefn.vfe_config)
 		rc = sync->vfefn.vfe_config(cfgcmd, &axi_data);
 
@@ -1530,17 +1510,6 @@ static int msm_put_stats_buffer(struct msm_sync *sync, void __user *arg)
 			cfgcmd.cmd_type = CMD_STATS_BUF_RELEASE;
 		else if (buf.type == STAT_AF)
 			cfgcmd.cmd_type = CMD_STATS_AF_BUF_RELEASE;
-		else if (buf.type == STAT_AEC)
-			cfgcmd.cmd_type = CMD_STATS_AEC_BUF_RELEASE;
-		else if (buf.type == STAT_AWB)
-			cfgcmd.cmd_type = CMD_STATS_AWB_BUF_RELEASE;
-		else if (buf.type == STAT_IHIST)
-			cfgcmd.cmd_type = CMD_STATS_IHIST_BUF_RELEASE;
-		else if (buf.type == STAT_RS)
-			cfgcmd.cmd_type = CMD_STATS_RS_BUF_RELEASE;
-		else if (buf.type == STAT_CS)
-			cfgcmd.cmd_type = CMD_STATS_CS_BUF_RELEASE;
-
 		else {
 			pr_err("%s: invalid buf type %d\n",
 				__func__,
@@ -1550,7 +1519,6 @@ static int msm_put_stats_buffer(struct msm_sync *sync, void __user *arg)
 		}
 
 		cfgcmd.value = (void *)&buf;
-
 		if (sync->vfefn.vfe_config) {
 			rc = sync->vfefn.vfe_config(&cfgcmd, &pphy);
 			if (rc < 0)
@@ -1577,13 +1545,15 @@ static int msm_axi_config(struct msm_sync *sync, void __user *arg)
 	}
 
 	switch (cfgcmd.cmd_type) {
+#ifndef CONFIG_720P_CAMERA
 	case CMD_AXI_CFG_OUT1:
 	case CMD_AXI_CFG_OUT2:
-	case CMD_AXI_CFG_O1_AND_O2:
 	case CMD_AXI_CFG_SNAP_O1_AND_O2:
+#else
 	case CMD_AXI_CFG_VIDEO:
 	case CMD_AXI_CFG_PREVIEW:
 	case CMD_AXI_CFG_SNAP:
+#endif
 	case CMD_RAW_PICT_AXI_CFG:
 		return msm_frame_axi_cfg(sync, &cfgcmd);
 
@@ -1612,14 +1582,8 @@ static int __msm_get_pic(struct msm_sync *sync, struct msm_ctrl_cmd *ctrl)
 
 	rc = wait_event_interruptible_timeout(
 			sync->pict_q.wait,
-			!list_empty_careful(
-				&sync->pict_q.list) || sync->get_pic_abort,
+			!list_empty_careful(&sync->pict_q.list),
 			msecs_to_jiffies(tm));
-
-	if (sync->get_pic_abort == 1) {
-		sync->get_pic_abort = 0;
-		return -ENODATA;
-	}
 	if (list_empty_careful(&sync->pict_q.list)) {
 		if (rc == 0)
 			return -ETIMEDOUT;
@@ -1634,6 +1598,13 @@ static int __msm_get_pic(struct msm_sync *sync, struct msm_ctrl_cmd *ctrl)
 	qcmd = msm_dequeue(&sync->pict_q, list_pict);
 	BUG_ON(!qcmd);
 
+	/* HTC: check qcmd */
+    if (!qcmd) {
+      rc = -EFAULT;
+      pr_err("%s: qcmd is NULL, rc %d\n", __func__, rc);
+	  return rc;
+    }
+
 	if (qcmd->command != NULL) {
 		struct msm_ctrl_cmd *q =
 			(struct msm_ctrl_cmd *)qcmd->command;
@@ -1652,8 +1623,7 @@ static int __msm_get_pic(struct msm_sync *sync, struct msm_ctrl_cmd *ctrl)
 static int msm_get_pic(struct msm_sync *sync, void __user *arg)
 {
 	struct msm_ctrl_cmd ctrlcmd;
-	struct msm_pmem_region *pic_pmem_region = NULL, *region;
-	struct hlist_node *node, *n;
+	struct msm_pmem_region pic_pmem_region;
 	int rc;
 	unsigned long end;
 	int cline_mask;
@@ -1685,31 +1655,31 @@ static int msm_get_pic(struct msm_sync *sync, void __user *arg)
 		}
 	}
 
-	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
-		if (region->info.vfe_can_write &&
-				(region->info.type == MSM_PMEM_MAINIMG ||
-				region->info.type == MSM_PMEM_RAW_MAINIMG)) {
-			pic_pmem_region = region;
-			break;
+	if (msm_pmem_region_lookup(&sync->pmem_frames,
+			MSM_PMEM_MAINIMG,
+			&pic_pmem_region, 1) == 0) {
+		pr_err("%s pmem region lookup error\n", __func__);
+		pr_info("%s probably getting RAW\n", __func__);
+		if (msm_pmem_region_lookup(&sync->pmem_frames,
+				MSM_PMEM_RAW_MAINIMG,
+				&pic_pmem_region, 1) == 0) {
+			pr_err("%s RAW pmem region lookup error\n", __func__);
+			return -EIO;
 		}
 	}
 
-	if (!pic_pmem_region) {
-		pr_err("%s pmem region lookup error\n", __func__);
-		return -EIO;
-	}
 	cline_mask = cache_line_size() - 1;
-	end = pic_pmem_region->kvaddr + pic_pmem_region->len;
+	end = pic_pmem_region.kvaddr + pic_pmem_region.len;
 	end = (end + cline_mask) & ~cline_mask;
 
 	pr_info("%s: flushing cache for [%08lx, %08lx)\n",
 		__func__,
-		pic_pmem_region->kvaddr, end);
+		pic_pmem_region.kvaddr, end);
 
-	/* HACK: Invalidate buffer */
-	dmac_unmap_area((void*)pic_pmem_region->kvaddr, pic_pmem_region->len,
-			DMA_FROM_DEVICE);
-	pic_pmem_region->info.vfe_can_write = 0;
+        /* HACK: Invalidate buffer */
+        dmac_unmap_area((void*)pic_pmem_region.kvaddr, pic_pmem_region.len,
+                        DMA_FROM_DEVICE);
+        pic_pmem_region.info.vfe_can_write = 0;
 
 	CDBG("%s: copy snapshot frame to user\n", __func__);
 	if (copy_to_user((void *)arg,
@@ -1733,7 +1703,7 @@ static int msm_set_crop(struct msm_sync *sync, void __user *arg)
 	}
 
 	if (!sync->croplen) {
-		sync->cropinfo = kmalloc(crop.len, GFP_KERNEL);
+		sync->cropinfo = kzalloc(crop.len, GFP_KERNEL);
 		if (!sync->cropinfo)
 			return -ENOMEM;
 	} else if (sync->croplen < crop.len)
@@ -1800,7 +1770,6 @@ static int msm_pp_release(struct msm_sync *sync, void __user *arg)
 			return -EINVAL;
 		}
 		pr_info("%s: delivering pp_prev\n", __func__);
-
 		msm_enqueue(&sync->frame_q, &sync->pp_prev->list_frame);
 		sync->pp_prev = NULL;
 		goto done;
@@ -1840,34 +1809,54 @@ static long msm_ioctl_common(struct msm_device *pmsm,
 
 int msm_camera_flash(struct msm_sync *sync, int level)
 {
-	int flash_level;
+	int flash_level = 0;
+	uint8_t phy_flash = 0;
+	int ret = 0;
 
-	if (!sync->sdata->camera_flash) {
+	if (!sync->sdata->flash_cfg) {
 		pr_err("%s: camera flash is not supported.\n", __func__);
 		return -EINVAL;
 	}
 
-	if (!sync->sdata->num_flash_levels) {
+	if (!sync->sdata->flash_cfg->num_flash_levels) {
 		pr_err("%s: no flash levels.\n", __func__);
 		return -EINVAL;
 	}
 
+	sync->sdata->flash_cfg->postpone_led_mode = MSM_CAMERA_LED_OFF;
+
 	switch (level) {
+	case MSM_CAMERA_LED_DEATH_RAY:
+		flash_level = FL_MODE_DEATH_RAY;
+		phy_flash = 1;
+		break;
+	case MSM_CAMERA_LED_LOW_FOR_SNAPSHOT:
+		/* postpone set led low*/
+		sync->sdata->flash_cfg->postpone_led_mode = MSM_CAMERA_LED_LOW;
+		phy_flash = 0;
+		break;
 	case MSM_CAMERA_LED_HIGH:
-		flash_level = sync->sdata->num_flash_levels - 1;
+		/* postpone set led high*/
+		sync->sdata->flash_cfg->postpone_led_mode = MSM_CAMERA_LED_HIGH;
+		phy_flash = 0;
 		break;
 	case MSM_CAMERA_LED_LOW:
-		flash_level = sync->sdata->num_flash_levels / 2;
+		flash_level = sync->sdata->flash_cfg->num_flash_levels / 2;
+		phy_flash = 1;
 		break;
 	case MSM_CAMERA_LED_OFF:
 		flash_level = 0;
+		phy_flash = 1;
 		break;
 	default:
 		pr_err("%s: invalid flash level %d.\n", __func__, level);
 		return -EINVAL;
 	}
 
-	return sync->sdata->camera_flash(level);
+	if (phy_flash)
+		ret = sync->sdata->flash_cfg->camera_flash(flash_level);
+
+	return ret;
 }
 
 static long msm_ioctl_config(struct file *filep, unsigned int cmd,
@@ -1950,8 +1939,7 @@ static long msm_ioctl_config(struct file *filep, unsigned int cmd,
 		} else
 			rc = msm_camera_flash(pmsm->sync, led_state);
 		break;
-	}
-
+		}
 	case MSM_CAM_IOCTL_ENABLE_OUTPUT_IND: {
 		uint32_t enable;
 		if (copy_from_user(&enable, argp, sizeof(enable))) {
@@ -1959,11 +1947,7 @@ static long msm_ioctl_config(struct file *filep, unsigned int cmd,
 			rc = -EFAULT;
 			break;
 		}
-		pr_info("%s: copying all preview frames to config: %d\n",
-			__func__, enable);
 		pmsm->sync->report_preview_to_config = enable;
-		rc = 0;
-		break;
 	}
 
 	default:
@@ -1984,7 +1968,6 @@ static long msm_ioctl_frame(struct file *filep, unsigned int cmd,
 	void __user *argp = (void __user *)arg;
 	struct msm_device *pmsm = filep->private_data;
 
-
 	switch (cmd) {
 	case MSM_CAM_IOCTL_GETFRAME:
 		/* Coming from frame thread to get frame
@@ -2043,17 +2026,33 @@ static long msm_ioctl_control(struct file *filep, unsigned int cmd,
 	return rc;
 }
 
+
+static void msm_show_time(void){
+	struct timespec ts;
+	struct rtc_time tm;
+	getnstimeofday(&ts);
+	rtc_time_to_tm(ts.tv_sec, &tm);
+	pr_info(">>>>>>>>(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)<<<<<<<\n",
+		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	return;
+}
+
+
 static int __msm_release(struct msm_sync *sync)
 {
 	struct msm_pmem_region *region;
 	struct hlist_node *hnode;
 	struct hlist_node *n;
-
+       pr_info("%s:sync->opencnt:%d \n", __func__, sync->opencnt);
 	mutex_lock(&sync->lock);
 	if (sync->opencnt)
 		sync->opencnt--;
 
 	if (!sync->opencnt) {
+
+		msm_show_time();
+
 		/* need to clean up system resource */
 		if (sync->vfefn.vfe_release)
 			sync->vfefn.vfe_release(sync->pdev);
@@ -2062,6 +2061,8 @@ static int __msm_release(struct msm_sync *sync)
 		sync->cropinfo = NULL;
 		sync->croplen = 0;
 
+		/*sensor release moved to vfe_release*/
+
 		hlist_for_each_entry_safe(region, hnode, n,
 				&sync->pmem_frames, list) {
 			hlist_del(hnode);
@@ -2075,8 +2076,12 @@ static int __msm_release(struct msm_sync *sync)
 			put_pmem_file(region->file);
 			kfree(region);
 		}
+
+		msm_queue_drain(&sync->event_q, list_config);
+		msm_queue_drain(&sync->frame_q, list_frame);
 		msm_queue_drain(&sync->pict_q, list_pict);
 
+		wake_unlock(&sync->wake_suspend_lock);
 		wake_unlock(&sync->wake_lock);
 
 		sync->apps_id = NULL;
@@ -2091,10 +2096,10 @@ static int msm_release_config(struct inode *node, struct file *filep)
 {
 	int rc;
 	struct msm_device *pmsm = filep->private_data;
-	CDBG("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
 	rc = __msm_release(pmsm->sync);
 	if (!rc) {
-		msm_queue_drain(&pmsm->sync->event_q, list_config);
+		pr_info("release config atomic_set pmsm->opened as 0\n");
 		atomic_set(&pmsm->opened, 0);
 	}
 	return rc;
@@ -2105,7 +2110,7 @@ static int msm_release_control(struct inode *node, struct file *filep)
 	int rc;
 	struct msm_control_device *ctrl_pmsm = filep->private_data;
 	struct msm_device *pmsm = ctrl_pmsm->pmsm;
-	CDBG("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
 	rc = __msm_release(pmsm->sync);
 	if (!rc) {
 		msm_queue_drain(&ctrl_pmsm->ctrl_q, list_control);
@@ -2118,10 +2123,10 @@ static int msm_release_frame(struct inode *node, struct file *filep)
 {
 	int rc;
 	struct msm_device *pmsm = filep->private_data;
-	CDBG("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
 	rc = __msm_release(pmsm->sync);
 	if (!rc) {
-		msm_queue_drain(&pmsm->sync->frame_q, list_frame);
+		pr_info("release frame atomic_set pmsm->opened as 0\n");
 		atomic_set(&pmsm->opened, 0);
 	}
 	return rc;
@@ -2177,8 +2182,11 @@ static void *msm_vfe_sync_alloc(int size,
 			gfp_t gfp)
 {
 	struct msm_queue_cmd *qcmd =
-		kmalloc(sizeof(struct msm_queue_cmd) + size, gfp);
+		kzalloc(sizeof(struct msm_queue_cmd) + size, gfp);
 	if (qcmd) {
+		/* Becker and kant */
+		memset(qcmd, 0x0, sizeof(struct msm_queue_cmd) + size);
+
 		qcmd->on_heap = 1;
 		return qcmd + 1;
 	}
@@ -2221,14 +2229,40 @@ static void msm_vfe_sync(struct msm_vfe_resp *vdata,
 	qcmd->type = qtype;
 	qcmd->command = vdata;
 
+	CDBG("%s: qtype %d \n", __func__, qtype);
+	CDBG("%s: evt_msg.msg_id %d\n", __func__, vdata->evt_msg.msg_id);
+	CDBG("%s: evt_msg.exttype %d\n", __func__, vdata->evt_msg.exttype);
+	if (sync->sdata->flash_cfg) {
+		if (qtype == MSM_CAM_Q_VFE_MSG &&
+			vdata->evt_msg.exttype == VFE_MSG_SNAPSHOT) {
+#if defined(CONFIG_ARCH_MSM_ARM11)
+			if (vdata->evt_msg.msg_id == 4)
+			/* QDSP_VFETASK_MSG_VFE_START_ACK */
+#elif defined(CONFIG_ARCH_QSD8X50)
+			if (vdata->evt_msg.msg_id == 1)
+			/* VFE_MSG_ID_START_ACK */
+#endif
+			{
+				pr_info("flashlight: postpone_led_mode %d\n",
+					sync->sdata->flash_cfg->postpone_led_mode);
+				sync->sdata->flash_cfg->camera_flash(
+					sync->sdata->flash_cfg->postpone_led_mode);
+			}
+		}
+	}
+
 	if (qtype != MSM_CAM_Q_VFE_MSG)
 		goto for_config;
-
+	
 	CDBG("%s: vdata->type %d\n", __func__, vdata->type);
 	switch (vdata->type) {
+#ifndef CONFIG_720P_CAMERA
 	case VFE_MSG_OUTPUT1:
 	case VFE_MSG_OUTPUT2:
+#else
 	case VFE_MSG_OUTPUT_P:
+#endif
+
 		if (sync->pp_mask & PP_PREV) {
 			CDBG("%s: PP_PREV in progress: phy_y %x phy_cbcr %x\n",
 				__func__,
@@ -2239,24 +2273,24 @@ static void msm_vfe_sync(struct msm_vfe_resp *vdata,
 					__func__);
 			pr_info("%s: sending preview to config\n", __func__);
 			sync->pp_prev = qcmd;
-			break;
-		}
-
-		if (sync->report_preview_to_config) {
 			if (qcmd->on_heap)
 				qcmd->on_heap++;
-			msm_enqueue(&sync->frame_q, &qcmd->list_frame);
-			break;
-		}
+				break;
+			}
+		CDBG("%s: msm_enqueue frame_q\n", __func__);
+		if (qcmd->on_heap)
+			qcmd->on_heap++;
 		msm_enqueue(&sync->frame_q, &qcmd->list_frame);
-		return;
+		break;
 
-	case VFE_MSG_OUTPUT_V:
+#ifdef CONFIG_720P_CAMERA
+		case VFE_MSG_OUTPUT_V:
+			if (qcmd->on_heap)
+				qcmd->on_heap++;
 		CDBG("%s: msm_enqueue video frame_q\n", __func__);
-		if (qcmd->on_heap)
-			qcmd->on_heap++;
 		msm_enqueue(&sync->frame_q, &qcmd->list_frame);
 		break;
+#endif
 
 	case VFE_MSG_SNAPSHOT:
 		if (sync->pp_mask & (PP_SNAP | PP_RAW_SNAP)) {
@@ -2267,46 +2301,16 @@ static void msm_vfe_sync(struct msm_vfe_resp *vdata,
 					__func__);
 			pr_info("%s: sending snapshot to config\n", __func__);
 			sync->pp_snap = qcmd;
-			break;
+			if (qcmd->on_heap)
+				qcmd->on_heap++;
+				break;
 		}
-
 		if (qcmd->on_heap)
 			qcmd->on_heap++;
 		msm_enqueue(&sync->pict_q, &qcmd->list_pict);
 		break;
 
-	case VFE_MSG_STATS_AWB:
-		CDBG("%s: qtype %d, AWB stats, enqueue event_q.\n",
-		     __func__, vdata->type);
-		break;
-
-	case VFE_MSG_STATS_AEC:
-		CDBG("%s: qtype %d, AEC stats, enqueue event_q.\n",
-		     __func__, vdata->type);
-		break;
-
-	case VFE_MSG_STATS_IHIST:
-		CDBG("%s: qtype %d, ihist stats, enqueue event_q.\n",
-		     __func__, vdata->type);
-		break;
-
-	case VFE_MSG_STATS_RS:
-		CDBG("%s: qtype %d, rs stats, enqueue event_q.\n",
-		     __func__, vdata->type);
-		break;
-
-	case VFE_MSG_STATS_CS:
-		CDBG("%s: qtype %d, cs stats, enqueue event_q.\n",
-		     __func__, vdata->type);
-		break;
-
-
-	case VFE_MSG_GENERAL:
-		CDBG("%s: qtype %d, general msg, enqueue event_q.\n",
-		    __func__, vdata->type);
-		break;
-
-	default:
+		default:
 		CDBG("%s: qtype %d not handled\n", __func__, vdata->type);
 		/* fall through, send to config. */
 	}
@@ -2319,7 +2323,6 @@ static struct msm_vfe_callback msm_vfe_s = {
 	.vfe_resp = msm_vfe_sync,
 	.vfe_alloc = msm_vfe_sync_alloc,
 	.vfe_free = msm_vfe_sync_free,
-	.flash_ctrl = msm_camera_flash,
 };
 
 static int __msm_open(struct msm_sync *sync, const char *const apps_id)
@@ -2340,11 +2343,11 @@ static int __msm_open(struct msm_sync *sync, const char *const apps_id)
 	sync->apps_id = apps_id;
 
 	if (!sync->opencnt) {
+		wake_lock(&sync->wake_suspend_lock);
 		wake_lock(&sync->wake_lock);
 
 		msm_camvfe_fn_init(&sync->vfefn, sync);
 		if (sync->vfefn.vfe_init) {
-			sync->get_pic_abort = 0;
 			rc = sync->vfefn.vfe_init(&msm_vfe_s,
 				sync->pdev);
 			if (rc < 0) {
@@ -2356,6 +2359,7 @@ static int __msm_open(struct msm_sync *sync, const char *const apps_id)
 			if (rc < 0) {
 				pr_err("%s: sensor init failed: %d\n",
 					__func__, rc);
+				sync->vfefn.vfe_release(sync->pdev);
 				goto msm_open_done;
 			}
 		} else {
@@ -2384,7 +2388,7 @@ static int msm_open_common(struct inode *inode, struct file *filep,
 	struct msm_device *pmsm =
 		container_of(inode->i_cdev, struct msm_device, cdev);
 
-	CDBG("%s: open %s\n", __func__, filep->f_path.dentry->d_name.name);
+	pr_info("%s: open %s\n", __func__, filep->f_path.dentry->d_name.name);
 
 	if (atomic_cmpxchg(&pmsm->opened, 0, 1) && once) {
 		pr_err("%s: %s is already opened.\n",
@@ -2409,8 +2413,11 @@ static int msm_open_common(struct inode *inode, struct file *filep,
 	return rc;
 }
 
+
+
 static int msm_open(struct inode *inode, struct file *filep)
 {
+	msm_show_time();
 	return msm_open_common(inode, filep, 1);
 }
 
@@ -2419,7 +2426,7 @@ static int msm_open_control(struct inode *inode, struct file *filep)
 	int rc;
 
 	struct msm_control_device *ctrl_pmsm =
-		kmalloc(sizeof(struct msm_control_device), GFP_KERNEL);
+		kzalloc(sizeof(struct msm_control_device), GFP_KERNEL);
 	if (!ctrl_pmsm)
 		return -ENOMEM;
 
@@ -2431,7 +2438,6 @@ static int msm_open_control(struct inode *inode, struct file *filep)
 
 	ctrl_pmsm->pmsm = filep->private_data;
 	filep->private_data = ctrl_pmsm;
-
 	msm_queue_init(&ctrl_pmsm->ctrl_q, "control");
 
 	CDBG("%s: rc %d\n", __func__, rc);
@@ -2449,7 +2455,7 @@ static int __msm_v4l2_control(struct msm_sync *sync,
 	struct msm_device_queue FIXME;
 
 	/* wake up config thread, 4 is for V4L2 application */
-	qcmd = kmalloc(sizeof(struct msm_queue_cmd), GFP_KERNEL);
+	qcmd = kzalloc(sizeof(struct msm_queue_cmd), GFP_KERNEL);
 	if (!qcmd) {
 		pr_err("%s: cannot allocate buffer\n", __func__);
 		rc = -ENOMEM;
@@ -2538,6 +2544,169 @@ static int msm_tear_down_cdev(struct msm_device *msm, dev_t devno)
 	return 0;
 }
 
+static uint32_t led_ril_status_value;
+static uint32_t led_wimax_status_value;
+static uint32_t led_hotspot_status_value;
+static uint16_t led_low_temp_limit;
+static uint16_t led_low_cap_limit;
+static struct kobject *led_status_obj;
+
+static ssize_t led_ril_status_get(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", led_ril_status_value);
+	return length;
+}
+
+static ssize_t led_ril_status_set(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+
+	tmp = buf[0] - 0x30; /* only get the first char */
+
+	led_ril_status_value = tmp;
+	pr_info("led_ril_status_value = %d\n", led_ril_status_value);
+	return count;
+}
+
+static ssize_t led_wimax_status_get(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", led_wimax_status_value);
+	return length;
+}
+
+static ssize_t led_wimax_status_set(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+
+	tmp = buf[0] - 0x30; /* only get the first char */
+
+	led_wimax_status_value = tmp;
+	pr_info("led_wimax_status_value = %d\n", led_wimax_status_value);
+	return count;
+}
+
+static ssize_t led_hotspot_status_get(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", led_hotspot_status_value);
+	return length;
+}
+
+static ssize_t led_hotspot_status_set(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+
+	tmp = buf[0] - 0x30; /* only get the first char */
+
+	led_hotspot_status_value = tmp;
+	pr_info("led_hotspot_status_value = %d\n", led_hotspot_status_value);
+	return count;
+}
+
+static ssize_t low_temp_limit_get(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", led_low_temp_limit);
+	return length;
+}
+
+static ssize_t low_cap_limit_get(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", led_low_cap_limit);
+	return length;
+}
+
+static DEVICE_ATTR(led_ril_status, 0644,
+	led_ril_status_get,
+	led_ril_status_set);
+
+static DEVICE_ATTR(led_wimax_status, 0644,
+	led_wimax_status_get,
+	led_wimax_status_set);
+
+static DEVICE_ATTR(led_hotspot_status, 0644,
+	led_hotspot_status_get,
+	led_hotspot_status_set);
+
+static DEVICE_ATTR(low_temp_limit, 0444,
+	low_temp_limit_get,
+	NULL);
+
+static DEVICE_ATTR(low_cap_limit, 0444,
+	low_cap_limit_get,
+	NULL);
+
+static int msm_camera_sysfs_init(struct msm_sync* sync)
+{
+	int ret = 0;
+	CDBG("msm_camera:kobject creat and add\n");
+	led_status_obj = kobject_create_and_add("camera_led_status", NULL);
+	if (led_status_obj == NULL) {
+		pr_info("msm_camera: subsystem_register failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	ret = sysfs_create_file(led_status_obj,
+		&dev_attr_led_ril_status.attr);
+	if (ret) {
+		pr_info("msm_camera: sysfs_create_file ril failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(led_status_obj,
+		&dev_attr_led_wimax_status.attr);
+	if (ret) {
+		pr_info("msm_camera: sysfs_create_file wimax failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(led_status_obj,
+		&dev_attr_led_hotspot_status.attr);
+	if (ret) {
+		pr_info("msm_camera: sysfs_create_file hotspot failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(led_status_obj,
+		&dev_attr_low_temp_limit.attr);
+	if (ret) {
+		pr_info("msm_camera: sysfs_create_file low_temp_limit failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(led_status_obj,
+		&dev_attr_low_cap_limit.attr);
+	if (ret) {
+		pr_info("msm_camera: sysfs_create_file low_cap_limit failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	led_low_temp_limit = sync->sdata->flash_cfg->low_temp_limit;
+	led_low_cap_limit = sync->sdata->flash_cfg->low_cap_limit;
+
+	return ret;
+error:
+	kobject_del(led_status_obj);
+	return ret;
+}
+
 #ifdef CONFIG_MSM_CAMERA_V4L2
 int msm_v4l2_register(struct msm_v4l2_driver *drv)
 {
@@ -2569,8 +2738,8 @@ EXPORT_SYMBOL(msm_v4l2_unregister);
 
 static int msm_sync_init(struct msm_sync *sync,
 		struct platform_device *pdev,
-		int (*sensor_probe)(const struct msm_camera_sensor_info *,
-				struct msm_sensor_ctrl *))
+		int (*sensor_probe)(struct msm_camera_sensor_info *,
+				struct msm_sensor_ctrl *), int camera_node)
 {
 	int rc = 0;
 	struct msm_sensor_ctrl sctrl;
@@ -2580,11 +2749,14 @@ static int msm_sync_init(struct msm_sync *sync,
 	msm_queue_init(&sync->frame_q, "frame");
 	msm_queue_init(&sync->pict_q, "pict");
 
-	wake_lock_init(&sync->wake_lock, WAKE_LOCK_SUSPEND, "msm_camera");
+	wake_lock_init(&sync->wake_suspend_lock, WAKE_LOCK_SUSPEND, "msm_camera_wake");
+	wake_lock_init(&sync->wake_lock, WAKE_LOCK_IDLE, "msm_camera");
 
 	rc = msm_camio_probe_on(pdev);
 	if (rc < 0)
 		return rc;
+	sctrl.node = camera_node;
+	pr_info("sctrl.node %d\n", sctrl.node);
 	rc = sensor_probe(sync->sdata, &sctrl);
 	if (rc >= 0) {
 		sync->pdev = pdev;
@@ -2595,6 +2767,7 @@ static int msm_sync_init(struct msm_sync *sync,
 		pr_err("%s: failed to initialize %s\n",
 			__func__,
 			sync->sdata->sensor_name);
+		wake_lock_destroy(&sync->wake_suspend_lock);
 		wake_lock_destroy(&sync->wake_lock);
 		return rc;
 	}
@@ -2607,6 +2780,7 @@ static int msm_sync_init(struct msm_sync *sync,
 
 static int msm_sync_destroy(struct msm_sync *sync)
 {
+	wake_lock_destroy(&sync->wake_suspend_lock);
 	wake_lock_destroy(&sync->wake_lock);
 	return 0;
 }
@@ -2658,13 +2832,13 @@ static int msm_device_init(struct msm_device *pmsm,
 }
 
 int msm_camera_drv_start(struct platform_device *dev,
-		int (*sensor_probe)(const struct msm_camera_sensor_info *,
+		int (*sensor_probe)(struct msm_camera_sensor_info *,
 			struct msm_sensor_ctrl *))
 {
 	struct msm_device *pmsm = NULL;
 	struct msm_sync *sync;
 	int rc = -ENODEV;
-	static int camera_node;
+	static int camera_node = 0;
 
 	if (camera_node >= MSM_MAX_CAMERA_SENSORS) {
 		pr_err("%s: too many camera sensors\n", __func__);
@@ -2697,7 +2871,7 @@ int msm_camera_drv_start(struct platform_device *dev,
 		return -ENOMEM;
 	sync = (struct msm_sync *)(pmsm + 3);
 
-	rc = msm_sync_init(sync, dev, sensor_probe);
+	rc = msm_sync_init(sync, dev, sensor_probe, camera_node);
 	if (rc < 0) {
 		kfree(pmsm);
 		return rc;
@@ -2711,6 +2885,9 @@ int msm_camera_drv_start(struct platform_device *dev,
 		return rc;
 	}
 
+	if (!!sync->sdata->flash_cfg)
+		msm_camera_sysfs_init(sync);
+
 	camera_node++;
 	list_add(&sync->list, &msm_sensors);
 	return rc;
diff --git a/drivers/media/video/msm/msm_io7x.c b/drivers/media/video/msm/msm_io7x.c
index 63c9b64..4a33d2e 100644
--- a/drivers/media/video/msm/msm_io7x.c
+++ b/drivers/media/video/msm/msm_io7x.c
@@ -55,7 +55,7 @@ static struct msm_camera_io_ext camio_ext;
 static struct resource *appio, *mdcio;
 void __iomem *appbase, *mdcbase;
 
-int clk_set_flags(struct clk *clk, unsigned long flags);
+extern int clk_set_flags(struct clk *clk, unsigned long flags);
 
 int msm_camio_clk_enable(enum msm_camio_clk_type clktype)
 {
@@ -79,7 +79,8 @@ int msm_camio_clk_enable(enum msm_camio_clk_type clktype)
 		break;
 	}
 
-	if (!IS_ERR(clk)) {
+	/* HTC: check clk */
+	if (!IS_ERR(clk) && clk) {
 		clk_enable(clk);
 		rc = 0;
 	}
@@ -108,8 +109,8 @@ int msm_camio_clk_disable(enum msm_camio_clk_type clktype)
 	default:
 		break;
 	}
-
-	if (!IS_ERR(clk)) {
+	/* HTC: check clk */
+	if (!IS_ERR(clk) && clk) {
 		clk_disable(clk);
 		clk_put(clk);
 		rc = 0;
@@ -141,7 +142,8 @@ int msm_camio_enable(struct platform_device *pdev)
 		goto enable_fail;
 	}
 
-	appbase = ioremap(camio_ext.appphy, camio_ext.appsz);
+	appbase = ioremap(camio_ext.appphy,
+		camio_ext.appsz);
 	if (!appbase) {
 		rc = -ENOMEM;
 		goto apps_no_mem;
@@ -154,17 +156,21 @@ int msm_camio_enable(struct platform_device *pdev)
 		goto mdc_busy;
 	}
 
-	mdcbase = ioremap(camio_ext.mdcphy, camio_ext.mdcsz);
+	mdcbase = ioremap(camio_ext.mdcphy,
+		camio_ext.mdcsz);
 	if (!mdcbase) {
 		rc = -ENOMEM;
 		goto mdc_no_mem;
 	}
 
-	camdev->camera_gpio_on();
-
 	msm_camio_clk_enable(CAMIO_VFE_CLK);
 	msm_camio_clk_enable(CAMIO_MDC_CLK);
 	msm_camio_clk_enable(CAMIO_VFE_MDC_CLK);
+
+	mdelay(2);
+	camdev->camera_gpio_on();
+	mdelay(2);
+
 	return 0;
 
 mdc_no_mem:
@@ -187,11 +193,12 @@ void msm_camio_disable(struct platform_device *pdev)
 	iounmap(appbase);
 	release_mem_region(camio_ext.appphy, camio_ext.appsz);
 
-	camdev->camera_gpio_off();
 
 	msm_camio_clk_disable(CAMIO_VFE_CLK);
 	msm_camio_clk_disable(CAMIO_MDC_CLK);
 	msm_camio_clk_disable(CAMIO_VFE_MDC_CLK);
+
+	camdev->camera_gpio_off();
 }
 
 void msm_camio_camif_pad_reg_reset(void)
@@ -204,10 +211,13 @@ void msm_camio_camif_pad_reg_reset(void)
 
 	reg = (readl(mdcbase)) & CAMIF_CFG_RMSK;
 
-	mask = CAM_SEL_BMSK | CAM_PCLK_SRC_SEL_BMSK | CAM_PCLK_INVERT_BMSK;
+	mask = CAM_SEL_BMSK |
+		CAM_PCLK_SRC_SEL_BMSK |
+		CAM_PCLK_INVERT_BMSK;
 
 	value = 1 << CAM_SEL_SHFT |
-	    3 << CAM_PCLK_SRC_SEL_SHFT | 0 << CAM_PCLK_INVERT_SHFT;
+		3 << CAM_PCLK_SRC_SEL_SHFT |
+		0 << CAM_PCLK_INVERT_SHFT;
 
 	writel((reg & (~mask)) | (value & mask), mdcbase);
 	mdelay(10);
diff --git a/drivers/media/video/msm/msm_io8x.c b/drivers/media/video/msm/msm_io8x.c
index ae4fe44..13364d9 100644
--- a/drivers/media/video/msm/msm_io8x.c
+++ b/drivers/media/video/msm/msm_io8x.c
@@ -79,7 +79,7 @@ int msm_camio_clk_enable(enum msm_camio_clk_type clktype)
 		break;
 	}
 
-	if (!IS_ERR(clk)) {
+	if (!IS_ERR(clk) && clk != NULL) {
 		/* Set rate here *before* enabling the block to prevent
 		 * unstable clock from source.
 		 */
@@ -120,7 +120,7 @@ int msm_camio_clk_disable(enum msm_camio_clk_type clktype)
 		break;
 	}
 
-	if (!IS_ERR(clk)) {
+	if (!IS_ERR(clk) && clk != NULL) {
 		clk_disable(clk);
 		clk_put(clk);
 	} else
diff --git a/drivers/media/video/msm/msm_io_vfe31.c b/drivers/media/video/msm/msm_io_vfe31.c
deleted file mode 100644
index 523c7f1..0000000
--- a/drivers/media/video/msm/msm_io_vfe31.c
+++ /dev/null
@@ -1,285 +0,0 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <mach/gpio.h>
-#include <mach/board.h>
-#include <mach/camera.h>
-#include <mach/clk.h>
-
-#define CAMIF_CFG_RMSK             0x1fffff
-#define CAM_SEL_BMSK               0x2
-#define CAM_PCLK_SRC_SEL_BMSK      0x60000
-#define CAM_PCLK_INVERT_BMSK       0x80000
-#define CAM_PAD_REG_SW_RESET_BMSK  0x100000
-
-#define EXT_CAM_HSYNC_POL_SEL_BMSK 0x10000
-#define EXT_CAM_VSYNC_POL_SEL_BMSK 0x8000
-#define MDDI_CLK_CHICKEN_BIT_BMSK  0x80
-
-#define CAM_SEL_SHFT               0x1
-#define CAM_PCLK_SRC_SEL_SHFT      0x11
-#define CAM_PCLK_INVERT_SHFT       0x13
-#define CAM_PAD_REG_SW_RESET_SHFT  0x14
-
-#define EXT_CAM_HSYNC_POL_SEL_SHFT 0x10
-#define EXT_CAM_VSYNC_POL_SEL_SHFT 0xF
-#define MDDI_CLK_CHICKEN_BIT_SHFT  0x7
-
-static struct clk *camio_vfe_mdc_clk;
-static struct clk *camio_mdc_clk;
-static struct clk *camio_vfe_clk;
-static struct clk *camio_vfe_camif_clk;
-static struct clk *camio_vfe_pbdg_clk;
-static struct clk *camio_cam_m_clk;
-static struct clk *camio_camif_pad_pbdg_clk;
-static struct msm_camera_io_ext camio_ext;
-static struct resource *camifpadio;
-void __iomem *camifpadbase;
-
-static void camif_io_w(u32 data)
-{
-	writel(data, camifpadbase);
-	wmb();
-}
-
-static u32 camif_io_r(void)
-{
-	uint32_t data = readl(camifpadbase);
-	rmb();
-	return data;
-}
-
-int msm_camio_clk_enable(enum msm_camio_clk_type clktype)
-{
-	int rc = 0;
-	struct clk *clk = NULL;
-
-	switch (clktype) {
-	case CAMIO_VFE_MDC_CLK:
-		camio_vfe_mdc_clk = clk = clk_get(NULL, "vfe_mdc_clk");
-		break;
-
-	case CAMIO_MDC_CLK:
-		camio_mdc_clk = clk = clk_get(NULL, "mdc_clk");
-		break;
-
-	case CAMIO_VFE_CLK:
-		camio_vfe_clk = clk = clk_get(NULL, "vfe_clk");
-		clk_set_rate(clk, 122880000);
-		break;
-
-	case CAMIO_VFE_CAMIF_CLK:
-		camio_vfe_camif_clk = clk = clk_get(NULL, "vfe_camif_clk");
-		break;
-
-	case CAMIO_VFE_PBDG_CLK:
-		camio_vfe_pbdg_clk = clk = clk_get(NULL, "vfe_pclk");
-		break;
-
-	case CAMIO_CAM_MCLK_CLK:
-		camio_cam_m_clk = clk = clk_get(NULL, "cam_m_clk");
-		clk_set_rate(clk, 24000000);
-		break;
-
-	case CAMIO_CAMIF_PAD_PBDG_CLK:
-		camio_camif_pad_pbdg_clk = clk = clk_get(NULL, "camif_pad_pclk");
-		break;
-
-	default:
-		break;
-	}
-
-	if (!IS_ERR(clk))
-		clk_enable(clk);
-	else
-		rc = -1;
-	return rc;
-}
-
-int msm_camio_clk_disable(enum msm_camio_clk_type clktype)
-{
-	int rc = 0;
-	struct clk *clk = NULL;
-
-	switch (clktype) {
-	case CAMIO_VFE_MDC_CLK:
-		clk = camio_vfe_mdc_clk;
-		break;
-
-	case CAMIO_MDC_CLK:
-		clk = camio_mdc_clk;
-		break;
-
-	case CAMIO_VFE_CLK:
-		clk = camio_vfe_clk;
-		break;
-
-	case CAMIO_VFE_CAMIF_CLK:
-		clk = camio_vfe_camif_clk;
-		break;
-
-	case CAMIO_VFE_PBDG_CLK:
-		clk = camio_vfe_pbdg_clk;
-		break;
-
-	case CAMIO_CAM_MCLK_CLK:
-		clk = camio_cam_m_clk;
-		break;
-
-	case CAMIO_CAMIF_PAD_PBDG_CLK:
-		clk = camio_camif_pad_pbdg_clk;
-		break;
-
-	default:
-		break;
-	}
-
-	if (!IS_ERR(clk)) {
-		clk_disable(clk);
-		clk_put(clk);
-	} else
-		rc = -1;
-
-	return rc;
-}
-
-void msm_camio_clk_rate_set(int rate)
-{
-	struct clk *clk = camio_cam_m_clk;
-	clk_set_rate(clk, rate);
-}
-
-int msm_camio_enable(struct platform_device *pdev)
-{
-	int rc = 0;
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
-
-	camio_ext = camdev->ioext;
-
-	camdev->camera_gpio_on();
-	msm_camio_clk_enable(CAMIO_VFE_PBDG_CLK);
-	msm_camio_clk_enable(CAMIO_CAMIF_PAD_PBDG_CLK);
-	msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
-	msm_camio_clk_enable(CAMIO_VFE_CLK);
-	camifpadio = request_mem_region(camio_ext.camifpadphy,
-		camio_ext.camifpadsz, pdev->name);
-	if (!camifpadio) {
-		rc = -EBUSY;
-		goto common_fail;
-	}
-	camifpadbase = ioremap(camio_ext.camifpadphy, camio_ext.camifpadsz);
-	if (!camifpadbase) {
-		rc = -ENOMEM;
-		goto parallel_busy;
-	}
-	msm_camio_clk_enable(CAMIO_VFE_CAMIF_CLK);
-	return 0;
-
-parallel_busy:
-	release_mem_region(camio_ext.camifpadphy, camio_ext.camifpadsz);
-common_fail:
-	msm_camio_clk_disable(CAMIO_VFE_CLK);
-	msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
-	msm_camio_clk_disable(CAMIO_CAMIF_PAD_PBDG_CLK);
-	msm_camio_clk_disable(CAMIO_VFE_PBDG_CLK);
-	camdev->camera_gpio_off();
-	return rc;
-}
-
-void msm_camio_disable(struct platform_device *pdev)
-{
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
-
-	msm_camio_clk_disable(CAMIO_VFE_CAMIF_CLK);
-	iounmap(camifpadbase);
-	release_mem_region(camio_ext.camifpadphy, camio_ext.camifpadsz);
-	CDBG("disable clocks\n");
-
-	msm_camio_clk_disable(CAMIO_VFE_CLK);
-	msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
-	msm_camio_clk_disable(CAMIO_CAMIF_PAD_PBDG_CLK);
-	msm_camio_clk_disable(CAMIO_VFE_PBDG_CLK);
-	camdev->camera_gpio_off();
-}
-
-void msm_camio_camif_pad_reg_reset(void)
-{
-	uint32_t reg;
-
-	msm_camio_clk_sel(MSM_CAMIO_CLK_SRC_INTERNAL);
-	msleep(10);
-
-	reg = camif_io_r() & CAMIF_CFG_RMSK;
-	reg |= 0x3;
-	camif_io_w(reg);
-	msleep(10);
-
-	reg = camif_io_r() & CAMIF_CFG_RMSK;
-	reg |= 0x10;
-	camif_io_w(reg);
-	msleep(10);
-
-	reg = camif_io_r() & CAMIF_CFG_RMSK;
-	/* Need to be uninverted*/
-	reg &= 0x03;
-	camif_io_w(reg);
-	msleep(10);
-}
-
-void msm_camio_vfe_blk_reset(void)
-{
-	return;
-}
-
-void msm_camio_clk_sel(enum msm_camio_clk_src_type srctype)
-{
-	if (camio_vfe_clk != NULL) {
-		switch (srctype) {
-		case MSM_CAMIO_CLK_SRC_INTERNAL:
-			clk_set_flags(camio_vfe_clk, 0x00000100 << 1);
-			break;
-
-		case MSM_CAMIO_CLK_SRC_EXTERNAL:
-			clk_set_flags(camio_vfe_clk, 0x00000100);
-			break;
-
-		default:
-			break;
-		}
-	}
-}
-int msm_camio_probe_on(struct platform_device *pdev)
-{
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
-	camdev->camera_gpio_on();
-	return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
-}
-
-int msm_camio_probe_off(struct platform_device *pdev)
-{
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
-	camdev->camera_gpio_off();
-	return msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
-}
diff --git a/drivers/media/video/msm/msm_v4l2.c b/drivers/media/video/msm/msm_v4l2.c
index 6abbdb9..138d7d4 100644
--- a/drivers/media/video/msm/msm_v4l2.c
+++ b/drivers/media/video/msm/msm_v4l2.c
@@ -24,6 +24,7 @@
 #include <linux/spinlock.h>
 #include <linux/videodev2.h>
 #include <linux/proc_fs.h>
+#include <linux/slab.h>
 #include <media/v4l2-dev.h>
 #include <media/msm_camera.h>
 #include <mach/camera.h>
diff --git a/drivers/media/video/msm/msm_vfe31.c b/drivers/media/video/msm/msm_vfe31.c
deleted file mode 100644
index 7160229..0000000
--- a/drivers/media/video/msm/msm_vfe31.c
+++ /dev/null
@@ -1,2314 +0,0 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/uaccess.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <mach/irqs.h>
-#include "msm_vfe31.h"
-#include <mach/camera.h>
-#include <linux/io.h>
-
-#define CHECKED_COPY_FROM_USER(in) {					\
-	if (copy_from_user((in), (void __user *)cmd->value,		\
-			cmd->length)) {					\
-		rc = -EFAULT;						\
-		break;							\
-	}								\
-}
-
-#define vfe31_get_ch_ping_addr(chn) \
-	(vfe_io_r(VFE_AXI_OFFSET + 0x18 * (chn)))
-#define vfe31_get_ch_pong_addr(chn) \
-	(vfe_io_r(VFE_AXI_OFFSET + 0x18 * (chn) + 4))
-#define vfe31_get_ch_addr(ping_pong, chn) \
-	(((ping_pong) & (1 << (chn))) == 0 ? \
-	vfe31_get_ch_pong_addr(chn) : vfe31_get_ch_ping_addr(chn))
-
-#define vfe31_put_ch_ping_addr(chn, addr) \
-	(vfe_io_w((addr), VFE_AXI_OFFSET + 0x18 * (chn)))
-#define vfe31_put_ch_pong_addr(chn, addr) \
-	(vfe_io_w((addr), VFE_AXI_OFFSET + 0x18 * (chn) + 4))
-#define vfe31_put_ch_addr(ping_pong, chn, addr) \
-	(((ping_pong) & (1 << (chn))) == 0 ?   \
-	vfe31_put_ch_pong_addr((chn), (addr)) : \
-	vfe31_put_ch_ping_addr((chn), (addr)))
-
-static struct vfe31_ctrl_type *vfe31_ctrl;
-static void *vfe_syncdata;
-
-struct vfe31_isr_queue_cmd {
-	struct list_head list;
-	uint32_t                           vfeInterruptStatus0;
-	uint32_t                           vfeInterruptStatus1;
-	struct vfe_frame_asf_info          vfeAsfFrameInfo;
-	struct vfe_frame_bpc_info          vfeBpcFrameInfo;
-	struct vfe_msg_camif_status        vfeCamifStatusLocal;
-};
-
-static struct vfe31_cmd_type vfe31_cmd[] = {
-/* 0*/	{V31_DUMMY_0},
-		{V31_SET_CLK},
-		{V31_RESET},
-		{V31_START},
-		{V31_TEST_GEN_START},
-/* 5*/	{V31_OPERATION_CFG, V31_OPERATION_CFG_LEN},
-		{V31_AXI_OUT_CFG, V31_AXI_OUT_LEN, V31_AXI_OUT_OFF, 0xFF},
-		{V31_CAMIF_CFG, V31_CAMIF_LEN, V31_CAMIF_OFF, 0xFF},
-		{V31_AXI_INPUT_CFG},
-		{V31_BLACK_LEVEL_CFG, V31_BLACK_LEVEL_LEN, V31_BLACK_LEVEL_OFF,
-		0xFF},
-/*10*/  {V31_ROLL_OFF_CFG, V31_ROLL_OFF_CFG_LEN, V31_ROLL_OFF_CFG_OFF,
-		0xFF},
-		{V31_DEMUX_CFG, V31_DEMUX_LEN, V31_DEMUX_OFF, 0xFF},
-		{V31_DEMOSAIC_0_CFG, V31_DEMOSAIC_0_LEN, V31_DEMOSAIC_0_OFF,
-		0xFF},
-		{V31_DEMOSAIC_1_CFG, V31_DEMOSAIC_1_LEN, V31_DEMOSAIC_1_OFF,
-		0xFF},
-		{V31_DEMOSAIC_2_CFG, V31_DEMOSAIC_2_LEN, V31_DEMOSAIC_2_OFF,
-		0xFF},
-/*15*/	{V31_FOV_CFG, V31_FOV_LEN, V31_FOV_OFF, 0xFF},
-		{V31_MAIN_SCALER_CFG, V31_MAIN_SCALER_LEN, V31_MAIN_SCALER_OFF,
-		0xFF},
-		{V31_WB_CFG, V31_WB_LEN, V31_WB_OFF, 0xFF},
-		{V31_COLOR_COR_CFG, V31_COLOR_COR_LEN, V31_COLOR_COR_OFF, 0xFF},
-		{V31_RGB_G_CFG, V31_RGB_G_LEN, V31_RGB_G_OFF, 0xFF},
-/*20*/	{V31_LA_CFG, V31_LA_LEN, V31_LA_OFF, 0xFF },
-		{V31_CHROMA_EN_CFG, V31_CHROMA_EN_LEN, V31_CHROMA_EN_OFF, 0xFF},
-		{V31_CHROMA_SUP_CFG, V31_CHROMA_SUP_LEN, V31_CHROMA_SUP_OFF,
-		0xFF},
-		{V31_MCE_CFG, V31_MCE_LEN, V31_MCE_OFF, 0xFF},
-		{V31_SK_ENHAN_CFG},
-/*25*/	{V31_ASF_CFG, V31_ASF_LEN, V31_ASF_OFF, 0xFF},
-		{V31_S2Y_CFG, V31_S2Y_LEN, V31_S2Y_OFF, 0xFF},
-		{V31_S2CbCr_CFG, V31_S2CbCr_LEN, V31_S2CbCr_OFF, 0xFF},
-		{V31_CHROMA_SUBS_CFG, V31_CHROMA_SUBS_LEN, V31_CHROMA_SUBS_OFF,
-			0xFF},
-		{V31_OUT_CLAMP_CFG, V31_OUT_CLAMP_LEN, V31_OUT_CLAMP_OFF, 0xFF},
-/*30*/	{V31_FRAME_SKIP_CFG, V31_FRAME_SKIP_LEN, V31_FRAME_SKIP_OFF, 0xFF},
-		{V31_DUMMY_1},
-		{V31_DUMMY_2},
-		{V31_DUMMY_3},
-		{V31_UPDATE},
-/*35*/	{V31_BL_LVL_UPDATE, V31_BLACK_LEVEL_LEN, V31_BLACK_LEVEL_OFF,
-		0xFF},
-		{V31_DEMUX_UPDATE, V31_DEMUX_LEN, V31_DEMUX_OFF, 0xFF},
-		{V31_DEMOSAIC_1_UPDATE, V31_DEMOSAIC_1_LEN, V31_DEMOSAIC_1_OFF,
-		0xFF},
-		{V31_DEMOSAIC_2_UPDATE, V31_DEMOSAIC_2_LEN, V31_DEMOSAIC_2_OFF,
-		0xFF},
-		{V31_FOV_UPDATE, V31_FOV_LEN, V31_FOV_OFF, 0xFF},
-/*40*/	{V31_MAIN_SCALER_UPDATE, V31_MAIN_SCALER_LEN, V31_MAIN_SCALER_OFF,
-		0xFF},
-		{V31_WB_UPDATE, V31_WB_LEN, V31_WB_OFF, 0xFF},
-		{V31_COLOR_COR_UPDATE, V31_COLOR_COR_LEN, V31_COLOR_COR_OFF,
-		0xFF},
-		{V31_RGB_G_UPDATE, V31_RGB_G_LEN, V31_CHROMA_EN_OFF, 0xFF},
-		{V31_LA_UPDATE, V31_LA_LEN, V31_LA_OFF, 0xFF },
-/*45*/	{V31_CHROMA_EN_UPDATE, V31_CHROMA_EN_LEN, V31_CHROMA_EN_OFF, 0xFF},
-		{V31_CHROMA_SUP_UPDATE, V31_CHROMA_SUP_LEN, V31_CHROMA_SUP_OFF,
-		0xFF},
-		{V31_MCE_UPDATE, V31_MCE_LEN, V31_MCE_OFF, 0xFF},
-		{V31_SK_ENHAN_UPDATE},
-		{V31_S2CbCr_UPDATE, V31_S2CbCr_LEN, V31_S2CbCr_OFF, 0xFF},
-/*50*/	{V31_S2Y_UPDATE, V31_S2Y_LEN, V31_S2Y_OFF, 0xFF},
-		{V31_ASF_UPDATE, V31_ASF_UPDATE_LEN, V31_ASF_OFF, 0xFF},
-		{V31_FRAME_SKIP_UPDATE},
-		{V31_CAMIF_FRAME_UPDATE},
-		{V31_STATS_AF_UPDATE, V31_STATS_AF_LEN, V31_STATS_AF_OFF},
-/*55*/	{V31_STATS_AE_UPDATE, V31_STATS_AE_LEN, V31_STATS_AE_OFF},
-		{V31_STATS_AWB_UPDATE, V31_STATS_AWB_LEN, V31_STATS_AWB_OFF},
-		{V31_STATS_RS_UPDATE, V31_STATS_RS_LEN, V31_STATS_RS_OFF},
-		{V31_STATS_CS_UPDATE, V31_STATS_CS_LEN, V31_STATS_CS_OFF},
-		{V31_STATS_SKIN_UPDATE},
-/*60*/	{V31_STATS_IHIST_UPDATE, V31_STATS_IHIST_LEN, V31_STATS_IHIST_OFF},
-		{V31_DUMMY_4},
-		{V31_EPOCH1_ACK},
-		{V31_EPOCH2_ACK},
-		{V31_START_RECORDING},
-/*65*/	{V31_STOP_RECORDING},
-		{V31_DUMMY_5},
-		{V31_DUMMY_6},
-		{V31_CAPTURE, V31_CAPTURE_LEN, 0xFF},
-		{V31_DUMMY_7},
-/*70*/	{V31_STOP},
-		{V31_GET_HW_VERSION},
-		{V31_GET_FRAME_SKIP_COUNTS},
-		{V31_OUTPUT1_BUFFER_ENQ},
-		{V31_OUTPUT2_BUFFER_ENQ},
-/*75*/	{V31_OUTPUT3_BUFFER_ENQ},
-		{V31_JPEG_OUT_BUF_ENQ},
-		{V31_RAW_OUT_BUF_ENQ},
-		{V31_RAW_IN_BUF_ENQ},
-		{V31_STATS_AF_ENQ},
-/*80*/	{V31_STATS_AE_ENQ},
-		{V31_STATS_AWB_ENQ},
-		{V31_STATS_RS_ENQ},
-		{V31_STATS_CS_ENQ},
-		{V31_STATS_SKIN_ENQ},
-/*85*/	{V31_STATS_IHIST_ENQ},
-		{V31_DUMMY_8},
-		{V31_JPEG_ENC_CFG},
-		{V31_DUMMY_9},
-		{V31_STATS_AF_START, V31_STATS_AF_LEN, V31_STATS_AF_OFF},
-/*90*/	{V31_STATS_AF_STOP},
-		{V31_STATS_AE_START, V31_STATS_AE_LEN, V31_STATS_AE_OFF},
-		{V31_STATS_AE_STOP},
-		{V31_STATS_AWB_START, V31_STATS_AWB_LEN, V31_STATS_AWB_OFF},
-		{V31_STATS_AWB_STOP},
-/*95*/	{V31_STATS_RS_START, V31_STATS_RS_LEN, V31_STATS_RS_OFF},
-		{V31_STATS_RS_STOP},
-		{V31_STATS_CS_START, V31_STATS_CS_LEN, V31_STATS_CS_OFF},
-		{V31_STATS_CS_STOP},
-		{V31_STATS_SKIN_START, V31_STATS_IHIST_LEN,
-			V31_STATS_IHIST_OFF},
-/*100*/	{V31_STATS_SKIN_STOP},
-		{V31_STATS_IHIST_START},
-		{V31_STATS_IHIST_STOP},
-		{V31_DUMMY_10},
-		{V31_SYNC_TIMER_SETTING},
-/*105*/	{V31_ASYNC_TIMER_SETTING},
-};
-
-static void vfe_io_w(u32 data, unsigned long offset)
-{
-	writel(data, vfe31_ctrl->vfebase + offset);
-	wmb();
-}
-
-static u32 vfe_io_r(unsigned long offset)
-{
-	uint32_t data = readl(vfe31_ctrl->vfebase + offset);
-	rmb();
-	return data;
-}
-
-static void msm_io_memcpy(void __iomem *dest_addr,
-	void __iomem *src_addr, u32 len)
-{
-	int i;
-	u32 *d = (u32 *) dest_addr;
-	u32 *s = (u32 *) src_addr;
-	/* memcpy_toio does not work. Use writel for now */
-	for (i = 0; i < len / 4; i++) {
-		writel(*s++, d++);
-		wmb();
-	}
-}
-
-static void vfe_io_w_axi_out_chan(u32 data, int8_t chan)
-{
-	uint32_t temp;
-	vfe_io_w(data, V31_AXI_OUT_OFF + 20 + 24 * chan);
-	temp = vfe_io_r(V31_AXI_OUT_OFF + 20 + 24 * chan);
-}
-
-static void vfe_msg_get_phy_addr(struct msm_vfe_phy_info *pinfo,
-	struct vfe_message *data)
-{
-	pinfo->y_phy = data->_u.msgOut.yBuffer;
-	pinfo->cbcr_phy = data->_u.msgOut.cbcrBuffer;
-}
-
-static void vfe31_proc_ops(enum VFE31_MESSAGE_ID id, void *msg, size_t len)
-{
-	struct msm_vfe_resp *rp;
-	struct vfe_message *vfe_msg_data = NULL;
-
-	rp = vfe31_ctrl->resp->vfe_alloc(sizeof(struct msm_vfe_resp),
-		vfe31_ctrl->syncdata, GFP_ATOMIC);
-	if (!rp) {
-		pr_err("rp: cannot allocate buffer\n");
-		return;
-	}
-	CDBG("vfe31_proc_ops, msgId = %d\n", id);
-	rp->evt_msg.type   = MSM_CAMERA_MSG;
-	rp->evt_msg.msg_id = id;
-	rp->evt_msg.len    = len;
-	rp->evt_msg.data   = msg;
-	vfe_msg_data = (struct vfe_message *)rp->evt_msg.data;
-
-	switch (rp->evt_msg.msg_id) {
-	case MSG_ID_SNAPSHOT_DONE:
-		rp->type = VFE_MSG_SNAPSHOT;
-		break;
-
-	case MSG_ID_OUTPUT_P:
-		rp->type = VFE_MSG_OUTPUT_P;
-		rp->phy.output_id = OUTPUT_TYPE_P;
-		vfe_msg_get_phy_addr(&rp->phy, vfe_msg_data);
-		break;
-
-	case MSG_ID_OUTPUT_T:
-		rp->type = VFE_MSG_OUTPUT_T;
-		rp->phy.output_id = OUTPUT_TYPE_T;
-		vfe_msg_get_phy_addr(&rp->phy, vfe_msg_data);
-		break;
-
-	case MSG_ID_OUTPUT_S:
-		rp->type = VFE_MSG_OUTPUT_S;
-		rp->phy.output_id = OUTPUT_TYPE_S;
-		vfe_msg_get_phy_addr(&rp->phy, vfe_msg_data);
-		break;
-
-	case MSG_ID_OUTPUT_V:
-		rp->type = VFE_MSG_OUTPUT_V;
-		rp->phy.output_id = OUTPUT_TYPE_V;
-		vfe_msg_get_phy_addr(&rp->phy, vfe_msg_data);
-		break;
-
-	case MSG_ID_STATS_AF:
-		rp->type = VFE_MSG_STATS_AF;
-		rp->phy.sbuf_phy = vfe_msg_data->_u.msgStats.buffer;
-		break;
-
-	case MSG_ID_STATS_AWB:
-		rp->type = VFE_MSG_STATS_AWB;
-		rp->phy.sbuf_phy = vfe_msg_data->_u.msgStats.buffer;
-		break;
-
-	case MSG_ID_STATS_AEC:
-		rp->type = VFE_MSG_STATS_AEC;
-		rp->phy.sbuf_phy = vfe_msg_data->_u.msgStats.buffer;
-		break;
-
-	default:
-		rp->type = VFE_MSG_GENERAL;
-		break;
-	}
-	vfe31_ctrl->resp->vfe_resp(rp, MSM_CAM_Q_VFE_MSG, vfe31_ctrl->syncdata,
-		GFP_ATOMIC);
-}
-
-static void vfe_send_outmsg(uint8_t msgid, uint32_t pyaddr, uint32_t pcbcraddr)
-{
-	struct vfe_message msg;
-	msg._d = msgid;
-	msg._u.msgOut.yBuffer     = pyaddr;
-	msg._u.msgOut.cbcrBuffer  = pcbcraddr;
-	vfe31_proc_ops(msgid, &msg, sizeof(struct vfe_message));
-}
-
-static int vfe31_enable(struct camera_enable_cmd *enable)
-{
-	return 0;
-}
-
-void vfe_stop(void)
-{
-	uint8_t axiBusyFlag = true;
-	unsigned long flags;
-
-	/* for reset hw modules, and send msg when reset_irq comes. */
-	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
-	vfe31_ctrl->stop_ack_pending = TRUE;
-	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
-
-	/* disable all interrupts.  */
-	vfe_io_w(VFE_DISABLE_ALL_IRQS, VFE_IRQ_MASK_0);
-	vfe_io_w(VFE_DISABLE_ALL_IRQS, VFE_IRQ_MASK_1);
-
-	/* clear all pending interrupts*/
-	vfe_io_w(VFE_CLEAR_ALL_IRQS, VFE_IRQ_CLEAR_0);
-	vfe_io_w(VFE_CLEAR_ALL_IRQS, VFE_IRQ_CLEAR_1);
-	vfe_io_w(1, VFE_IRQ_CMD);
-
-	/* in either continuous or snapshot mode, stop command can be issued
-	 * at any time. stop camif immediately. */
-	vfe_io_w(CAMIF_COMMAND_STOP_IMMEDIATELY, VFE_CAMIF_COMMAND);
-
-	/* axi halt command. */
-	vfe_io_w(AXI_HALT, VFE_AXI_CMD);
-
-	while (axiBusyFlag) {
-		if (vfe_io_r(VFE_AXI_STATUS) & 0x1) {
-			axiBusyFlag = false;
-		}
-	}
-	vfe_io_w(AXI_HALT_CLEAR, VFE_AXI_CMD);
-
-	/* after axi halt, then ok to apply global reset. */
-	/* enable reset_ack and async timer interrupt only while
-	stopping the pipeline.*/
-	vfe_io_w(0xf0000000, VFE_IRQ_MASK_0);
-	vfe_io_w(VFE_IMASK_WHILE_STOPPING_1, VFE_IRQ_MASK_1);
-	vfe_io_w(VFE_RESET_UPON_STOP_CMD, VFE_GLOBAL_RESET);
-}
-
-static int vfe31_disable(struct camera_enable_cmd *enable,
-	struct platform_device *dev)
-{
-	vfe_stop();
-	msm_camio_disable(dev);
-	return 0;
-}
-
-static void vfe31_release(struct platform_device *pdev)
-{
-	struct msm_sensor_ctrl *sctrl =
-		&((struct msm_sync *)vfe_syncdata)->sctrl;
-	struct resource *vfemem, *vfeio;
-
-	if (sctrl)
-		sctrl->s_release();
-
-	vfemem = vfe31_ctrl->vfemem;
-	vfeio  = vfe31_ctrl->vfeio;
-
-	kfree(vfe31_ctrl->extdata);
-	free_irq(vfe31_ctrl->vfeirq, 0);
-	iounmap(vfe31_ctrl->vfebase);
-	kfree(vfe31_ctrl);
-	vfe31_ctrl = NULL;
-	release_mem_region(vfemem->start, (vfemem->end - vfemem->start) + 1);
-	msm_camio_disable(pdev);
-	vfe_syncdata = NULL;
-}
-
-static int vfe31_config_axi(int mode, struct axidata *ad, uint32_t *ao)
-{
-	int i;
-	uint32_t *p, *p1, *p2;
-	struct vfe31_output_ch *outp1 = NULL, *outp2 = NULL;
-	struct msm_pmem_region *regp1 = NULL, *regp2 = NULL;
-
-	p = ao + 2;
-
-	CDBG("vfe31_config_axi: mode = %d, bufnum1 = %d, bufnum2 = %d\n",
-		mode, ad->bufnum1, ad->bufnum2);
-
-	switch (mode) {
-	case OUTPUT_2:
-		if (ad->bufnum2 != 3)
-			return -EINVAL;
-		*p = 0x200;    /* preview with wm0 & wm1 */
-
-		vfe31_ctrl->outpath.out0.ch0 = 0; /* luma   */
-		vfe31_ctrl->outpath.out0.ch1 = 1; /* chroma */
-		regp1 = &(ad->region[ad->bufnum1]);
-		outp1 = &(vfe31_ctrl->outpath.out0);
-		vfe31_ctrl->outpath.output_mode |= VFE31_OUTPUT_MODE_PT;
-
-		for (i = 0; i < 2; i++) {
-			p1 = ao + 6 + i;    /* wm0 for y  */
-			*p1 = (regp1->paddr + regp1->info.y_off);
-
-			p1 = ao + 12 + i;  /* wm1 for cbcr */
-			*p1 = (regp1->paddr + regp1->info.cbcr_off);
-			regp1++;
-		}
-		outp1->free_buf.available = 1;
-		outp1->free_buf.paddr = regp1->paddr;
-		outp1->free_buf.y_off = regp1->info.y_off;
-		outp1->free_buf.cbcr_off = regp1->info.cbcr_off;
-
-		CDBG("vfe31_config_axi: free_buf paddr = 0x%x, y_off = %d,"
-			" cbcr_off = %d\n",
-			outp1->free_buf.paddr, outp1->free_buf.y_off,
-			outp1->free_buf.cbcr_off);
-		break;
-
-	case OUTPUT_1_AND_2:
-		/* use wm0& 4 for thumbnail, wm1&5 for main image.*/
-		if ((ad->bufnum1 < 1) || (ad->bufnum2 < 1))
-			return -EINVAL;
-		/* at least one frame for snapshot.  */
-		*p++ = 0x1;    /* xbar cfg0 */
-		*p = 0x203;    /* xbar cfg1 */
-		vfe31_ctrl->outpath.out0.ch0 = 0; /* thumbnail luma   */
-		vfe31_ctrl->outpath.out0.ch1 = 4; /* thumbnail chroma */
-		vfe31_ctrl->outpath.out1.ch0 = 1; /* main image luma   */
-		vfe31_ctrl->outpath.out1.ch1 = 5; /* main image chroma */
-		vfe31_ctrl->outpath.output_mode |=
-			VFE31_OUTPUT_MODE_S;  /* main image.*/
-		vfe31_ctrl->outpath.output_mode |=
-			VFE31_OUTPUT_MODE_PT;  /* thumbnail. */
-
-		regp1 = &(ad->region[0]); /* this is thumbnail buffer. */
-		/* this is main image buffer. */
-		regp2 = &(ad->region[ad->bufnum1]);
-		outp1 = &(vfe31_ctrl->outpath.out0);
-		outp2 = &(vfe31_ctrl->outpath.out1); /* snapshot */
-
-		p1 = ao + 6;   /* wm0 ping */
-		*p1++ = (regp1->paddr + regp1->info.y_off);
-		/* this is to duplicate ping address to pong.*/
-		*p1 = (regp1->paddr + regp1->info.y_off);
-		p1 = ao + 30;  /* wm4 ping */
-		*p1++ = (regp1->paddr + regp1->info.cbcr_off);
-		/* this is to duplicate ping address to pong.*/
-		*p1 = (regp1->paddr + regp1->info.cbcr_off);
-		p1 = ao + 12;   /* wm1 ping */
-		*p1++ = (regp2->paddr + regp2->info.y_off);
-		/* pong = ping,*/
-		*p1 = (regp2->paddr + regp2->info.y_off);
-		p1 = ao + 36;  /* wm5 */
-		*p1++ = (regp2->paddr + regp2->info.cbcr_off);
-		*p1 = (regp2->paddr + regp2->info.cbcr_off);
-		break;
-
-	case OUTPUT_1_AND_3:
-		/* use wm0& 4 for preview, wm1&5 for video.*/
-		if ((ad->bufnum1 < 2) || (ad->bufnum2 < 2))
-			return -EINVAL;
-		*p++ = 0x1;    /* xbar cfg0 */
-		*p = 0x1a03;    /* xbar cfg1 */
-		vfe31_ctrl->outpath.out0.ch0 = 0; /* preview luma   */
-		vfe31_ctrl->outpath.out0.ch1 = 4; /* preview chroma */
-		vfe31_ctrl->outpath.out2.ch0 = 1; /* video luma     */
-		vfe31_ctrl->outpath.out2.ch1 = 5; /* video chroma   */
-		vfe31_ctrl->outpath.output_mode |=
-			VFE31_OUTPUT_MODE_V;  /* video*/
-		vfe31_ctrl->outpath.output_mode |=
-			VFE31_OUTPUT_MODE_PT;  /* preview */
-
-		regp1 = &(ad->region[0]); /* this is preview buffer. */
-		regp2 = &(ad->region[ad->bufnum1]);/* this is video buffer. */
-		outp1 = &(vfe31_ctrl->outpath.out0); /* preview */
-		outp2 = &(vfe31_ctrl->outpath.out2); /* video */
-
-
-		for (i = 0; i < 2; i++) {
-			p1 = ao + 6 + i;    /* wm0 for y  */
-			*p1 = (regp1->paddr + regp1->info.y_off);
-
-			p1 = ao + 30 + i;  /* wm1 for cbcr */
-			*p1 = (regp1->paddr + regp1->info.cbcr_off);
-			regp1++;
-		}
-
-		for (i = 0; i < 2; i++) {
-			p2 = ao + 12 + i;    /* wm0 for y  */
-			*p2 = (regp2->paddr + regp2->info.y_off);
-
-			p2 = ao + 36 + i;  /* wm1 for cbcr */
-			*p2 = (regp2->paddr + regp2->info.cbcr_off);
-			regp2++;
-		}
-		outp1->free_buf.available = 1;
-		outp1->free_buf.paddr = regp1->paddr;
-		outp1->free_buf.y_off = regp1->info.y_off;
-		outp1->free_buf.cbcr_off = regp1->info.cbcr_off;
-
-		outp2->free_buf.available = 1;
-		outp2->free_buf.paddr = regp2->paddr;
-		outp2->free_buf.y_off = regp2->info.y_off;
-		outp2->free_buf.cbcr_off = regp2->info.cbcr_off;
-		CDBG("vfe31_config_axi: preview free_buf"
-			"paddr = 0x%x, y_off = %d, cbcr_off = %d\n",
-			outp1->free_buf.paddr, outp1->free_buf.y_off,
-			outp1->free_buf.cbcr_off);
-		CDBG("vfe31_config_axi: video free_buf"
-			"paddr = 0x%x,y_off = %d, cbcr_off = %d\n",
-			outp2->free_buf.paddr, outp2->free_buf.y_off,
-			outp2->free_buf.cbcr_off);
-		break;
-
-	case CAMIF_TO_AXI_VIA_OUTPUT_2:  /* use wm0 only */
-		if (ad->bufnum2 < 1)
-			return -EINVAL;
-		CDBG("config axi for raw snapshot.\n");
-		*p = 0x60;    /* raw snapshot with wm0 */
-		vfe31_ctrl->outpath.out1.ch0 = 0; /* raw */
-		regp1 = &(ad->region[ad->bufnum1]);
-		vfe31_ctrl->outpath.output_mode |= VFE31_OUTPUT_MODE_S;
-		p1 = ao + 6;    /* wm0 for y  */
-		*p1 = (regp1->paddr + regp1->info.y_off);
-		break;
-
-	default:
-		break;
-	}
-	msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[V31_AXI_OUT_CFG].offset,
-		ao, vfe31_cmd[V31_AXI_OUT_CFG].length);
-	return 0;
-}
-
-static void vfe31_reset_internal_variables(void)
-{
-	unsigned long flags;
-
-	vfe31_ctrl->vfeImaskCompositePacked = 0;
-	/* state control variables */
-	vfe31_ctrl->start_ack_pending = FALSE;
-
-	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
-	vfe31_ctrl->stop_ack_pending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
-
-	vfe31_ctrl->reset_ack_pending = FALSE;
-
-	spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
-	vfe31_ctrl->update_ack_pending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->update_ack_lock, flags);
-
-	vfe31_ctrl->req_stop_video_rec = FALSE;
-	vfe31_ctrl->req_start_video_rec = FALSE;
-
-	spin_lock_irqsave(&vfe31_ctrl->state_lock, flags);
-	vfe31_ctrl->vstate = VFE_STATE_IDLE;
-	spin_unlock_irqrestore(&vfe31_ctrl->state_lock, flags);
-
-	/* 0 for continuous mode, 1 for snapshot mode */
-	vfe31_ctrl->operation_mode = 0;
-	vfe31_ctrl->outpath.output_mode = 0;
-	vfe31_ctrl->vfe_capture_count = 0;
-
-	/* this is unsigned 32 bit integer. */
-	vfe31_ctrl->vfeFrameId = 0;
-	vfe31_ctrl->output1Pattern = 0xffffffff;
-	vfe31_ctrl->output1Period  = 31;
-	vfe31_ctrl->output2Pattern = 0xffffffff;
-	vfe31_ctrl->output2Period  = 31;
-	vfe31_ctrl->vfeFrameSkipCount   = 0;
-	vfe31_ctrl->vfeFrameSkipPeriod  = 31;
-
-	/* Stats control variables. */
-	memset(&vfe31_ctrl->afStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-	memset(&vfe31_ctrl->awbStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-	memset(&vfe31_ctrl->aecStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-	memset(&vfe31_ctrl->ihistStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-	memset(&vfe31_ctrl->rsStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-	memset(&vfe31_ctrl->csStatsControl, 0,
-		sizeof(struct vfe_stats_control));
-}
-
-static void vfe31_reset(void)
-{
-	uint32_t vfe_version;
-
-	vfe31_reset_internal_variables();
-	vfe_version = vfe_io_r(VFE_VERSION);
-	CDBG("vfe_version = 0x%x\n", vfe_version);
-	/* disable all interrupts.  vfeImaskLocal is also reset to 0
-	* to begin with. */
-	vfe_io_w(VFE_DISABLE_ALL_IRQS, VFE_IRQ_MASK_0);
-	vfe_io_w(VFE_DISABLE_ALL_IRQS, VFE_IRQ_MASK_1);
-
-	/* clear all pending interrupts*/
-	vfe_io_w(VFE_CLEAR_ALL_IRQS, VFE_IRQ_CLEAR_0);
-	vfe_io_w(VFE_CLEAR_ALL_IRQS, VFE_IRQ_CLEAR_1);
-	vfe_io_w(1, VFE_IRQ_CMD);
-
-	/* enable reset_ack interrupt.  */
-	vfe_io_w(VFE_IMASK_WHILE_STOPPING_1, VFE_IRQ_MASK_1);
-
-	/* Write to VFE_GLOBAL_RESET_CMD to reset the vfe hardware. Once reset
-	 * is done, hardware interrupt will be generated.  VFE ist processes
-	 * the interrupt to complete the function call.  Note that the reset
-	 * function is synchronous. */
-	vfe_io_w(VFE_RESET_UPON_RESET_CMD, VFE_GLOBAL_RESET);
-}
-
-static int vfe31_operation_config(uint32_t *cmd)
-{
-	uint32_t *p = cmd;
-
-	vfe31_ctrl->operation_mode = *p;
-	vfe31_ctrl->stats_comp = *(++p);
-
-	vfe_io_w(*(++p), VFE_CFG_OFF);
-	vfe_io_w(*(++p), VFE_MODULE_CFG);
-	vfe_io_w(*(++p), VFE_REALIGN_BUF);
-	vfe_io_w(*(++p), VFE_CHROMA_UP);
-	vfe_io_w(*(++p), VFE_STATS_CFG);
-	return 0;
-}
-
-static uint32_t vfe_stats_awb_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_AWB_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_AWB_WR_PONG_ADDR);
-	vfe31_ctrl->awbStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static uint32_t vfe_stats_aec_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_AEC_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_AEC_WR_PONG_ADDR);
-	vfe31_ctrl->aecStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static uint32_t vfe_stats_af_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_AF_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_AF_WR_PONG_ADDR);
-	vfe31_ctrl->afStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static uint32_t vfe_stats_ihist_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_HIST_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_HIST_WR_PONG_ADDR);
-	vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static uint32_t vfe_stats_rs_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_RS_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_RS_WR_PONG_ADDR);
-	vfe31_ctrl->rsStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static uint32_t vfe_stats_cs_buf_init(struct vfe_cmd_stats_buf *in)
-{
-	uint32_t *ptr = in->statsBuf;
-	uint32_t addr;
-
-	addr = ptr[0];
-	vfe_io_w(addr, VFE_BUS_STATS_CS_WR_PING_ADDR);
-	addr = ptr[1];
-	vfe_io_w(addr, VFE_BUS_STATS_CS_WR_PONG_ADDR);
-	vfe31_ctrl->csStatsControl.nextFrameAddrBuf = in->statsBuf[2];
-	return 0;
-}
-
-static void vfe31_start_common(void)
-{
-	unsigned long flags;
-
-	vfe31_ctrl->start_ack_pending = TRUE;
-	CDBG("VFE opertaion mode = 0x%x.\n", vfe31_ctrl->operation_mode);
-	CDBG("VFE output path out mode = 0x%x.\n",
-		vfe31_ctrl->outpath.output_mode);
-	vfe_io_w(0x00EFE021, VFE_IRQ_MASK_0);
-	vfe_io_w(VFE_IMASK_WHILE_STOPPING_1, VFE_IRQ_MASK_1);
-
-	vfe_io_w(1, VFE_REG_UPDATE_CMD);
-	vfe_io_w(1, VFE_CAMIF_COMMAND);
-
-	spin_lock_irqsave(&vfe31_ctrl->state_lock, flags);
-	vfe31_ctrl->vstate = VFE_STATE_ACTIVE;
-	spin_unlock_irqrestore(&vfe31_ctrl->state_lock, flags);
-}
-
-static int vfe31_start_recording(void)
-{
-	vfe31_ctrl->req_start_video_rec = TRUE;
-	return 0;
-}
-
-static int vfe31_stop_recording(void)
-{
-	vfe31_ctrl->req_stop_video_rec = TRUE;
-	return 0;
-}
-
-static int vfe31_capture(uint32_t num_frames_capture)
-{
-	uint32_t irq_comp_mask = 0;
-
-	/* capture command is valid for both idle and active state. */
-	vfe31_ctrl->outpath.out1.capture_cnt = num_frames_capture;
-	if (vfe31_ctrl->operation_mode == 1) {
-		vfe31_ctrl->outpath.out0.capture_cnt = num_frames_capture;
-	}
-	vfe31_ctrl->vfe_capture_count = num_frames_capture;
-	irq_comp_mask = vfe_io_r(VFE_IRQ_COMP_MASK);
-
-	if (vfe31_ctrl->operation_mode == 1) {
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
-			irq_comp_mask |= (0x1 << vfe31_ctrl->outpath.out0.ch0 |
-					0x1 << vfe31_ctrl->outpath.out0.ch1);
-		}
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
-			irq_comp_mask |=
-				(0x1 << (vfe31_ctrl->outpath.out1.ch0 + 8) |
-				0x1 << (vfe31_ctrl->outpath.out1.ch1 + 8));
-		}
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out0.ch0);
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out0.ch1);
-		}
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out1.ch0);
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out1.ch1);
-		}
-	} else {  /* this is raw snapshot mode. */
-		CDBG("config the comp imask for raw snapshot mode.\n");
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
-			irq_comp_mask |=
-				(0x1 << (vfe31_ctrl->outpath.out1.ch0 + 8));
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out1.ch0);
-		}
-	}
-	vfe_io_w(irq_comp_mask, VFE_IRQ_COMP_MASK);
-	vfe_io_r(VFE_IRQ_COMP_MASK);
-	vfe31_start_common();
-	vfe_io_r(VFE_IRQ_COMP_MASK);
-	/* for debug */
-	vfe_io_w(1, 0x18C);
-	vfe_io_w(1, 0x188);
-	return 0;
-}
-
-static int vfe31_start(void)
-{
-	uint32_t irq_comp_mask = 0;
-
-	/* start command now is only good for continuous mode. */
-	if (vfe31_ctrl->operation_mode & 1)
-		return 0;
-	irq_comp_mask = vfe_io_r(VFE_IRQ_COMP_MASK);
-
-	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
-		irq_comp_mask |= (0x1 << vfe31_ctrl->outpath.out0.ch0 |
-			0x1 << vfe31_ctrl->outpath.out0.ch1);
-	}
-
-	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
-		irq_comp_mask |= (0x1 << (vfe31_ctrl->outpath.out2.ch0 + 16) |
-			0x1 << (vfe31_ctrl->outpath.out2.ch1 + 16));
-	}
-
-	vfe_io_w(irq_comp_mask, VFE_IRQ_COMP_MASK);
-
-	if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
-		vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out0.ch0);
-		vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out0.ch1);
-	}
-	vfe31_start_common();
-	return 0;
-}
-
-static void vfe31_update(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
-	vfe31_ctrl->update_ack_pending = TRUE;
-	spin_unlock_irqrestore(&vfe31_ctrl->update_ack_lock, flags);
-	vfe_io_w(1, VFE_REG_UPDATE_CMD);
-}
-
-void vfe31_program_dmi_cfg(enum VFE31_DMI_RAM_SEL bankSel)
-{
-	/* set bit 8 for auto increment. */
-	uint32_t value = VFE_DMI_CFG_DEFAULT;
-	value += (uint32_t)bankSel;
-
-	vfe_io_w(value, VFE_DMI_CFG);
-	/* by default, always starts with offset 0. */
-	vfe_io_w(0, VFE_DMI_ADDR);
-}
-
-void vfe31_write_gamma_cfg(enum VFE31_DMI_RAM_SEL channel_sel,
-						const uint32_t *tbl)
-{
-	int i;
-	uint32_t value, value1, value2;
-
-	vfe31_program_dmi_cfg(channel_sel);
-	/* for loop for extracting init table. */
-	for (i = 0 ; i < (VFE31_GAMMA_NUM_ENTRIES/2) ; i++) {
-		value = *tbl++;
-		value1 = value & 0x0000FFFF;
-		value2 = (value & 0xFFFF0000)>>16;
-		vfe_io_w(value1, VFE_DMI_DATA_LO);
-		vfe_io_w(value2, VFE_DMI_DATA_LO);
-	}
-	vfe31_program_dmi_cfg(NO_MEM_SELECTED);
-}
-
-static int vfe31_proc_general(struct msm_vfe31_cmd *cmd)
-{
-	int i, rc = 0;
-	uint32_t old_val = 0, new_val = 0;
-	uint32_t *cmdp = NULL;
-	uint32_t *cmdp_local = NULL;
-
-	CDBG("vfe31_proc_general: cmdID = %d, length = %d\n",
-		cmd->id, cmd->length);
-	switch (cmd->id) {
-	case V31_RESET:
-		vfe31_reset();
-		break;
-	case V31_START:
-		rc = vfe31_start();
-		break;
-	case V31_UPDATE:
-		vfe31_update();
-		break;
-	case V31_CAPTURE:
-		rc = vfe31_capture(1);
-		break;
-	case V31_START_RECORDING:
-		rc = vfe31_start_recording();
-		break;
-	case V31_STOP_RECORDING:
-		rc = vfe31_stop_recording();
-		break;
-	case V31_OPERATION_CFG:
-		if (cmd->length != V31_OPERATION_CFG_LEN) {
-			rc = -EINVAL;
-			goto proc_general_done;
-		}
-		cmdp = kmalloc(V31_OPERATION_CFG_LEN, GFP_KERNEL);
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				V31_OPERATION_CFG_LEN)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		rc = vfe31_operation_config(cmdp);
-		break;
-
-	case V31_STATS_AE_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= AE_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_STATS_AF_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= AF_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_STATS_AWB_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= AWB_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_STATS_IHIST_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= IHIST_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-
-	case V31_STATS_RS_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= RS_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_STATS_CS_START:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val |= CS_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_MCE_UPDATE:
-	case V31_MCE_CFG:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		/* Incrementing with 4 so as to point to the 2nd Register as
-		the 2nd register has the mce_enable bit */
-		old_val = vfe_io_r(V31_CHROMA_EN_OFF + 4);
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		cmdp_local = cmdp;
-		new_val = *cmdp_local;
-		old_val &= MCE_EN_MASK;
-		new_val = new_val | old_val;
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_CHROMA_EN_OFF + 4,
-			      &new_val, 4);
-		cmdp_local += 1;
-
-		old_val = vfe_io_r(V31_CHROMA_EN_OFF + 8);
-		new_val = *cmdp_local;
-		old_val &= MCE_Q_K_MASK;
-		new_val = new_val | old_val;
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_CHROMA_EN_OFF + 8,
-			      &new_val, 4);
-		cmdp_local += 1;
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp_local, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_DEMOSAIC_2_UPDATE: /* 38 BPC update   */
-	case V31_DEMOSAIC_2_CFG:  /* 14 BPC config   */
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		cmdp_local = cmdp;
-		new_val = *cmdp_local;
-
-		old_val = vfe_io_r(V31_DEMOSAIC_0_OFF);
-		old_val &= BPC_MASK;
-
-		new_val = new_val | old_val;
-		*cmdp_local = new_val;
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_DEMOSAIC_0_OFF,
-			      cmdp_local, 4);
-		cmdp_local += 1;
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp_local, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_DEMOSAIC_1_UPDATE:/* 37 ABF update  */
-	case V31_DEMOSAIC_1_CFG: /* 13 ABF config  */
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		cmdp_local = cmdp;
-		new_val = *cmdp_local;
-
-		old_val = vfe_io_r(V31_DEMOSAIC_0_OFF);
-		old_val &= ABF_MASK;
-		new_val = new_val | old_val;
-		*cmdp_local = new_val;
-
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_DEMOSAIC_0_OFF,
-			      cmdp_local, 4);
-
-		cmdp_local += 1;
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp_local, vfe31_cmd[cmd->id].length);
-		break;
-
-	case V31_ROLL_OFF_CFG:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		cmdp_local = cmdp;
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp_local, 16);
-		cmdp_local += 4;
-		vfe31_program_dmi_cfg(ROLLOFF_RAM);
-		/* for loop for extrcting init table. */
-		for (i = 0 ; i < (VFE31_ROLL_OFF_INIT_TABLE_SIZE * 2) ; i++) {
-			vfe_io_w(*cmdp_local, VFE_DMI_DATA_LO);
-			cmdp_local++;
-		}
-		CDBG("done writing init table\n");
-		/* by default, always starts with offset 0. */
-		vfe_io_w(LENS_ROLL_OFF_DELTA_TABLE_OFFSET, VFE_DMI_ADDR);
-		/* for loop for extracting delta table. */
-		for (i = 0 ; i < (VFE31_ROLL_OFF_DELTA_TABLE_SIZE * 2) ; i++) {
-			vfe_io_w(*cmdp_local, VFE_DMI_DATA_LO);
-			cmdp_local++;
-		}
-		vfe31_program_dmi_cfg(NO_MEM_SELECTED);
-		break;
-
-	case V31_LA_CFG:
-	case V31_LA_UPDATE:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-
-		/* If the value is 0x00 then write in to LUT bank0
-		if the value is 0x01 then write in to LUT bank1 */
-		if (*cmdp == 0x0)
-			vfe31_program_dmi_cfg(LUMA_ADAPT_LUT_RAM_BANK0);
-		else
-			vfe31_program_dmi_cfg(LUMA_ADAPT_LUT_RAM_BANK1);
-		cmdp += 1;
-		/* for loop for extracting init table. */
-		for (i = 0 ; i < VFE31_LA_TABLE_LENGTH ; i++) {
-			vfe_io_w(*cmdp, VFE_DMI_DATA_LO);
-			cmdp++;
-		}
-		vfe31_program_dmi_cfg(NO_MEM_SELECTED);
-		cmdp -= 1;
-		break;
-
-	case V31_RGB_G_CFG:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_RGB_G_OFF, cmdp, 4);
-		cmdp += 1;
-		vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK0 , cmdp);
-		vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK0 , cmdp);
-		vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK0 , cmdp);
-		cmdp -= 1;
-		break;
-
-	case V31_RGB_G_UPDATE:
-		cmdp = kmalloc(cmd->length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-		if (copy_from_user(cmdp, (void __user *)cmd->value,
-				cmd->length)) {
-			rc = -EFAULT;
-			goto proc_general_done;
-		}
-
-		msm_io_memcpy(vfe31_ctrl->vfebase + V31_RGB_G_OFF, cmdp, 4);
-		old_val = *cmdp;
-		cmdp += 1;
-
-		if (old_val) {
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK1, cmdp);
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK1, cmdp);
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK1, cmdp);
-		} else {
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH0_BANK0, cmdp);
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH1_BANK0, cmdp);
-			vfe31_write_gamma_cfg(RGBLUT_RAM_CH2_BANK0, cmdp);
-		}
-		cmdp -= 1;
-		break;
-
-	case V31_STATS_AWB_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~AWB_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STATS_AE_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~AE_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STATS_AF_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~AF_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STATS_IHIST_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~IHIST_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STATS_RS_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~RS_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STATS_CS_STOP:
-		old_val = vfe_io_r(VFE_MODULE_CFG);
-		old_val &= ~CS_ENABLE_MASK;
-		vfe_io_w(old_val, VFE_MODULE_CFG);
-		break;
-
-	case V31_STOP:
-		vfe_stop();
-		break;
-
-	default:
-		if (cmd->length != vfe31_cmd[cmd->id].length)
-			return -EINVAL;
-
-		cmdp = kmalloc(vfe31_cmd[cmd->id].length, GFP_KERNEL);
-		if (!cmdp) {
-			rc = -ENOMEM;
-			goto proc_general_done;
-		}
-
-		CHECKED_COPY_FROM_USER(cmdp);
-		msm_io_memcpy(vfe31_ctrl->vfebase + vfe31_cmd[cmd->id].offset,
-				cmdp, vfe31_cmd[cmd->id].length);
-		break;
-	}
-
-proc_general_done:
-	kfree(cmdp);
-
-	return rc;
-}
-
-static void vfe31_stats_af_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->af_ack_lock, flags);
-	vfe31_ctrl->afStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->afStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
-}
-
-static void vfe31_stats_awb_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->awb_ack_lock, flags);
-	vfe31_ctrl->awbStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->awbStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
-}
-
-static void vfe31_stats_aec_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->aec_ack_lock, flags);
-	vfe31_ctrl->aecStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->aecStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
-}
-
-static void vfe31_stats_ihist_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->ihist_ack_lock, flags);
-	vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->ihistStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->ihist_ack_lock, flags);
-}
-
-static void vfe31_stats_rs_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->rs_ack_lock, flags);
-	vfe31_ctrl->rsStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->rsStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->rs_ack_lock, flags);
-}
-
-static void vfe31_stats_cs_ack(struct vfe_cmd_stats_ack *pAck)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vfe31_ctrl->cs_ack_lock, flags);
-	vfe31_ctrl->csStatsControl.nextFrameAddrBuf = pAck->nextStatsBuf;
-	vfe31_ctrl->csStatsControl.ackPending = FALSE;
-	spin_unlock_irqrestore(&vfe31_ctrl->cs_ack_lock, flags);
-}
-
-static int vfe31_config(struct msm_vfe_cfg_cmd *cmd, void *data)
-{
-	struct msm_vfe31_cmd vfecmd;
-	long rc = 0;
-	uint32_t i = 0;
-	struct vfe_cmd_stats_buf *scfg = NULL;
-	struct msm_pmem_region *regptr = NULL;
-	struct vfe_cmd_stats_ack *sack = NULL;
-
-	if (cmd->cmd_type != CMD_FRAME_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_AEC_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_AWB_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_IHIST_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_RS_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_CS_BUF_RELEASE &&
-		cmd->cmd_type != CMD_STATS_AF_BUF_RELEASE) {
-		if (copy_from_user(&vfecmd, (void __user *)cmd->value,
-				sizeof(vfecmd))) {
-			pr_err("%s %d: copy_from_user failed\n", __func__,
-				__LINE__);
-			return -EFAULT;
-		}
-	} else if (cmd->cmd_type != CMD_FRAME_BUF_RELEASE) {
-		/* This must be stats release. */
-		if (!data)
-			return -EFAULT;
-		sack = kmalloc(sizeof(struct vfe_cmd_stats_ack), GFP_KERNEL);
-		if (!sack)
-			return -ENOMEM;
-		sack->nextStatsBuf = *(uint32_t *)data;
-	}
-
-	CDBG("%s: cmdType = %d\n", __func__, cmd->cmd_type);
-
-	switch (cmd->cmd_type) {
-	case CMD_GENERAL:
-		rc = vfe31_proc_general(&vfecmd);
-		break;
-	case CMD_FRAME_BUF_RELEASE: {
-		struct msm_frame *b;
-		unsigned long p;
-		struct vfe31_free_buf *fbuf = NULL;
-		if (!data)
-			return -EFAULT;
-
-		b = (struct msm_frame *)(cmd->value);
-		p = *(unsigned long *)data;
-
-		CDBG("CMD_FRAME_BUF_RELEASE b->path = %d\n", b->path);
-
-		if (b->path & OUTPUT_TYPE_P) {
-			CDBG("CMD_FRAME_BUF_RELEASE got free buffer\n");
-			fbuf = &vfe31_ctrl->outpath.out0.free_buf;
-		} else if (b->path & OUTPUT_TYPE_S) {
-			fbuf = &vfe31_ctrl->outpath.out1.free_buf;
-		} else if (b->path & OUTPUT_TYPE_V) {
-			fbuf = &vfe31_ctrl->outpath.out2.free_buf;
-		} else
-			return -EFAULT;
-
-		fbuf->paddr = p;
-		fbuf->y_off = b->y_off;
-		fbuf->cbcr_off = b->cbcr_off;
-		fbuf->available = 1;
-		}
-		break;
-
-	case CMD_SNAP_BUF_RELEASE:
-		break;
-	case CMD_STATS_AEC_BUF_RELEASE:
-		vfe31_stats_aec_ack(sack);
-		break;
-	case CMD_STATS_AF_BUF_RELEASE:
-		vfe31_stats_af_ack(sack);
-		break;
-	case CMD_STATS_AWB_BUF_RELEASE:
-		vfe31_stats_awb_ack(sack);
-		break;
-	case CMD_STATS_IHIST_BUF_RELEASE:
-		vfe31_stats_ihist_ack(sack);
-		break;
-	case CMD_STATS_RS_BUF_RELEASE:
-		vfe31_stats_rs_ack(sack);
-		break;
-	case CMD_STATS_CS_BUF_RELEASE:
-		vfe31_stats_cs_ack(sack);
-		break;
-
-	case CMD_AXI_CFG_PREVIEW: {
-		struct axidata *axid;
-		uint32_t *axio = NULL;
-		axid = data;
-		if (!axid)
-			return -EFAULT;
-		axio = kmalloc(vfe31_cmd[V31_AXI_OUT_CFG].length, GFP_KERNEL);
-		if (!axio)
-			return -ENOMEM;
-
-		if (copy_from_user(axio, (void __user *)vfecmd.value,
-				vfe31_cmd[V31_AXI_OUT_CFG].length)) {
-			kfree(axio);
-			return -EFAULT;
-		}
-		vfe31_config_axi(OUTPUT_2, axid, axio);
-		kfree(axio);
-	}
-		break;
-
-	case CMD_RAW_PICT_AXI_CFG: {
-		struct axidata *axid;
-		uint32_t *axio = NULL;
-		axid = data;
-		if (!axid)
-			return -EFAULT;
-		axio = kmalloc(vfe31_cmd[V31_AXI_OUT_CFG].length, GFP_KERNEL);
-		if (!axio)
-			return -ENOMEM;
-
-		if (copy_from_user(axio, (void __user *)vfecmd.value,
-				vfe31_cmd[V31_AXI_OUT_CFG].length)) {
-			kfree(axio);
-			return -EFAULT;
-		}
-		vfe31_config_axi(CAMIF_TO_AXI_VIA_OUTPUT_2, axid, axio);
-		kfree(axio);
-	}
-		break;
-
-	case CMD_AXI_CFG_SNAP: {
-		struct axidata *axid;
-		uint32_t *axio = NULL;
-		axid = data;
-		if (!axid)
-			return -EFAULT;
-		axio = kmalloc(vfe31_cmd[V31_AXI_OUT_CFG].length, GFP_KERNEL);
-		if (!axio)
-			return -ENOMEM;
-
-		if (copy_from_user(axio, (void __user *)vfecmd.value,
-				vfe31_cmd[V31_AXI_OUT_CFG].length)) {
-			kfree(axio);
-			return -EFAULT;
-		}
-		vfe31_config_axi(OUTPUT_1_AND_2, axid, axio);
-		kfree(axio);
-	}
-		break;
-
-	case CMD_AXI_CFG_VIDEO: {
-		struct axidata *axid;
-		uint32_t *axio = NULL;
-		axid = data;
-		if (!axid)
-			return -EFAULT;
-		axio = kmalloc(vfe31_cmd[V31_AXI_OUT_CFG].length, GFP_KERNEL);
-		if (!axio)
-			return -ENOMEM;
-
-		if (copy_from_user(axio, (void __user *)vfecmd.value,
-				vfe31_cmd[V31_AXI_OUT_CFG].length)) {
-			kfree(axio);
-			return -EFAULT;
-		}
-		vfe31_config_axi(OUTPUT_1_AND_3, axid, axio);
-		kfree(axio);
-	}
-		break;
-
-	case CMD_STATS_AF_ENABLE:
-	case CMD_STATS_AWB_ENABLE:
-	case CMD_STATS_IHIST_ENABLE:
-	case CMD_STATS_RS_ENABLE:
-	case CMD_STATS_CS_ENABLE:
-	case CMD_STATS_AEC_ENABLE: {
-		struct axidata *axid;
-		axid = (struct axidata *)data;
-		if (!axid)
-			return -EFAULT;
-
-		scfg = kmalloc(sizeof(struct vfe_cmd_stats_buf), GFP_KERNEL);
-		if (!scfg)
-			return -ENOMEM;
-		regptr = axid->region;
-		if (axid->bufnum1 > 0) {
-			for (i = 0; i < axid->bufnum1; i++) {
-				scfg->statsBuf[i] = (uint32_t)(regptr->paddr);
-				regptr++;
-			}
-		}
-		/* individual */
-		switch (cmd->cmd_type) {
-		case CMD_STATS_AEC_ENABLE:
-			rc = vfe_stats_aec_buf_init(scfg);
-			break;
-		case CMD_STATS_AF_ENABLE:
-			rc = vfe_stats_af_buf_init(scfg);
-			break;
-		case CMD_STATS_AWB_ENABLE:
-			rc = vfe_stats_awb_buf_init(scfg);
-			break;
-		case CMD_STATS_IHIST_ENABLE:
-			rc = vfe_stats_ihist_buf_init(scfg);
-			break;
-		case CMD_STATS_RS_ENABLE:
-			rc = vfe_stats_rs_buf_init(scfg);
-			break;
-		case CMD_STATS_CS_ENABLE:
-			rc = vfe_stats_cs_buf_init(scfg);
-			break;
-		}
-	}
-
-	default:
-		rc = -EINVAL;
-		break;
-	}
-	kfree(scfg);
-	kfree(sack);
-	CDBG("%s done: rc = %d\n", __func__, (int) rc);
-	return rc;
-}
-
-static inline void vfe31_read_irq_status(struct vfe31_irq_status *out)
-{
-	memset(out, 0, sizeof(struct vfe31_irq_status));
-	out->vfeIrqStatus0 = vfe_io_r(VFE_IRQ_STATUS_0);
-	out->vfeIrqStatus1 = vfe_io_r(VFE_IRQ_STATUS_1);
-	out->camifStatus = vfe_io_r(VFE_CAMIF_STATUS);
-	CDBG("camifStatus  = 0x%x\n", out->camifStatus);
-}
-
-static void vfe31_send_msg_no_payload(enum VFE31_MESSAGE_ID id)
-{
-	struct vfe_message msg;
-
-	CDBG("vfe31_send_msg_no_payload\n");
-	msg._d = id;
-	vfe31_proc_ops(id, &msg, 0);
-}
-
-static void vfe31_process_reg_update_irq(void)
-{
-	unsigned long flags;
-	uint32_t temp;
-
-	if (vfe31_ctrl->req_start_video_rec) {
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out2.ch0);
-			vfe_io_w_axi_out_chan(1, vfe31_ctrl->outpath.out2.ch1);
-		}
-		vfe31_ctrl->req_start_video_rec =  FALSE;
-		CDBG("start video triggered .\n");
-	} else if (vfe31_ctrl->req_stop_video_rec) {
-		if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_V) {
-			vfe_io_w_axi_out_chan(0, vfe31_ctrl->outpath.out2.ch0);
-			vfe_io_w_axi_out_chan(0, vfe31_ctrl->outpath.out2.ch1);
-		}
-		vfe31_ctrl->req_stop_video_rec =  FALSE;
-		CDBG("stop video triggered .\n");
-	}
-	if (vfe31_ctrl->start_ack_pending == TRUE) {
-		vfe31_send_msg_no_payload(MSG_ID_START_ACK);
-		vfe31_ctrl->start_ack_pending = FALSE;
-	} else {
-		spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
-		if (vfe31_ctrl->update_ack_pending == TRUE) {
-			spin_unlock_irqrestore(
-				&vfe31_ctrl->update_ack_lock, flags);
-			vfe31_send_msg_no_payload(MSG_ID_UPDATE_ACK);
-			spin_lock_irqsave(&vfe31_ctrl->update_ack_lock, flags);
-			vfe31_ctrl->update_ack_pending = FALSE;
-			spin_unlock_irqrestore(
-				&vfe31_ctrl->update_ack_lock, flags);
-		} else {
-			spin_unlock_irqrestore(
-				&vfe31_ctrl->update_ack_lock, flags);
-		}
-	}
-	if (vfe31_ctrl->operation_mode & 1) {  /* in snapshot mode */
-		/* later we need to add check for live snapshot mode. */
-		vfe31_ctrl->vfe_capture_count--;
-		/* if last frame to be captured: */
-		if (vfe31_ctrl->vfe_capture_count == 0) {
-			/* stop the bus output:  write master enable = 0*/
-			if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_PT) {
-				vfe_io_w_axi_out_chan(0,
-					vfe31_ctrl->outpath.out0.ch0);
-				vfe_io_w_axi_out_chan(0,
-					vfe31_ctrl->outpath.out0.ch1);
-			}
-			if (vfe31_ctrl->outpath.output_mode & VFE31_OUTPUT_MODE_S) {
-				vfe_io_w_axi_out_chan(0,
-					vfe31_ctrl->outpath.out1.ch0);
-				vfe_io_w_axi_out_chan(0,
-					vfe31_ctrl->outpath.out1.ch1);
-			}
-			vfe_io_w(CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY,
-				VFE_CAMIF_COMMAND);
-
-			temp = vfe_io_r(VFE_CAMIF_COMMAND);
-			/* then do reg_update. */
-			vfe_io_w(1, VFE_REG_UPDATE_CMD);
-		}
-	} /* if snapshot mode. */
-}
-
-static void vfe31_set_default_reg_values(void)
-{
-	vfe_io_w(0x800080, VFE_DEMUX_GAIN_0);
-	vfe_io_w(0x800080, VFE_DEMUX_GAIN_1);
-	vfe_io_w(0xFFFFF, VFE_CGC_OVERRIDE);
-
-	/* default frame drop period and pattern */
-	vfe_io_w(0x1f, VFE_FRAMEDROP_ENC_Y_CFG);
-	vfe_io_w(0x1f, VFE_FRAMEDROP_ENC_CBCR_CFG);
-	vfe_io_w(0xFFFFFFFF, VFE_FRAMEDROP_ENC_Y_PATTERN);
-	vfe_io_w(0xFFFFFFFF, VFE_FRAMEDROP_ENC_CBCR_PATTERN);
-	vfe_io_w(0x1f, VFE_FRAMEDROP_VIEW_Y);
-	vfe_io_w(0x1f, VFE_FRAMEDROP_VIEW_CBCR);
-	vfe_io_w(0xFFFFFFFF, VFE_FRAMEDROP_VIEW_Y_PATTERN);
-	vfe_io_w(0xFFFFFFFF, VFE_FRAMEDROP_VIEW_CBCR_PATTERN);
-	vfe_io_w(0, VFE_CLAMP_MIN);
-	vfe_io_w(0xFFFFFF, VFE_CLAMP_MAX);
-
-	/* stats UB config */
-	vfe_io_w(0x3900007, VFE_BUS_STATS_AEC_UB_CFG);
-	vfe_io_w(0x3980007, VFE_BUS_STATS_AF_UB_CFG);
-	vfe_io_w(0x3A0000F, VFE_BUS_STATS_AWB_UB_CFG);
-	vfe_io_w(0x3B00007, VFE_BUS_STATS_RS_UB_CFG);
-	vfe_io_w(0x3B8001F, VFE_BUS_STATS_CS_UB_CFG);
-	vfe_io_w(0x3D8001F, VFE_BUS_STATS_HIST_UB_CFG);
-	vfe_io_w(0x3F80007, VFE_BUS_STATS_SKIN_UB_CFG);
-}
-
-static void vfe31_process_reset_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->state_lock, flags);
-	vfe31_ctrl->vstate = VFE_STATE_IDLE;
-	spin_unlock_irqrestore(&vfe31_ctrl->state_lock, flags);
-
-	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
-	if (vfe31_ctrl->stop_ack_pending) {
-		vfe31_ctrl->stop_ack_pending = FALSE;
-		spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
-		vfe31_send_msg_no_payload(MSG_ID_STOP_ACK);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
-		/* this is from reset command. */
-		vfe31_set_default_reg_values();
-
-		/* reload all write masters. (frame & line)*/
-		vfe_io_w(0x7FFF, VFE_BUS_CMD);
-		vfe31_send_msg_no_payload(MSG_ID_RESET_ACK);
-	}
-}
-
-static void vfe31_process_camif_sof_irq(void)
-{
-	uint32_t temp;
-
-	if (vfe31_ctrl->operation_mode == 3) {  /* in raw snapshot mode */
-		if (vfe31_ctrl->start_ack_pending) {
-			vfe31_send_msg_no_payload(MSG_ID_START_ACK);
-			vfe31_ctrl->start_ack_pending = FALSE;
-		}
-		vfe31_ctrl->vfe_capture_count--;
-		/* if last frame to be captured: */
-		if (vfe31_ctrl->vfe_capture_count == 0) {
-			vfe_io_w(CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY, VFE_CAMIF_COMMAND);
-			temp = vfe_io_r(VFE_CAMIF_COMMAND);
-		}
-	} /* if raw snapshot mode. */
-
-	vfe31_ctrl->vfeFrameId++;
-	CDBG("camif_sof_irq, frameId = %d\n", vfe31_ctrl->vfeFrameId);
-}
-
-static void vfe31_process_output_path_irq_0(void)
-{
-	uint32_t ping_pong;
-	uint32_t pyaddr, pcbcraddr;
-	uint8_t out_bool = 0;
-
-	/* we render frames in the following conditions:
-	1. Continuous mode and the free buffer is avaialable.
-	2. In snapshot shot mode, free buffer is not always available.
-	when pending snapshot count is <=1,  then no need to use
-	free buffer.
-	*/
-	out_bool =
-		((vfe31_ctrl->operation_mode & 1) &&
-		(vfe31_ctrl->vfe_capture_count <= 1)) ||
-		(vfe31_ctrl->outpath.out0.free_buf.available);
-	if (out_bool) {
-		ping_pong = vfe_io_r(VFE_BUS_PING_PONG_STATUS);
-
-		/* Y channel */
-		pyaddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out0.ch0);
-		/* Chroma channel */
-		pcbcraddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out0.ch1);
-
-		CDBG("output path 0, pyaddr = 0x%x, pcbcraddr = 0x%x\n",
-			pyaddr, pcbcraddr);
-		if (vfe31_ctrl->outpath.out0.free_buf.available) {
-			/* Y channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out0.ch0,
-				vfe31_ctrl->outpath.out0.free_buf.paddr +
-				vfe31_ctrl->outpath.out0.free_buf.y_off);
-			/* Chroma channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out0.ch1,
-				vfe31_ctrl->outpath.out0.free_buf.paddr +
-				vfe31_ctrl->outpath.out0.free_buf.cbcr_off);
-			vfe31_ctrl->outpath.out0.free_buf.available = 0;
-		}
-		if (vfe31_ctrl->operation_mode & 1) {
-			/* will add message for multi-shot. */
-			vfe31_ctrl->outpath.out0.capture_cnt--;
-		} else {
-			/* always send message for continous mode. */
-			/* if continuous mode, this is for display. (preview) */
-			vfe_send_outmsg(MSG_ID_OUTPUT_P, pyaddr, pcbcraddr);
-		}
-	} else {
-		vfe31_ctrl->outpath.out0.frame_drop_cnt++;
-		CDBG("path_irq_0 - no free buffer!\n");
-	}
-}
-
-static void vfe31_process_output_path_irq_1(void)
-{
-	uint32_t ping_pong;
-	uint32_t pyaddr, pcbcraddr;
-	/* this must be snapshot main image output. */
-	uint8_t out_bool;
-
-	/* we render frames in the following conditions:
-	1. Continuous mode and the free buffer is avaialable.
-	2. In snapshot shot mode, free buffer is not always available.
-	-- when pending snapshot count is <=1,  then no need to use
-	free buffer.
-	*/
-	out_bool =
-		((vfe31_ctrl->operation_mode & 1) &&
-		 (vfe31_ctrl->vfe_capture_count <= 1)) ||
-		(vfe31_ctrl->outpath.out1.free_buf.available);
-	if (out_bool) {
-		ping_pong = vfe_io_r(VFE_BUS_PING_PONG_STATUS);
-
-		/* Y channel */
-		pyaddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out1.ch0);
-		/* Chroma channel */
-		pcbcraddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out1.ch1);
-
-		CDBG("snapshot main, pyaddr = 0x%x, pcbcraddr = 0x%x\n",
-			pyaddr, pcbcraddr);
-		if (vfe31_ctrl->outpath.out1.free_buf.available) {
-			/* Y channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out1.ch0,
-				vfe31_ctrl->outpath.out1.free_buf.paddr +
-				vfe31_ctrl->outpath.out1.free_buf.y_off);
-			/* Chroma channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out1.ch1,
-				vfe31_ctrl->outpath.out1.free_buf.paddr +
-				vfe31_ctrl->outpath.out1.free_buf.cbcr_off);
-			vfe31_ctrl->outpath.out1.free_buf.available = 0;
-		}
-
-		vfe31_ctrl->outpath.out1.capture_cnt--;
-	} else {
-		vfe31_ctrl->outpath.out1.frame_drop_cnt++;
-		CDBG("path_irq_1 - no free buffer!\n");
-	}
-}
-
-static void vfe31_process_output_path_irq_2(void)
-{
-	uint32_t ping_pong;
-	uint32_t pyaddr, pcbcraddr;
-	uint8_t out_bool;
-
-	/* we render frames in the following conditions:
-	1. Continuous mode and the free buffer is avaialable.
-	2. In snapshot shot mode, free buffer is not always available.
-	-- when pending snapshot count is <=1,  then no need to use
-	free buffer.
-	*/
-	out_bool =
-		((vfe31_ctrl->operation_mode & 1) &&
-		(vfe31_ctrl->vfe_capture_count <= 1)) ||
-		(vfe31_ctrl->outpath.out2.free_buf.available);
-	if (out_bool) {
-		ping_pong = vfe_io_r(VFE_BUS_PING_PONG_STATUS);
-
-		/* Y channel */
-		pyaddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out2.ch0);
-		/* Chroma channel */
-		pcbcraddr = vfe31_get_ch_addr(ping_pong,
-			vfe31_ctrl->outpath.out2.ch1);
-
-		CDBG("video output, pyaddr = 0x%x, pcbcraddr = 0x%x\n",
-			pyaddr, pcbcraddr);
-
-		if (vfe31_ctrl->outpath.out2.free_buf.available) {
-			/* Y channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out2.ch0,
-				vfe31_ctrl->outpath.out2.free_buf.paddr +
-				vfe31_ctrl->outpath.out2.free_buf.y_off);
-			/* Chroma channel */
-			vfe31_put_ch_addr(ping_pong,
-				vfe31_ctrl->outpath.out2.ch1,
-				vfe31_ctrl->outpath.out2.free_buf.paddr +
-				vfe31_ctrl->outpath.out2.free_buf.cbcr_off);
-			vfe31_ctrl->outpath.out2.free_buf.available = 0;
-		}
-		vfe_send_outmsg(MSG_ID_OUTPUT_V, pyaddr, pcbcraddr);
-	} else {
-		vfe31_ctrl->outpath.out2.frame_drop_cnt++;
-		CDBG("path_irq_2 - no free buffer!\n");
-	}
-}
-
-static void vfe31_process_stats_comb_irq(uint32_t *irqstatus)
-{
-	return;
-}
-
-static uint32_t vfe31_process_stats_irq_common(uint32_t statsNum,
-						uint32_t newAddr) {
-	uint32_t pingpongStatus;
-	uint32_t returnAddr;
-	uint32_t pingpongAddrOffset;
-
-	/* must be 0=ping, 1=pong */
-	pingpongStatus =
-		(vfe_io_r(VFE_BUS_PING_PONG_STATUS)
-		& ((uint32_t)(1<<(statsNum + 7)))) >> (statsNum + 7);
-	/* stats bits starts at 7 */
-	CDBG("statsNum %d, pingpongStatus %d\n", statsNum, pingpongStatus);
-	pingpongAddrOffset =
-		((uint32_t)(VFE_BUS_STATS_PING_PONG_BASE)) +
-				(3*statsNum)*4 + (1-pingpongStatus)*4;
-	returnAddr = vfe_io_r(pingpongAddrOffset);
-	vfe_io_w(newAddr, pingpongAddrOffset);
-	return returnAddr;
-}
-
-static void vfe_send_stats_msg(uint32_t bufAddress, uint32_t statsNum)
-{
-	struct vfe_message msg;
-
-	/* fill message with right content. */
-	msg._u.msgStats.frameCounter = vfe31_ctrl->vfeFrameId;
-	msg._u.msgStats.buffer = bufAddress;
-
-	switch (statsNum) {
-	case statsAeNum:
-		msg._d = MSG_ID_STATS_AEC;
-		break;
-	case statsAfNum:
-		msg._d = MSG_ID_STATS_AF;
-		break;
-	case statsAwbNum:
-		msg._d = MSG_ID_STATS_AWB;
-		break;
-	case statsIhistNum:
-		msg._d = MSG_ID_STATS_IHIST;
-		break;
-	case statsRsNum:
-		msg._d = MSG_ID_STATS_RS;
-		break;
-	case statsCsNum:
-		msg._d = MSG_ID_STATS_CS;
-		break;
-	default:
-		goto stats_done;
-	}
-
-	vfe31_proc_ops(msg._d, &msg, sizeof(struct vfe_message));
-stats_done:
-	return;
-}
-
-static void vfe31_process_stats_ae_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->aec_ack_lock, flags);
-	if (!vfe31_ctrl->aecStatsControl.ackPending) {
-		vfe31_ctrl->aecStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
-		vfe31_ctrl->aecStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsAeNum,
-			vfe31_ctrl->aecStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->aecStatsControl.bufToRender,
-						statsAeNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->aec_ack_lock, flags);
-		vfe31_ctrl->aecStatsControl.droppedStatsFrameCount++;
-	}
-
-}
-
-static void vfe31_process_stats_af_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->af_ack_lock, flags);
-	if (!vfe31_ctrl->afStatsControl.ackPending) {
-		vfe31_ctrl->afStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
-		vfe31_ctrl->afStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsAfNum,
-			vfe31_ctrl->afStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->afStatsControl.bufToRender,
-						statsAfNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->af_ack_lock, flags);
-		vfe31_ctrl->afStatsControl.droppedStatsFrameCount++;
-	}
-
-}
-
-static void vfe31_process_stats_awb_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->awb_ack_lock, flags);
-	if (!vfe31_ctrl->awbStatsControl.ackPending) {
-		vfe31_ctrl->awbStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
-		vfe31_ctrl->awbStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsAwbNum,
-			vfe31_ctrl->awbStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->awbStatsControl.bufToRender,
-						statsAwbNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->awb_ack_lock, flags);
-		vfe31_ctrl->awbStatsControl.droppedStatsFrameCount++;
-	}
-
-}
-
-static void vfe31_process_stats_ihist_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->ihist_ack_lock, flags);
-	if (!vfe31_ctrl->ihistStatsControl.ackPending) {
-		vfe31_ctrl->ihistStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->ihist_ack_lock, flags);
-		vfe31_ctrl->ihistStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsIhistNum,
-			vfe31_ctrl->ihistStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->ihistStatsControl.bufToRender,
-						statsIhistNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->ihist_ack_lock, flags);
-		vfe31_ctrl->ihistStatsControl.droppedStatsFrameCount++;
-	}
-}
-
-
-static void vfe31_process_stats_rs_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->rs_ack_lock, flags);
-	if (!vfe31_ctrl->rsStatsControl.ackPending) {
-		vfe31_ctrl->rsStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->rs_ack_lock, flags);
-		vfe31_ctrl->rsStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsRsNum,
-			vfe31_ctrl->rsStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->rsStatsControl.bufToRender,
-						statsRsNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->rs_ack_lock, flags);
-		vfe31_ctrl->rsStatsControl.droppedStatsFrameCount++;
-	}
-}
-
-static void vfe31_process_stats_cs_irq(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vfe31_ctrl->cs_ack_lock, flags);
-	if (!vfe31_ctrl->csStatsControl.ackPending) {
-		vfe31_ctrl->csStatsControl.ackPending = TRUE;
-		spin_unlock_irqrestore(&vfe31_ctrl->cs_ack_lock, flags);
-		vfe31_ctrl->csStatsControl.bufToRender =
-			vfe31_process_stats_irq_common(statsCsNum,
-			vfe31_ctrl->csStatsControl.nextFrameAddrBuf);
-
-		vfe_send_stats_msg(vfe31_ctrl->csStatsControl.bufToRender,
-						statsCsNum);
-	} else {
-		spin_unlock_irqrestore(&vfe31_ctrl->cs_ack_lock, flags);
-		vfe31_ctrl->csStatsControl.droppedStatsFrameCount++;
-	}
-}
-
-static void vfe31_do_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct vfe31_isr_queue_cmd *qcmd = NULL;
-
-	CDBG("=== vfe31_do_tasklet start ===\n");
-
-	spin_lock_irqsave(&vfe31_ctrl->tasklet_lock, flags);
-	qcmd = list_first_entry(&vfe31_ctrl->tasklet_q,
-		struct vfe31_isr_queue_cmd, list);
-
-	if (!qcmd) {
-		spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock, flags);
-		return;
-	}
-
-	list_del(&qcmd->list);
-	spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock, flags);
-
-	/* interrupt to be processed,  *qcmd has the payload.  */
-	if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_REG_UPDATE_MASK) {
-		CDBG("irq regUpdateIrq\n");
-		vfe31_process_reg_update_irq();
-	}
-
-	if (qcmd->vfeInterruptStatus1 & VFE_IMASK_WHILE_STOPPING_1) {
-		CDBG("irq resetAckIrq\n");
-		vfe31_process_reset_irq();
-	}
-
-	spin_lock_irqsave(&vfe31_ctrl->state_lock, flags);
-	if (vfe31_ctrl->vstate == VFE_STATE_ACTIVE) {
-		/* irqs below are only valid when in active state. */
-		spin_unlock_irqrestore(&vfe31_ctrl->state_lock, flags);
-		/* next, check output path related interrupts. */
-		if (qcmd->vfeInterruptStatus0 &
-			VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE0_MASK) {
-			vfe31_process_output_path_irq_0();
-		}
-		if (qcmd->vfeInterruptStatus0 &
-			VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE1_MASK) {
-			vfe31_process_output_path_irq_1();
-		}
-		if (qcmd->vfeInterruptStatus0 &
-			VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE2_MASK) {
-			vfe31_process_output_path_irq_2();
-		}
-		/* in snapshot mode if done then send snapshot done message */
-		if (vfe31_ctrl->operation_mode & 1) {
-			if ((vfe31_ctrl->outpath.out0.capture_cnt == 0) &&
-				(vfe31_ctrl->outpath.out1.capture_cnt == 0)) {
-				vfe31_send_msg_no_payload(MSG_ID_SNAPSHOT_DONE);
-				vfe_io_w(CAMIF_COMMAND_STOP_IMMEDIATELY, VFE_CAMIF_COMMAND);
-			}
-		}
-		/* then process stats irq. */
-		if (vfe31_ctrl->stats_comp) {
-			/* process stats comb interrupt. */
-			if (qcmd->vfeInterruptStatus0 &
-				VFE_IRQ_STATUS0_STATS_COMPOSIT_MASK) {
-				CDBG("Stats composite irq occured.\n");
-				vfe31_process_stats_comb_irq(
-					&qcmd->vfeInterruptStatus0);
-			}
-		} else {
-			/* process individual stats interrupt. */
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_AEC) {
-				CDBG("Stats AEC irq occured.\n");
-				vfe31_process_stats_ae_irq();
-			}
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_AWB) {
-				CDBG("Stats AWB irq occured.\n");
-				vfe31_process_stats_awb_irq();
-			}
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_AF) {
-				CDBG("Stats AF irq occured.\n");
-				vfe31_process_stats_af_irq();
-			}
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_IHIST) {
-				CDBG("Stats IHIST irq occured.\n");
-				vfe31_process_stats_ihist_irq();
-			}
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_RS) {
-				CDBG("Stats RS irq occured.\n");
-				vfe31_process_stats_rs_irq();
-			}
-			if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_STATS_CS) {
-				CDBG("Stats CS irq occured.\n");
-				vfe31_process_stats_cs_irq();
-			}
-		}
-	} else {
-		/* do we really need spin lock for state? */
-		spin_unlock_irqrestore(&vfe31_ctrl->state_lock, flags);
-	}
-	if (qcmd->vfeInterruptStatus0 & VFE_IRQ_STATUS0_CAMIF_SOF_MASK) {
-		vfe31_process_camif_sof_irq();
-	}
-	kfree(qcmd);
-	CDBG("=== vfe31_do_tasklet end ===\n");
-}
-
-DECLARE_TASKLET(vfe31_tasklet, vfe31_do_tasklet, 0);
-
-static irqreturn_t vfe31_parse_irq(int irq_num, void *data)
-{
-	unsigned long flags;
-	struct vfe31_irq_status irq;
-	struct vfe31_isr_queue_cmd *qcmd;
-
-	CDBG("vfe_parse_irq\n");
-	vfe31_read_irq_status(&irq);
-
-	if ((irq.vfeIrqStatus0 == 0) && (irq.vfeIrqStatus1 == 0)) {
-		CDBG("vfe_parse_irq: vfeIrqStatus0 & 1 are both 0!\n");
-		return IRQ_HANDLED;
-	}
-
-	qcmd = kzalloc(sizeof(struct vfe31_isr_queue_cmd), GFP_ATOMIC);
-	if (!qcmd) {
-		pr_err("vfe_parse_irq: qcmd malloc failed!\n");
-		return IRQ_HANDLED;
-	}
-
-	spin_lock_irqsave(&vfe31_ctrl->stop_flag_lock, flags);
-	if (vfe31_ctrl->stop_ack_pending) {
-		irq.vfeIrqStatus0 &= VFE_IMASK_WHILE_STOPPING_0;
-		irq.vfeIrqStatus1 &= VFE_IMASK_WHILE_STOPPING_1;
-	}
-	spin_unlock_irqrestore(&vfe31_ctrl->stop_flag_lock, flags);
-
-	CDBG("vfe_parse_irq: Irq_status0 = 0x%x, Irq_status1 = 0x%x.\n",
-		irq.vfeIrqStatus0, irq.vfeIrqStatus1);
-
-	qcmd->vfeInterruptStatus0 = irq.vfeIrqStatus0;
-	qcmd->vfeInterruptStatus1 = irq.vfeIrqStatus1;
-
-	spin_lock_irqsave(&vfe31_ctrl->tasklet_lock, flags);
-	list_add_tail(&qcmd->list, &vfe31_ctrl->tasklet_q);
-	spin_unlock_irqrestore(&vfe31_ctrl->tasklet_lock, flags);
-	tasklet_schedule(&vfe31_tasklet);
-
-	/* clear the pending interrupt of the same kind.*/
-	vfe_io_w(irq.vfeIrqStatus0, VFE_IRQ_CLEAR_0);
-	vfe_io_w(irq.vfeIrqStatus1, VFE_IRQ_CLEAR_1);
-
-	vfe_io_w(1, VFE_IRQ_CMD);
-
-	return IRQ_HANDLED;
-}
-
-static int vfe31_resource_init(struct msm_vfe_callback *presp,
-	struct platform_device *pdev, void *sdata)
-{
-	struct resource	*vfemem, *vfeirq, *vfeio;
-	int rc;
-	struct msm_camera_sensor_info *s_info;
-	s_info = pdev->dev.platform_data;
-
-	pdev->resource = s_info->resource;
-	pdev->num_resources = s_info->num_resources;
-
-	vfemem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!vfemem) {
-		pr_err("%s: no mem resource?\n", __func__);
-		return -ENODEV;
-	}
-
-	vfeirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!vfeirq) {
-		pr_err("%s: no irq resource?\n", __func__);
-		return -ENODEV;
-	}
-
-	vfeio = request_mem_region(vfemem->start,
-		resource_size(vfemem), pdev->name);
-	if (!vfeio) {
-		pr_err("%s: VFE region already claimed\n", __func__);
-		return -EBUSY;
-	}
-
-	vfe31_ctrl = kzalloc(sizeof(struct vfe31_ctrl_type), GFP_KERNEL);
-	if (!vfe31_ctrl) {
-		rc = -ENOMEM;
-		goto cmd_init_failed1;
-	}
-
-	vfe31_ctrl->vfeirq = vfeirq->start;
-
-	vfe31_ctrl->vfebase =
-		ioremap(vfemem->start, (vfemem->end - vfemem->start) + 1);
-	if (!vfe31_ctrl->vfebase) {
-		rc = -ENOMEM;
-		pr_err("%s: vfe ioremap failed\n", __func__);
-		goto cmd_init_failed2;
-	}
-
-	rc = request_irq(vfe31_ctrl->vfeirq, vfe31_parse_irq,
-		IRQF_TRIGGER_RISING, "vfe", 0);
-	if (rc < 0)
-		goto cmd_init_failed2;
-
-	if (presp && presp->vfe_resp)
-		vfe31_ctrl->resp = presp;
-	else {
-		rc = -EINVAL;
-		goto cmd_init_failed3;
-	}
-
-	vfe31_ctrl->extdata = kmalloc(sizeof(struct vfe31_frame_extra),
-				      GFP_KERNEL);
-	if (!vfe31_ctrl->extdata) {
-		rc = -ENOMEM;
-		goto cmd_init_failed3;
-	}
-
-	vfe31_ctrl->extlen = sizeof(struct vfe31_frame_extra);
-
-	spin_lock_init(&vfe31_ctrl->stop_flag_lock);
-	spin_lock_init(&vfe31_ctrl->state_lock);
-	spin_lock_init(&vfe31_ctrl->update_ack_lock);
-	spin_lock_init(&vfe31_ctrl->tasklet_lock);
-
-	spin_lock_init(&vfe31_ctrl->aec_ack_lock);
-	spin_lock_init(&vfe31_ctrl->awb_ack_lock);
-	spin_lock_init(&vfe31_ctrl->af_ack_lock);
-	spin_lock_init(&vfe31_ctrl->ihist_ack_lock);
-	spin_lock_init(&vfe31_ctrl->rs_ack_lock);
-	spin_lock_init(&vfe31_ctrl->cs_ack_lock);
-	INIT_LIST_HEAD(&vfe31_ctrl->tasklet_q);
-
-	vfe31_ctrl->syncdata = sdata;
-	vfe31_ctrl->vfemem = vfemem;
-	vfe31_ctrl->vfeio = vfeio;
-	return 0;
-
-cmd_init_failed3:
-	free_irq(vfe31_ctrl->vfeirq, 0);
-	iounmap(vfe31_ctrl->vfebase);
-cmd_init_failed2:
-	kfree(vfe31_ctrl);
-cmd_init_failed1:
-	release_mem_region(vfemem->start, (vfemem->end - vfemem->start) + 1);
-	return rc;
-}
-
-static int vfe31_init(struct msm_vfe_callback *presp,
-	struct platform_device *dev)
-{
-	int rc = 0;
-	rc = vfe31_resource_init(presp, dev, vfe_syncdata);
-	if (rc < 0)
-		return rc;
-
-	/* Bring up all the required GPIOs and Clocks */
-	rc = msm_camio_enable(dev);
-	return rc;
-}
-
-void msm_camvfe_fn_init(struct msm_camvfe_fn *fptr, void *data)
-{
-	fptr->vfe_init    = vfe31_init;
-	fptr->vfe_enable  = vfe31_enable;
-	fptr->vfe_config  = vfe31_config;
-	fptr->vfe_disable = vfe31_disable;
-	fptr->vfe_release = vfe31_release;
-	vfe_syncdata = data;
-}
diff --git a/drivers/media/video/msm/msm_vfe31.h b/drivers/media/video/msm/msm_vfe31.h
deleted file mode 100644
index 2a12ac4..0000000
--- a/drivers/media/video/msm/msm_vfe31.h
+++ /dev/null
@@ -1,1052 +0,0 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MSM_VFE31_H__
-#define __MSM_VFE31_H__
-
-#define TRUE  1
-#define FALSE 0
-
-/* at start of camif,  bit 1:0 = 0x01:enable
- * image data capture at frame boundary. */
-#define CAMIF_COMMAND_START  0x00000005
-
-/* bit 2= 0x1:clear the CAMIF_STATUS register
- * value. */
-#define CAMIF_COMMAND_CLEAR  0x00000004
-
-/* at stop of vfe pipeline, for now it is assumed
- * that camif will stop at any time. Bit 1:0 = 0x10:
- * disable image data capture immediately. */
-#define CAMIF_COMMAND_STOP_IMMEDIATELY  0x00000002
-
-/* at stop of vfe pipeline, for now it is assumed
- * that camif will stop at any time. Bit 1:0 = 0x00:
- * disable image data capture at frame boundary */
-#define CAMIF_COMMAND_STOP_AT_FRAME_BOUNDARY  0x00000000
-
-/* to halt axi bridge */
-#define AXI_HALT  0x00000001
-
-/* clear the halt bit. */
-#define AXI_HALT_CLEAR  0x00000000
-
-/* reset the pipeline when stop command is issued.
- * (without reset the register.) bit 26-31 = 0,
- * domain reset, bit 0-9 = 1 for module reset, except
- * register module. */
-#define VFE_RESET_UPON_STOP_CMD  0x000003ef
-
-/* reset the pipeline when reset command.
- * bit 26-31 = 0, domain reset, bit 0-9 = 1 for module reset. */
-#define VFE_RESET_UPON_RESET_CMD  0x000003ff
-
-/* bit 5 is for axi status idle or busy.
- * 1 =  halted,  0 = busy */
-#define AXI_STATUS_BUSY_MASK 0x00000020
-
-/* bit 0 & bit 1 = 1, both y and cbcr irqs need to be present
- * for frame done interrupt */
-#define VFE_COMP_IRQ_BOTH_Y_CBCR 3
-
-/* bit 1 = 1, only cbcr irq triggers frame done interrupt */
-#define VFE_COMP_IRQ_CBCR_ONLY 2
-
-/* bit 0 = 1, only y irq triggers frame done interrupt */
-#define VFE_COMP_IRQ_Y_ONLY 1
-
-/* bit 0 = 1, PM go;   bit1 = 1, PM stop */
-#define VFE_PERFORMANCE_MONITOR_GO   0x00000001
-#define VFE_PERFORMANCE_MONITOR_STOP 0x00000002
-
-/* bit 0 = 1, test gen go;   bit1 = 1, test gen stop */
-#define VFE_TEST_GEN_GO   0x00000001
-#define VFE_TEST_GEN_STOP 0x00000002
-
-/* the chroma is assumed to be interpolated between
- * the luma samples.  JPEG 4:2:2 */
-#define VFE_CHROMA_UPSAMPLE_INTERPOLATED 0
-
-/* constants for irq registers */
-#define VFE_DISABLE_ALL_IRQS 0
-/* bit =1 is to clear the corresponding bit in VFE_IRQ_STATUS.  */
-#define VFE_CLEAR_ALL_IRQS   0xffffffff
-
-#define VFE_IRQ_STATUS0_CAMIF_SOF_MASK            0x00000001
-#define VFE_IRQ_STATUS0_REG_UPDATE_MASK           0x00000020
-#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE0_MASK 0x00200000
-#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE1_MASK 0x00400000
-#define VFE_IRQ_STATUS0_IMAGE_COMPOSIT_DONE2_MASK 0x00800000
-#define VFE_IRQ_STATUS1_RESET_AXI_HALT_ACK_MASK   0x00800000
-#define VFE_IRQ_STATUS0_STATS_COMPOSIT_MASK       0x01000000
-
-#define VFE_IRQ_STATUS0_STATS_AEC     0x2000  /* bit 13 */
-#define VFE_IRQ_STATUS0_STATS_AF      0x4000  /* bit 14 */
-#define VFE_IRQ_STATUS0_STATS_AWB     0x8000  /* bit 15 */
-#define VFE_IRQ_STATUS0_STATS_RS      0x10000  /* bit 16 */
-#define VFE_IRQ_STATUS0_STATS_CS      0x20000  /* bit 17 */
-#define VFE_IRQ_STATUS0_STATS_IHIST   0x40000  /* bit 18 */
-
-/* imask for while waiting for stop ack,  driver has already
- * requested stop, waiting for reset irq, and async timer irq.
- * For irq_status_0, bit 28-31 are for async timer. For
- * irq_status_1, bit 22 for reset irq, bit 23 for axi_halt_ack
-   irq */
-#define VFE_IMASK_WHILE_STOPPING_0  0xF0000000
-#define VFE_IMASK_WHILE_STOPPING_1  0x00400000
-
-/* no error irq in mask 0 */
-#define VFE_IMASK_ERROR_ONLY_0  0x0
-/* when normal case, don't want to block error status. */
-/* bit 0-21 are error irq bits */
-#define VFE_IMASK_ERROR_ONLY_1  0x003fffff
-
-/* For BPC bit 0,bit 12-17 and bit 26 -20 are set to zero and other's 1 */
-#define BPC_MASK 0xF80C0FFE
-
-/* For BPC bit 1 and 2 are set to zero and other's 1 */
-#define ABF_MASK 0xFFFFFFF9
-
-/* For MCE enable bit 28 set to zero and other's 1 */
-#define MCE_EN_MASK 0xEFFFFFFF
-
-/* For MCE Q_K bit 28 to 31 set to zero and other's 1 */
-#define MCE_Q_K_MASK 0x0FFFFFFF
-
-#define AWB_ENABLE_MASK 0x00000080     /* bit 7 */
-#define AF_ENABLE_MASK 0x00000040      /* bit 6 */
-#define AE_ENABLE_MASK 0x00000020      /* bit 5 */
-#define IHIST_ENABLE_MASK 0x00008000   /* bit 15 */
-#define RS_ENABLE_MASK 0x00000100      /* bit 8  */
-#define CS_ENABLE_MASK 0x00000200      /* bit 9  */
-
-
-#define VFE_REG_UPDATE_TRIGGER           1
-#define VFE_PM_BUF_MAX_CNT_MASK          0xFF
-#define VFE_DMI_CFG_DEFAULT              0x00000100
-#define LENS_ROLL_OFF_DELTA_TABLE_OFFSET 32
-#define VFE_AE_PINGPONG_STATUS_BIT       0x80
-#define VFE_AF_PINGPONG_STATUS_BIT       0x100
-#define VFE_AWB_PINGPONG_STATUS_BIT      0x200
-
-
-enum VFE31_DMI_RAM_SEL {
-	 NO_MEM_SELECTED          = 0,
-	 ROLLOFF_RAM              = 0x1,
-	 RGBLUT_RAM_CH0_BANK0     = 0x2,
-	 RGBLUT_RAM_CH0_BANK1     = 0x3,
-	 RGBLUT_RAM_CH1_BANK0     = 0x4,
-	 RGBLUT_RAM_CH1_BANK1     = 0x5,
-	 RGBLUT_RAM_CH2_BANK0     = 0x6,
-	 RGBLUT_RAM_CH2_BANK1     = 0x7,
-	 STATS_HIST_CB_EVEN_RAM   = 0x8,
-	 STATS_HIST_CB_ODD_RAM    = 0x9,
-	 STATS_HIST_CR_EVEN_RAM   = 0xa,
-	 STATS_HIST_CR_ODD_RAM    = 0xb,
-	 RGBLUT_CHX_BANK0         = 0xc,
-	 RGBLUT_CHX_BANK1         = 0xd,
-	 LUMA_ADAPT_LUT_RAM_BANK0 = 0xe,
-	 LUMA_ADAPT_LUT_RAM_BANK1 = 0xf
-
-};
-
-enum  VFE_STATE {
-	VFE_STATE_IDLE,
-	VFE_STATE_ACTIVE
-};
-
-#define V31_DUMMY_0               0
-#define V31_SET_CLK               1
-#define V31_RESET                 2
-#define V31_START                 3
-#define V31_TEST_GEN_START        4
-#define V31_OPERATION_CFG         5
-#define V31_AXI_OUT_CFG           6
-#define V31_CAMIF_CFG             7
-#define V31_AXI_INPUT_CFG         8
-#define V31_BLACK_LEVEL_CFG       9
-#define V31_ROLL_OFF_CFG          10
-#define V31_DEMUX_CFG             11
-#define V31_DEMOSAIC_0_CFG        12 /* general */
-#define V31_DEMOSAIC_1_CFG        13 /* ABF     */
-#define V31_DEMOSAIC_2_CFG        14 /* BPC     */
-#define V31_FOV_CFG               15
-#define V31_MAIN_SCALER_CFG       16
-#define V31_WB_CFG                17
-#define V31_COLOR_COR_CFG         18
-#define V31_RGB_G_CFG             19
-#define V31_LA_CFG                20
-#define V31_CHROMA_EN_CFG         21
-#define V31_CHROMA_SUP_CFG        22
-#define V31_MCE_CFG               23
-#define V31_SK_ENHAN_CFG          24
-#define V31_ASF_CFG               25
-#define V31_S2Y_CFG               26
-#define V31_S2CbCr_CFG            27
-#define V31_CHROMA_SUBS_CFG       28
-#define V31_OUT_CLAMP_CFG         29
-#define V31_FRAME_SKIP_CFG        30
-#define V31_DUMMY_1               31
-#define V31_DUMMY_2               32
-#define V31_DUMMY_3               33
-#define V31_UPDATE                34
-#define V31_BL_LVL_UPDATE         35
-#define V31_DEMUX_UPDATE          36
-#define V31_DEMOSAIC_1_UPDATE     37 /* BPC */
-#define V31_DEMOSAIC_2_UPDATE     38 /* ABF */
-#define V31_FOV_UPDATE            39
-#define V31_MAIN_SCALER_UPDATE    40
-#define V31_WB_UPDATE             41
-#define V31_COLOR_COR_UPDATE      42
-#define V31_RGB_G_UPDATE          43
-#define V31_LA_UPDATE             44
-#define V31_CHROMA_EN_UPDATE      45
-#define V31_CHROMA_SUP_UPDATE     46
-#define V31_MCE_UPDATE            47
-#define V31_SK_ENHAN_UPDATE       48
-#define V31_S2CbCr_UPDATE         49
-#define V31_S2Y_UPDATE            50
-#define V31_ASF_UPDATE            51
-#define V31_FRAME_SKIP_UPDATE     52
-#define V31_CAMIF_FRAME_UPDATE    53
-#define V31_STATS_AF_UPDATE       54
-#define V31_STATS_AE_UPDATE       55
-#define V31_STATS_AWB_UPDATE      56
-#define V31_STATS_RS_UPDATE       57
-#define V31_STATS_CS_UPDATE       58
-#define V31_STATS_SKIN_UPDATE     59
-#define V31_STATS_IHIST_UPDATE    60
-#define V31_DUMMY_4               61
-#define V31_EPOCH1_ACK            62
-#define V31_EPOCH2_ACK            63
-#define V31_START_RECORDING       64
-#define V31_STOP_RECORDING        65
-#define V31_DUMMY_5               66
-#define V31_DUMMY_6               67
-#define V31_CAPTURE               68
-#define V31_DUMMY_7               69
-#define V31_STOP                  70
-#define V31_GET_HW_VERSION        71
-#define V31_GET_FRAME_SKIP_COUNTS 72
-#define V31_OUTPUT1_BUFFER_ENQ    73
-#define V31_OUTPUT2_BUFFER_ENQ    74
-#define V31_OUTPUT3_BUFFER_ENQ    75
-#define V31_JPEG_OUT_BUF_ENQ      76
-#define V31_RAW_OUT_BUF_ENQ       77
-#define V31_RAW_IN_BUF_ENQ        78
-#define V31_STATS_AF_ENQ          79
-#define V31_STATS_AE_ENQ          80
-#define V31_STATS_AWB_ENQ         81
-#define V31_STATS_RS_ENQ          82
-#define V31_STATS_CS_ENQ          83
-#define V31_STATS_SKIN_ENQ        84
-#define V31_STATS_IHIST_ENQ       85
-#define V31_DUMMY_8               86
-#define V31_JPEG_ENC_CFG          87
-#define V31_DUMMY_9               88
-#define V31_STATS_AF_START        89
-#define V31_STATS_AF_STOP         90
-#define V31_STATS_AE_START        91
-#define V31_STATS_AE_STOP         92
-#define V31_STATS_AWB_START       93
-#define V31_STATS_AWB_STOP        94
-#define V31_STATS_RS_START        95
-#define V31_STATS_RS_STOP         96
-#define V31_STATS_CS_START        97
-#define V31_STATS_CS_STOP         98
-#define V31_STATS_SKIN_START      99
-#define V31_STATS_SKIN_STOP       100
-#define V31_STATS_IHIST_START     101
-#define V31_STATS_IHIST_STOP      102
-#define V31_DUMMY_10              103
-#define V31_SYNC_TIMER_SETTING    104
-#define V31_ASYNC_TIMER_SETTING   105
-#define V31_CAMIF_OFF             0x000001E4
-#define V31_CAMIF_LEN             32
-
-#define V31_DEMUX_OFF             0x00000284
-#define V31_DEMUX_LEN             20
-
-#define V31_DEMOSAIC_0_OFF        0x00000298
-#define V31_DEMOSAIC_0_LEN        4
-/* ABF     */
-#define V31_DEMOSAIC_1_OFF        0x000002A4
-#define V31_DEMOSAIC_1_LEN        180
-/* BPC     */
-#define V31_DEMOSAIC_2_OFF        0x0000029C
-#define V31_DEMOSAIC_2_LEN        8
-
-#define V31_OUT_CLAMP_OFF         0x00000524
-#define V31_OUT_CLAMP_LEN         8
-
-#define V31_OPERATION_CFG_LEN     28
-
-#define V31_AXI_OUT_OFF           0x00000038
-#define V31_AXI_OUT_LEN           188
-
-#define V31_FRAME_SKIP_OFF        0x00000504
-#define V31_FRAME_SKIP_LEN        32
-
-#define V31_CHROMA_SUBS_OFF       0x000004F8
-#define V31_CHROMA_SUBS_LEN       12
-
-#define V31_FOV_OFF           0x00000360
-#define V31_FOV_LEN           8
-
-#define V31_MAIN_SCALER_OFF 0x00000368
-#define V31_MAIN_SCALER_LEN 28
-
-#define V31_S2Y_OFF 0x000004D0
-#define V31_S2Y_LEN 20
-
-#define V31_S2CbCr_OFF 0x000004E4
-#define V31_S2CbCr_LEN 20
-
-#define V31_CHROMA_EN_OFF 0x000003C4
-#define V31_CHROMA_EN_LEN 36
-
-#define V31_BLACK_LEVEL_OFF 0x00000264
-#define V31_BLACK_LEVEL_LEN 16
-
-#define V31_ROLL_OFF_CFG_OFF 0x00000274
-#define V31_ROLL_OFF_CFG_LEN 16
-
-#define V31_COLOR_COR_OFF 0x00000388
-#define V31_COLOR_COR_LEN 52
-
-#define V31_WB_OFF 0x00000384
-#define V31_WB_LEN 4
-
-#define V31_RGB_G_OFF 0x000003BC
-#define V31_RGB_G_LEN 4
-
-#define V31_LA_OFF 0x000003C0
-#define V31_LA_LEN 4
-
-#define V31_CHROMA_SUP_OFF 0x000003E8
-#define V31_CHROMA_SUP_LEN 12
-
-#define V31_MCE_OFF 0x000003E8
-#define V31_MCE_LEN 36
-#define V31_STATS_AF_OFF 0x0000053c
-#define V31_STATS_AF_LEN 16
-
-#define V31_STATS_AE_OFF 0x00000534
-#define V31_STATS_AE_LEN 8
-
-#define V31_STATS_AWB_OFF 0x0000054c
-#define V31_STATS_AWB_LEN 32
-
-#define V31_STATS_IHIST_OFF 0x0000057c
-#define V31_STATS_IHIST_LEN 8
-
-#define V31_STATS_RS_OFF 0x0000056c
-#define V31_STATS_RS_LEN 8
-
-#define V31_STATS_CS_OFF 0x00000574
-#define V31_STATS_CS_LEN 8
-
-
-#define V31_ASF_OFF 0x000004A0
-#define V31_ASF_LEN 48
-#define V31_ASF_UPDATE_LEN 36
-
-#define V31_CAPTURE_LEN 4
-
-struct vfe_cmd_hw_version {
-	uint32_t minorVersion;
-	uint32_t majorVersion;
-	uint32_t coreVersion;
-};
-
-enum VFE_AXI_OUTPUT_MODE {
-	VFE_AXI_OUTPUT_MODE_Output1,
-	VFE_AXI_OUTPUT_MODE_Output2,
-	VFE_AXI_OUTPUT_MODE_Output1AndOutput2,
-	VFE_AXI_OUTPUT_MODE_CAMIFToAXIViaOutput2,
-	VFE_AXI_OUTPUT_MODE_Output2AndCAMIFToAXIViaOutput1,
-	VFE_AXI_OUTPUT_MODE_Output1AndCAMIFToAXIViaOutput2,
-	VFE_AXI_LAST_OUTPUT_MODE_ENUM
-};
-
-enum VFE_RAW_WR_PATH_SEL {
-	VFE_RAW_OUTPUT_DISABLED,
-	VFE_RAW_OUTPUT_ENC_CBCR_PATH,
-	VFE_RAW_OUTPUT_VIEW_CBCR_PATH,
-	VFE_RAW_OUTPUT_PATH_INVALID
-};
-
-
-#define VFE_AXI_OUTPUT_BURST_LENGTH     4
-#define VFE_MAX_NUM_FRAGMENTS_PER_FRAME 4
-#define VFE_AXI_OUTPUT_CFG_FRAME_COUNT  3
-
-struct vfe_cmds_per_write_master {
-	uint16_t imageWidth;
-	uint16_t imageHeight;
-	uint16_t outRowCount;
-	uint16_t outRowIncrement;
-	uint32_t outFragments[VFE_AXI_OUTPUT_CFG_FRAME_COUNT]
-		[VFE_MAX_NUM_FRAGMENTS_PER_FRAME];
-};
-
-struct vfe_cmds_axi_per_output_path {
-	uint8_t fragmentCount;
-	struct vfe_cmds_per_write_master firstWM;
-	struct vfe_cmds_per_write_master secondWM;
-};
-
-enum VFE_AXI_BURST_LENGTH {
-	VFE_AXI_BURST_LENGTH_IS_2  = 2,
-	VFE_AXI_BURST_LENGTH_IS_4  = 4,
-	VFE_AXI_BURST_LENGTH_IS_8  = 8,
-	VFE_AXI_BURST_LENGTH_IS_16 = 16
-};
-
-
-struct vfe_cmd_fov_crop_config {
-	uint8_t enable;
-	uint16_t firstPixel;
-	uint16_t lastPixel;
-	uint16_t firstLine;
-	uint16_t lastLine;
-};
-
-struct vfe_cmds_main_scaler_stripe_init {
-	uint16_t MNCounterInit;
-	uint16_t phaseInit;
-};
-
-struct vfe_cmds_scaler_one_dimension {
-	uint8_t  enable;
-	uint16_t inputSize;
-	uint16_t outputSize;
-	uint32_t phaseMultiplicationFactor;
-	uint8_t  interpolationResolution;
-};
-
-struct vfe_cmd_main_scaler_config {
-	uint8_t enable;
-	struct vfe_cmds_scaler_one_dimension    hconfig;
-	struct vfe_cmds_scaler_one_dimension    vconfig;
-	struct vfe_cmds_main_scaler_stripe_init MNInitH;
-	struct vfe_cmds_main_scaler_stripe_init MNInitV;
-};
-
-struct vfe_cmd_scaler2_config {
-	uint8_t enable;
-	struct vfe_cmds_scaler_one_dimension hconfig;
-	struct vfe_cmds_scaler_one_dimension vconfig;
-};
-
-
-struct vfe_cmd_frame_skip_update {
-	uint32_t output1Pattern;
-	uint32_t output2Pattern;
-};
-
-struct vfe_cmd_output_clamp_config {
-	uint8_t minCh0;
-	uint8_t minCh1;
-	uint8_t minCh2;
-	uint8_t maxCh0;
-	uint8_t maxCh1;
-	uint8_t maxCh2;
-};
-
-struct vfe_cmd_chroma_subsample_config {
-	uint8_t enable;
-	uint8_t cropEnable;
-	uint8_t vsubSampleEnable;
-	uint8_t hsubSampleEnable;
-	uint8_t vCosited;
-	uint8_t hCosited;
-	uint8_t vCositedPhase;
-	uint8_t hCositedPhase;
-	uint16_t cropWidthFirstPixel;
-	uint16_t cropWidthLastPixel;
-	uint16_t cropHeightFirstLine;
-	uint16_t cropHeightLastLine;
-};
-
-enum VFE_START_INPUT_SOURCE {
-	VFE_START_INPUT_SOURCE_CAMIF,
-	VFE_START_INPUT_SOURCE_TESTGEN,
-	VFE_START_INPUT_SOURCE_AXI,
-	VFE_START_INPUT_SOURCE_INVALID
-};
-
-enum VFE_START_OPERATION_MODE {
-	VFE_START_OPERATION_MODE_CONTINUOUS,
-	VFE_START_OPERATION_MODE_SNAPSHOT
-};
-
-enum VFE_START_PIXEL_PATTERN {
-	VFE_BAYER_RGRGRG,
-	VFE_BAYER_GRGRGR,
-	VFE_BAYER_BGBGBG,
-	VFE_BAYER_GBGBGB,
-	VFE_YUV_YCbYCr,
-	VFE_YUV_YCrYCb,
-	VFE_YUV_CbYCrY,
-	VFE_YUV_CrYCbY
-};
-
-enum VFE_BUS_RD_INPUT_PIXEL_PATTERN {
-	VFE_BAYER_RAW,
-	VFE_YUV_INTERLEAVED,
-	VFE_YUV_PSEUDO_PLANAR_Y,
-	VFE_YUV_PSEUDO_PLANAR_CBCR
-};
-
-enum VFE_YUV_INPUT_COSITING_MODE {
-	VFE_YUV_COSITED,
-	VFE_YUV_INTERPOLATED
-};
-
-
-/* 13*1  */
-#define VFE31_ROLL_OFF_INIT_TABLE_SIZE  13
-/* 13*16 */
-#define VFE31_ROLL_OFF_DELTA_TABLE_SIZE 208
-
-#define VFE31_GAMMA_NUM_ENTRIES  64
-
-#define VFE31_LA_TABLE_LENGTH    64
-
-struct vfe_cmds_demosaic_abf {
-	uint8_t   enable;
-	uint8_t   forceOn;
-	uint8_t   shift;
-	uint16_t  lpThreshold;
-	uint16_t  max;
-	uint16_t  min;
-	uint8_t   ratio;
-};
-
-struct vfe_cmds_demosaic_bpc {
-	uint8_t   enable;
-	uint16_t  fmaxThreshold;
-	uint16_t  fminThreshold;
-	uint16_t  redDiffThreshold;
-	uint16_t  blueDiffThreshold;
-	uint16_t  greenDiffThreshold;
-};
-
-struct vfe_cmd_demosaic_config {
-	uint8_t   enable;
-	uint8_t   slopeShift;
-	struct vfe_cmds_demosaic_abf abfConfig;
-	struct vfe_cmds_demosaic_bpc bpcConfig;
-};
-
-struct vfe_cmd_demosaic_bpc_update {
-	struct vfe_cmds_demosaic_bpc bpcUpdate;
-};
-
-struct vfe_cmd_demosaic_abf_update {
-	struct vfe_cmds_demosaic_abf abfUpdate;
-};
-
-struct vfe_cmd_white_balance_config {
-	uint8_t  enable;
-	uint16_t ch2Gain;
-	uint16_t ch1Gain;
-	uint16_t ch0Gain;
-};
-
-enum VFE_COLOR_CORRECTION_COEF_QFACTOR {
-	COEF_IS_Q7_SIGNED,
-	COEF_IS_Q8_SIGNED,
-	COEF_IS_Q9_SIGNED,
-	COEF_IS_Q10_SIGNED
-};
-
-struct vfe_cmd_color_correction_config {
-	uint8_t     enable;
-	enum VFE_COLOR_CORRECTION_COEF_QFACTOR coefQFactor;
-	int16_t  C0;
-	int16_t  C1;
-	int16_t  C2;
-	int16_t  C3;
-	int16_t  C4;
-	int16_t  C5;
-	int16_t  C6;
-	int16_t  C7;
-	int16_t  C8;
-	int16_t  K0;
-	int16_t  K1;
-	int16_t  K2;
-};
-
-#define VFE_LA_TABLE_LENGTH 256
-struct vfe_cmd_la_config {
-	uint8_t enable;
-	int16_t table[VFE_LA_TABLE_LENGTH];
-};
-
-#define VFE_GAMMA_TABLE_LENGTH 256
-enum VFE_RGB_GAMMA_TABLE_SELECT {
-	RGB_GAMMA_CH0_SELECTED,
-	RGB_GAMMA_CH1_SELECTED,
-	RGB_GAMMA_CH2_SELECTED,
-	RGB_GAMMA_CH0_CH1_SELECTED,
-	RGB_GAMMA_CH0_CH2_SELECTED,
-	RGB_GAMMA_CH1_CH2_SELECTED,
-	RGB_GAMMA_CH0_CH1_CH2_SELECTED
-};
-
-struct vfe_cmd_rgb_gamma_config {
-	uint8_t enable;
-	enum VFE_RGB_GAMMA_TABLE_SELECT channelSelect;
-	int16_t table[VFE_GAMMA_TABLE_LENGTH];
-};
-
-struct vfe_cmd_chroma_enhan_config {
-	uint8_t  enable;
-	int16_t am;
-	int16_t ap;
-	int16_t bm;
-	int16_t bp;
-	int16_t cm;
-	int16_t cp;
-	int16_t dm;
-	int16_t dp;
-	int16_t kcr;
-	int16_t kcb;
-	int16_t RGBtoYConversionV0;
-	int16_t RGBtoYConversionV1;
-	int16_t RGBtoYConversionV2;
-	uint8_t RGBtoYConversionOffset;
-};
-
-struct vfe_cmd_chroma_suppression_config {
-	uint8_t enable;
-	uint8_t m1;
-	uint8_t m3;
-	uint8_t n1;
-	uint8_t n3;
-	uint8_t nn1;
-	uint8_t mm1;
-};
-
-struct vfe_cmd_asf_config {
-	uint8_t enable;
-	uint8_t smoothFilterEnabled;
-	uint8_t sharpMode;
-	uint8_t smoothCoefCenter;
-	uint8_t smoothCoefSurr;
-	uint8_t normalizeFactor;
-	uint8_t sharpK1;
-	uint8_t sharpK2;
-	uint8_t sharpThreshE1;
-	int8_t sharpThreshE2;
-	int8_t sharpThreshE3;
-	int8_t sharpThreshE4;
-	int8_t sharpThreshE5;
-	int8_t filter1Coefficients[9];
-	int8_t filter2Coefficients[9];
-	uint8_t  cropEnable;
-	uint16_t cropFirstPixel;
-	uint16_t cropLastPixel;
-	uint16_t cropFirstLine;
-	uint16_t cropLastLine;
-};
-
-struct vfe_cmd_asf_update {
-	uint8_t enable;
-	uint8_t smoothFilterEnabled;
-	uint8_t sharpMode;
-	uint8_t smoothCoefCenter;
-	uint8_t smoothCoefSurr;
-	uint8_t normalizeFactor;
-	uint8_t sharpK1;
-	uint8_t sharpK2;
-	uint8_t sharpThreshE1;
-	int8_t  sharpThreshE2;
-	int8_t  sharpThreshE3;
-	int8_t  sharpThreshE4;
-	int8_t  sharpThreshE5;
-	int8_t  filter1Coefficients[9];
-	int8_t  filter2Coefficients[9];
-	uint8_t cropEnable;
-};
-
-enum VFE_TEST_GEN_SYNC_EDGE {
-	VFE_TEST_GEN_SYNC_EDGE_ActiveHigh,
-	VFE_TEST_GEN_SYNC_EDGE_ActiveLow
-};
-
-
-struct vfe_cmd_bus_pm_start {
-	uint8_t output2YWrPmEnable;
-	uint8_t output2CbcrWrPmEnable;
-	uint8_t output1YWrPmEnable;
-	uint8_t output1CbcrWrPmEnable;
-};
-
-struct vfe_cmd_sync_timer_setting {
-	uint8_t  whichSyncTimer;
-	uint8_t  operation;
-	uint8_t  polarity;
-	uint16_t repeatCount;
-	uint16_t hsyncCount;
-	uint32_t pclkCount;
-	uint32_t outputDuration;
-};
-
-struct vfe_cmd_async_timer_setting {
-	uint8_t  whichAsyncTimer;
-	uint8_t  operation;
-	uint8_t  polarity;
-	uint16_t repeatCount;
-	uint16_t inactiveCount;
-	uint32_t activeCount;
-};
-
-struct  vfe_frame_skip_counts {
-	uint32_t  totalFrameCount;
-	uint32_t  output1Count;
-	uint32_t  output2Count;
-};
-
-enum VFE_AXI_RD_UNPACK_HBI_SEL {
-	VFE_AXI_RD_HBI_32_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_64_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_128_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_256_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_512_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_1024_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_2048_CLOCK_CYCLES,
-	VFE_AXI_RD_HBI_4096_CLOCK_CYCLES
-};
-
-enum VFE31_MESSAGE_ID {
-	MSG_ID_RESET_ACK,
-	MSG_ID_START_ACK,
-	MSG_ID_STOP_ACK,
-	MSG_ID_UPDATE_ACK,
-	MSG_ID_OUTPUT_P,
-	MSG_ID_OUTPUT_T,
-	MSG_ID_OUTPUT_S,
-	MSG_ID_OUTPUT_V,
-	MSG_ID_SNAPSHOT_DONE,
-	MSG_ID_STATS_AEC,
-	MSG_ID_STATS_AF,
-	MSG_ID_STATS_AWB, /* 8 */
-	MSG_ID_STATS_RS,
-	MSG_ID_STATS_CS,
-	MSG_ID_STATS_IHIST,
-	MSG_ID_STATS_SKIN,
-	MSG_ID_EPOCH1,
-	MSG_ID_EPOCH2,
-	MSG_ID_SYNC_TIMER0_DONE,
-	MSG_ID_SYNC_TIMER1_DONE,
-	MSG_ID_SYNC_TIMER2_DONE,
-	MSG_ID_ASYNC_TIMER0_DONE,
-	MSG_ID_ASYNC_TIMER1_DONE,
-	MSG_ID_ASYNC_TIMER2_DONE,
-	MSG_ID_ASYNC_TIMER3_DONE,
-	MSG_ID_AE_OVERFLOW,
-	MSG_ID_AF_OVERFLOW,
-	MSG_ID_AWB_OVERFLOW,
-	MSG_ID_RS_OVERFLOW,
-	MSG_ID_CS_OVERFLOW,
-	MSG_ID_IHIST_OVERFLOW,
-	MSG_ID_SKIN_OVERFLOW,
-	MSG_ID_AXI_ERROR,
-	MSG_ID_CAMIF_OVERFLOW,
-	MSG_ID_VIOLATION,
-	MSG_ID_CAMIF_ERROR,
-	MSG_ID_BUS_OVERFLOW,
-};
-
-struct vfe_msg_stats{
-	uint32_t    buffer;
-	uint32_t    frameCounter;
-};
-
-
-struct vfe_frame_bpc_info {
-	uint32_t greenDefectPixelCount;
-	uint32_t redBlueDefectPixelCount;
-};
-
-struct vfe_frame_asf_info {
-	uint32_t  asfMaxEdge;
-	uint32_t  asfHbiCount;
-};
-
-struct vfe_msg_camif_status {
-	uint8_t  camifState;
-	uint32_t pixelCount;
-	uint32_t lineCount;
-};
-
-
-struct vfe31_irq_status {
-	uint32_t vfeIrqStatus0;
-	uint32_t vfeIrqStatus1;
-	uint32_t camifStatus;
-	uint32_t demosaicStatus;
-	uint32_t asfMaxEdge;
-};
-
-struct vfe_msg_output {
-	uint8_t   output_id;
-	uint32_t  yBuffer;
-	uint32_t  cbcrBuffer;
-	struct vfe_frame_bpc_info bpcInfo;
-	struct vfe_frame_asf_info asfInfo;
-	uint32_t  frameCounter;
-};
-
-struct vfe_message {
-	enum VFE31_MESSAGE_ID _d;
-	union {
-		struct vfe_msg_output              msgOut;
-		struct vfe_msg_stats               msgStats;
-		struct vfe_msg_camif_status        msgCamifError;
-   } _u;
-};
-
-/* New one for 7x30 */
-struct msm_vfe31_cmd {
-	int32_t  id;
-	uint16_t length;
-	void     *value;
-};
-
-#define V31_PREVIEW_AXI_FLAG  0x00000001
-#define V31_SNAPSHOT_AXI_FLAG (0x00000001<<1)
-
-struct vfe31_cmd_type {
-	uint16_t id;
-	uint32_t length;
-	uint32_t offset;
-	uint32_t flag;
-};
-
-struct vfe31_free_buf {
-	spinlock_t f_lock;
-	uint8_t available;
-	uint32_t paddr;
-	uint32_t y_off;
-	uint32_t cbcr_off;
-};
-
-struct vfe31_output_ch {
-	struct vfe31_free_buf free_buf;
-	uint16_t output_fmt;
-	int8_t ch0;
-	int8_t ch1;
-	int8_t ch2;
-	uint32_t  capture_cnt;
-	uint32_t  frame_drop_cnt;
-};
-
-/* no error irq in mask 0 */
-#define VFE31_IMASK_ERROR_ONLY_0  0x0
-/* when normal case, don't want to block error status. */
-/* bit 0-21 are error irq bits */
-#define VFE31_IMASK_ERROR_ONLY_1  0x003fffff
-
-struct vfe31_output_path {
-	uint16_t output_mode;     /* bitmask  */
-
-	struct vfe31_output_ch out0; /* preview and thumbnail */
-	struct vfe31_output_ch out1; /* snapshot */
-	struct vfe31_output_ch out2; /* video    */
-};
-
-struct vfe31_frame_extra {
-	uint32_t greenDefectPixelCount;
-	uint32_t redBlueDefectPixelCount;
-
-	uint32_t  asfMaxEdge;
-	uint32_t  asfHbiCount;
-
-	uint32_t yWrPmStats0;
-	uint32_t yWrPmStats1;
-	uint32_t cbcrWrPmStats0;
-	uint32_t cbcrWrPmStats1;
-
-	uint32_t  frameCounter;
-};
-
-#define VFE_DISABLE_ALL_IRQS              0
-#define VFE_CLEAR_ALL_IRQS                0xffffffff
-
-#define VFE_VERSION                       0x00000000
-#define VFE_GLOBAL_RESET                  0x00000004
-#define VFE_CGC_OVERRIDE                  0x0000000C
-#define VFE_MODULE_CFG                    0x00000010
-#define VFE_CFG_OFF                       0x00000014
-#define VFE_IRQ_CMD                       0x00000018
-#define VFE_IRQ_MASK_0                    0x0000001C
-#define VFE_IRQ_MASK_1                    0x00000020
-#define VFE_IRQ_CLEAR_0                   0x00000024
-#define VFE_IRQ_CLEAR_1                   0x00000028
-#define VFE_IRQ_STATUS_0                  0x0000002C
-#define VFE_IRQ_STATUS_1                  0x00000030
-#define VFE_IRQ_COMP_MASK                 0x00000034
-#define VFE_BUS_CMD                       0x00000038
-#define VFE_AXI_OFFSET                    0x00000050
-#define VFE_BUS_STATS_PING_PONG_BASE      0x000000F4
-#define VFE_BUS_STATS_AEC_WR_PING_ADDR    0x000000F4
-#define VFE_BUS_STATS_AEC_WR_PONG_ADDR    0x000000F8
-#define VFE_BUS_STATS_AEC_UB_CFG          0x000000FC
-#define VFE_BUS_STATS_AF_WR_PING_ADDR     0x00000100
-#define VFE_BUS_STATS_AF_WR_PONG_ADDR     0x00000104
-#define VFE_BUS_STATS_AF_UB_CFG           0x00000108
-#define VFE_BUS_STATS_AWB_WR_PING_ADDR    0x0000010C
-#define VFE_BUS_STATS_AWB_WR_PONG_ADDR    0x00000110
-#define VFE_BUS_STATS_AWB_UB_CFG          0x00000114
-#define VFE_BUS_STATS_RS_WR_PING_ADDR     0x00000118
-#define VFE_BUS_STATS_RS_WR_PONG_ADDR     0x0000011C
-#define VFE_BUS_STATS_RS_UB_CFG           0x00000120
-#define VFE_BUS_STATS_CS_WR_PING_ADDR     0x00000124
-#define VFE_BUS_STATS_CS_WR_PONG_ADDR     0x00000128
-#define VFE_BUS_STATS_CS_UB_CFG           0x0000012C
-#define VFE_BUS_STATS_HIST_WR_PING_ADDR   0x00000130
-#define VFE_BUS_STATS_HIST_WR_PONG_ADDR   0x00000134
-#define VFE_BUS_STATS_HIST_UB_CFG         0x00000138
-#define VFE_BUS_STATS_SKIN_WR_PING_ADDR   0x0000013C
-#define VFE_BUS_STATS_SKIN_WR_PONG_ADDR   0x00000140
-#define VFE_BUS_STATS_SKIN_UB_CFG         0x00000144
-#define VFE_BUS_PING_PONG_STATUS          0x00000180
-#define VFE_AXI_CMD                       0x000001D8
-#define VFE_AXI_STATUS                    0x000001DC
-#define VFE_CAMIF_COMMAND                 0x000001E0
-#define VFE_CAMIF_STATUS                  0x00000204
-#define VFE_REG_UPDATE_CMD                0x00000260
-#define VFE_DEMUX_GAIN_0                  0x00000288
-#define VFE_DEMUX_GAIN_1                  0x0000028C
-#define VFE_CHROMA_UP                     0x0000035C
-#define VFE_FRAMEDROP_ENC_Y_CFG           0x00000504
-#define VFE_FRAMEDROP_ENC_CBCR_CFG        0x00000508
-#define VFE_FRAMEDROP_ENC_Y_PATTERN       0x0000050C
-#define VFE_FRAMEDROP_ENC_CBCR_PATTERN    0x00000510
-#define VFE_FRAMEDROP_VIEW_Y              0x00000514
-#define VFE_FRAMEDROP_VIEW_CBCR           0x00000518
-#define VFE_FRAMEDROP_VIEW_Y_PATTERN      0x0000051C
-#define VFE_FRAMEDROP_VIEW_CBCR_PATTERN   0x00000520
-#define VFE_CLAMP_MAX                     0x00000524
-#define VFE_CLAMP_MIN                     0x00000528
-#define VFE_REALIGN_BUF                   0x0000052C
-#define VFE_STATS_CFG                     0x00000530
-#define VFE_DMI_CFG                       0x00000598
-#define VFE_DMI_ADDR                      0x0000059C
-#define VFE_DMI_DATA_LO                   0x000005A4
-
-struct vfe_stats_control {
-	uint8_t  ackPending;
-	uint32_t nextFrameAddrBuf;
-	uint32_t droppedStatsFrameCount;
-	uint32_t bufToRender;
-};
-
-struct vfe31_ctrl_type {
-	uint16_t operation_mode;     /* streaming or snapshot */
-	struct vfe31_output_path outpath;
-
-	uint32_t vfeImaskCompositePacked;
-
-	spinlock_t  stop_flag_lock;  /* protects stop_ack_pending */
-	spinlock_t  update_ack_lock; /* protects update_ack_pending */
-	spinlock_t  state_lock;      /* protects vstate */
-	spinlock_t  aec_ack_lock;    /* protects aecStatsControl.ackPending */
-	spinlock_t  awb_ack_lock;    /* protects awbStatsControl.ackPending */
-	spinlock_t  af_ack_lock;     /* protects afStatsControl.ackPending */
-	spinlock_t  ihist_ack_lock;  /* protects ihistStatsControl.ackPending */
-	spinlock_t  rs_ack_lock;     /* protects rsStatsControl.ackPending */
-	spinlock_t  cs_ack_lock;     /* protects csStatsControl.ackPending */
-
-	struct msm_vfe_callback *resp;
-	uint32_t extlen;
-	void *extdata;
-
-	int8_t start_ack_pending;
-	int8_t stop_ack_pending;
-	int8_t reset_ack_pending;
-	int8_t update_ack_pending;
-	int8_t req_start_video_rec;
-	int8_t req_stop_video_rec;
-
-	spinlock_t tasklet_lock;
-	struct list_head tasklet_q;
-	int vfeirq;
-	void __iomem *vfebase;
-	void *syncdata;
-
-	struct resource	*vfemem;
-	struct resource *vfeio;
-
-	uint32_t stats_comp;
-	uint8_t vstate;
-	uint32_t vfe_capture_count;
-
-	uint32_t vfeFrameId;
-	uint32_t output1Pattern;
-	uint32_t output1Period;
-	uint32_t output2Pattern;
-	uint32_t output2Period;
-	uint32_t vfeFrameSkipCount;
-	uint32_t vfeFrameSkipPeriod;
-	struct vfe_stats_control afStatsControl;
-	struct vfe_stats_control awbStatsControl;
-	struct vfe_stats_control aecStatsControl;
-	struct vfe_stats_control ihistStatsControl;
-	struct vfe_stats_control rsStatsControl;
-	struct vfe_stats_control csStatsControl;
-};
-
-#define statsAeNum      0
-#define statsAfNum      1
-#define statsAwbNum     2
-#define statsRsNum      3
-#define statsCsNum      4
-#define statsIhistNum   5
-#define statsSkinNum    6
-
-struct vfe_cmd_stats_ack{
-	uint32_t nextStatsBuf;
-};
-
-#define VFE_STATS_BUFFER_COUNT            3
-
-struct vfe_cmd_stats_buf{
-	uint32_t statsBuf[VFE_STATS_BUFFER_COUNT];
-};
-
-#define VFE31_OUTPUT_MODE_PT (0x1 << 0)
-#define VFE31_OUTPUT_MODE_S (0x1 << 1)
-#define VFE31_OUTPUT_MODE_V (0x1 << 2)
-
-#endif /* __MSM_VFE31_H__ */
diff --git a/drivers/media/video/msm/msm_vfe7x.c b/drivers/media/video/msm/msm_vfe7x.c
index 0812bf5..c7c75f6 100644
--- a/drivers/media/video/msm/msm_vfe7x.c
+++ b/drivers/media/video/msm/msm_vfe7x.c
@@ -21,11 +21,11 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <linux/android_pmem.h>
-#include <linux/sched.h>
+#include <mach/msm_adsp.h>
 #include <linux/delay.h>
 #include <linux/wait.h>
+#include <linux/sched.h>
 #include <linux/clk.h>
-#include <mach/msm_adsp.h>
 #include "msm_vfe7x.h"
 
 #define QDSP_CMDQUEUE QDSP_vfeCommandQueue
@@ -55,9 +55,6 @@ static uint8_t vfestopped;
 
 static struct stop_event stopevent;
 
-static struct clk *ebi1_clk;
-static const char *const ebi1_clk_name = "ebi1_clk";
-
 static void vfe_7x_convert(struct msm_vfe_phy_info *pinfo,
 			   enum vfe_resp_msg type,
 			   void *data, void **ext, int *elen)
@@ -234,7 +231,6 @@ static void vfe_7x_release(struct platform_device *pdev)
 {
 	struct msm_sensor_ctrl *sctrl =
 		&((struct msm_sync *)vfe_syncdata)->sctrl;
-
 	mutex_lock(&vfe_lock);
 	vfe_syncdata = NULL;
 	mutex_unlock(&vfe_lock);
@@ -256,12 +252,6 @@ static void vfe_7x_release(struct platform_device *pdev)
 
 	msm_camio_disable(pdev);
 
-	if (ebi1_clk) {
-		clk_set_rate(ebi1_clk, 0);
-		clk_put(ebi1_clk);
-		ebi1_clk = 0;
-	}
-
 	kfree(extdata);
 	extdata = 0;
 }
@@ -278,20 +268,7 @@ static int vfe_7x_init(struct msm_vfe_callback *presp,
 	if (presp && presp->vfe_resp)
 		resp = presp;
 	else
-		return -EIO;
-
-	ebi1_clk = clk_get(NULL, ebi1_clk_name);
-	if (!ebi1_clk) {
-		pr_err("%s: could not get %s\n", __func__, ebi1_clk_name);
-		return -EIO;
-	}
-
-	rc = clk_set_rate(ebi1_clk, 128000000);
-	if (rc < 0) {
-		pr_err("%s: clk_set_rate(%s) failed: %d\n", __func__,
-			ebi1_clk_name, rc);
-		return rc;
-	}
+		return -EFAULT;
 
 	/* Bring up all the required GPIOs and Clocks */
 	rc = msm_camio_enable(dev);
@@ -393,60 +370,77 @@ static int vfe_7x_config_axi(int mode, struct axidata *ad, struct axiout *ao)
 
 static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 {
-	int rc = 0;
-	int i;
-
-	struct msm_pmem_region *regptr = NULL;
+	struct msm_pmem_region *regptr;
+	unsigned char buf[256];
 
 	struct vfe_stats_ack sack;
-	struct axidata *axid = NULL;
+	struct axidata *axid;
+	uint32_t i;
+
+	struct vfe_stats_we_cfg *scfg = NULL;
+	struct vfe_stats_af_cfg *sfcfg = NULL;
 
-	struct axiout axio;
+	struct axiout *axio = NULL;
+	void *cmd_data = NULL;
 	void *cmd_data_alloc = NULL;
-	struct msm_vfe_command_7k vfecmd;
+	long rc = 0;
+	struct msm_vfe_command_7k *vfecmd;
+
+	vfecmd = kmalloc(sizeof(struct msm_vfe_command_7k), GFP_ATOMIC);
+	if (!vfecmd) {
+		pr_err("vfecmd alloc failed!\n");
+		return -ENOMEM;
+	}
 
 	if (cmd->cmd_type != CMD_FRAME_BUF_RELEASE &&
 	    cmd->cmd_type != CMD_STATS_BUF_RELEASE &&
 	    cmd->cmd_type != CMD_STATS_AF_BUF_RELEASE) {
-		if (copy_from_user(&vfecmd,
+		if (copy_from_user(vfecmd,
 				   (void __user *)(cmd->value),
 				   sizeof(struct msm_vfe_command_7k))) {
 			rc = -EFAULT;
-			goto config_error;
+			goto config_failure;
 		}
 	}
 
 	switch (cmd->cmd_type) {
 	case CMD_STATS_AEC_AWB_ENABLE:
 	case CMD_STATS_AXI_CFG:{
-			struct vfe_stats_we_cfg scfg;
 			axid = data;
 			if (!axid) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
 			}
 
-			if (vfecmd.length != sizeof(typeof(scfg))) {
+			scfg =
+			    kmalloc(sizeof(struct vfe_stats_we_cfg),
+				    GFP_ATOMIC);
+			if (!scfg) {
+				rc = -ENOMEM;
+				goto config_failure;
+			}
+
+			if (vfecmd->length != sizeof(typeof(*scfg))) {
 				rc = -EIO;
 				pr_err
 				    ("msm_camera: %s: cmd %d: "\
 				     "user-space data size %d "\
 				     "!= kernel data size %d\n", __func__,
-				     cmd->cmd_type, vfecmd.length,
-				     sizeof(typeof(scfg)));
-				goto config_error;
+				     cmd->cmd_type, vfecmd->length,
+				     sizeof(typeof(*scfg)));
+				goto config_failure;
 			}
 
-			if (copy_from_user(&scfg,
-					   (void __user *)(vfecmd.value),
-					   vfecmd.length)) {
+			if (copy_from_user(scfg,
+					   (void __user *)(vfecmd->value),
+					   vfecmd->length)) {
 
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
 
 			CDBG("STATS_ENABLE: bufnum = %d, enabling = %d\n",
-			     axid->bufnum1, scfg.wb_expstatsenable);
+			     axid->bufnum1, scfg->wb_expstatsenable);
 
 			if (axid->bufnum1 > 0) {
 				regptr = axid->region;
@@ -456,48 +450,57 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 					CDBG("STATS_ENABLE, phy = 0x%lx\n",
 					     regptr->paddr);
 
-					scfg.wb_expstatoutputbuffer[i] =
+					scfg->wb_expstatoutputbuffer[i] =
 					    (void *)regptr->paddr;
 					regptr++;
 				}
 
-				vfecmd.value = &scfg;
+				cmd_data = scfg;
 
 			} else {
 				rc = -EINVAL;
-				goto config_error;
+				goto config_done;
 			}
 		}
 		break;
 
 	case CMD_STATS_AF_ENABLE:
 	case CMD_STATS_AF_AXI_CFG:{
-			struct vfe_stats_af_cfg sfcfg;
 			axid = data;
 			if (!axid) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
 			}
 
-			if (vfecmd.length > sizeof(typeof(sfcfg))) {
+			sfcfg =
+			    kmalloc(sizeof(struct vfe_stats_af_cfg),
+				    GFP_ATOMIC);
+
+			if (!sfcfg) {
+				rc = -ENOMEM;
+				goto config_failure;
+			}
+
+			if (vfecmd->length > sizeof(typeof(*sfcfg))) {
 				pr_err
 				    ("msm_camera: %s: cmd %d: user-space "\
 				     "data %d exceeds kernel buffer %d\n",
-				     __func__, cmd->cmd_type, vfecmd.length,
-				     sizeof(typeof(sfcfg)));
+				     __func__, cmd->cmd_type, vfecmd->length,
+				     sizeof(typeof(*sfcfg)));
 				rc = -EIO;
-				goto config_error;
+				goto config_failure;
 			}
 
-			if (copy_from_user(&sfcfg,
-					   (void __user *)(vfecmd.value),
-					   vfecmd.length)) {
+			if (copy_from_user(sfcfg,
+					   (void __user *)(vfecmd->value),
+					   vfecmd->length)) {
+
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
 
 			CDBG("AF_ENABLE: bufnum = %d, enabling = %d\n",
-			     axid->bufnum1, sfcfg.af_enable);
+			     axid->bufnum1, sfcfg->af_enable);
 
 			if (axid->bufnum1 > 0) {
 				regptr = axid->region;
@@ -507,17 +510,17 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 					CDBG("STATS_ENABLE, phy = 0x%lx\n",
 					     regptr->paddr);
 
-					sfcfg.af_outbuf[i] =
+					sfcfg->af_outbuf[i] =
 					    (void *)regptr->paddr;
 
 					regptr++;
 				}
 
-				vfecmd.value = &sfcfg;
+				cmd_data = sfcfg;
 
 			} else {
 				rc = -EINVAL;
-				goto config_error;
+				goto config_done;
 			}
 		}
 		break;
@@ -528,7 +531,7 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			struct vfe_outputack fack;
 			if (!data) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
 			}
 
 			b = (struct msm_frame *)(cmd->value);
@@ -541,9 +544,9 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			fack.output2newcbcrbufferaddress =
 			    (void *)(p + b->cbcr_off);
 
-			vfecmd.queue = QDSP_CMDQUEUE;
-			vfecmd.length = sizeof(struct vfe_outputack);
-			vfecmd.value = &fack;
+			vfecmd->queue = QDSP_CMDQUEUE;
+			vfecmd->length = sizeof(struct vfe_outputack);
+			cmd_data = &fack;
 		}
 		break;
 
@@ -554,15 +557,15 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			CDBG("vfe_7x_config: CMD_STATS_BUF_RELEASE\n");
 			if (!data) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
 			}
 
 			sack.header = STATS_WE_ACK;
 			sack.bufaddr = (void *)*(uint32_t *) data;
 
-			vfecmd.queue = QDSP_CMDQUEUE;
-			vfecmd.length = sizeof(struct vfe_stats_ack);
-			vfecmd.value = &sack;
+			vfecmd->queue = QDSP_CMDQUEUE;
+			vfecmd->length = sizeof(struct vfe_stats_ack);
+			cmd_data = &sack;
 		}
 		break;
 
@@ -570,41 +573,41 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			CDBG("vfe_7x_config: CMD_STATS_AF_BUF_RELEASE\n");
 			if (!data) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
 			}
 
 			sack.header = STATS_AF_ACK;
 			sack.bufaddr = (void *)*(uint32_t *) data;
 
-			vfecmd.queue = QDSP_CMDQUEUE;
-			vfecmd.length = sizeof(struct vfe_stats_ack);
-			vfecmd.value = &sack;
+			vfecmd->queue = QDSP_CMDQUEUE;
+			vfecmd->length = sizeof(struct vfe_stats_ack);
+			cmd_data = &sack;
 		}
 		break;
 
 	case CMD_GENERAL:
 	case CMD_STATS_DISABLE:{
-			uint8_t buf[256];
-			void *tmp = buf;
-			if (vfecmd.length > sizeof(buf)) {
-				cmd_data_alloc = tmp =
-				    kmalloc(vfecmd.length, GFP_ATOMIC);
-				if (!cmd_data_alloc) {
+			if (vfecmd->length > sizeof(buf)) {
+				cmd_data_alloc =
+				    cmd_data =
+				    kmalloc(vfecmd->length, GFP_ATOMIC);
+				if (!cmd_data) {
 					rc = -ENOMEM;
-					goto config_error;
+					goto config_failure;
 				}
-			}
+			} else
+				cmd_data = buf;
+
+			if (copy_from_user(cmd_data,
+					   (void __user *)(vfecmd->value),
+					   vfecmd->length)) {
 
-			if (copy_from_user(tmp,
-					   (void __user *)(vfecmd.value),
-					   vfecmd.length)) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
-			vfecmd.value = tmp;
 
-			if (vfecmd.queue == QDSP_CMDQUEUE) {
-				switch (*(uint32_t *) vfecmd.value) {
+			if (vfecmd->queue == QDSP_CMDQUEUE) {
+				switch (*(uint32_t *) cmd_data) {
 				case VFE_RESET_CMD:
 					msm_camio_vfe_blk_reset();
 					msm_camio_camif_pad_reg_reset_2();
@@ -631,18 +634,24 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			axid = data;
 			if (!axid) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
+			}
+
+			axio = kmalloc(sizeof(struct axiout), GFP_ATOMIC);
+			if (!axio) {
+				rc = -ENOMEM;
+				goto config_failure;
 			}
 
-			if (copy_from_user(&axio, (void *)(vfecmd.value),
-					   sizeof(axio))) {
+			if (copy_from_user(axio, (void *)(vfecmd->value),
+					   sizeof(struct axiout))) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
 
-			vfe_7x_config_axi(OUTPUT_1, axid, &axio);
+			vfe_7x_config_axi(OUTPUT_1, axid, axio);
 
-			vfecmd.value = &axio;
+			cmd_data = axio;
 		}
 		break;
 
@@ -651,17 +660,23 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			axid = data;
 			if (!axid) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
+			}
+
+			axio = kmalloc(sizeof(struct axiout), GFP_ATOMIC);
+			if (!axio) {
+				rc = -ENOMEM;
+				goto config_failure;
 			}
 
-			if (copy_from_user(&axio, (void __user *)(vfecmd.value),
-					   sizeof(axio))) {
+			if (copy_from_user(axio, (void __user *)(vfecmd->value),
+					   sizeof(struct axiout))) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
 
-			vfe_7x_config_axi(OUTPUT_2, axid, &axio);
-			vfecmd.value = &axio;
+			vfe_7x_config_axi(OUTPUT_2, axid, axio);
+			cmd_data = axio;
 		}
 		break;
 
@@ -669,18 +684,24 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			axid = data;
 			if (!axid) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_failure;
+			}
+
+			axio = kmalloc(sizeof(struct axiout), GFP_ATOMIC);
+			if (!axio) {
+				rc = -ENOMEM;
+				goto config_failure;
 			}
 
-			if (copy_from_user(&axio, (void __user *)(vfecmd.value),
-					   sizeof(axio))) {
+			if (copy_from_user(axio, (void __user *)(vfecmd->value),
+					   sizeof(struct axiout))) {
 				rc = -EFAULT;
-				goto config_error;
+				goto config_done;
 			}
 
-			vfe_7x_config_axi(OUTPUT_1_AND_2, axid, &axio);
+			vfe_7x_config_axi(OUTPUT_1_AND_2, axid, axio);
 
-			vfecmd.value = &axio;
+			cmd_data = axio;
 		}
 		break;
 
@@ -689,14 +710,20 @@ static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 	}			/* switch */
 
 	if (vfestopped)
-		goto config_error;
+		goto config_done;
 
 config_send:
-	CDBG("send adsp command = %d\n", *(uint32_t *)vfecmd.value);
-	rc = msm_adsp_write(vfe_mod, vfecmd.queue, vfecmd.value, vfecmd.length);
+	CDBG("send adsp command = %d\n", *(uint32_t *) cmd_data);
+	rc = msm_adsp_write(vfe_mod, vfecmd->queue, cmd_data, vfecmd->length);
+
+config_done:
+	if (cmd_data_alloc != NULL)
+		kfree(cmd_data_alloc);
 
-config_error:
-	kfree(cmd_data_alloc);
+config_failure:
+	kfree(scfg);
+	kfree(axio);
+	kfree(vfecmd);
 	return rc;
 }
 
diff --git a/drivers/media/video/msm/msm_vfe8x.c b/drivers/media/video/msm/msm_vfe8x.c
index b4943be..1fedb2e 100644
--- a/drivers/media/video/msm/msm_vfe8x.c
+++ b/drivers/media/video/msm/msm_vfe8x.c
@@ -22,6 +22,7 @@
 #include <mach/irqs.h>
 #include <linux/clk.h>
 #include "msm_vfe8x_proc.h"
+#include <mach/camera.h>
 
 #define ON  1
 #define OFF 0
@@ -91,9 +92,10 @@ static void vfe_config_axi(int mode,
 			   struct axidata *ad,
 			   struct vfe_cmd_axi_output_config *ao)
 {
-	struct msm_pmem_region *regptr;
+	struct msm_pmem_region *regptr, *regptr1;
 	int i, j;
 	uint32_t *p1, *p2;
+    regptr1 = NULL;
 
 	if (mode == OUTPUT_1 || mode == OUTPUT_1_AND_2) {
 		regptr = ad->region;
@@ -141,6 +143,59 @@ static void vfe_config_axi(int mode,
 			regptr++;
 		}
 	}
+#ifdef CONFIG_720P_CAMERA
+	/* For video configuration */
+	if (mode == OUTPUT_1_AND_3) {
+		/* this is preview buffer. */
+		regptr =  &(ad->region[0]);
+		/* this is video buffer. */
+		regptr1 = &(ad->region[ad->bufnum1]);
+		CDBG("bufnum1 = %d\n", ad->bufnum1);
+		CDBG("bufnum2 = %d\n", ad->bufnum2);
+
+	for (i = 0; i < ad->bufnum1; i++) {
+		p1 = &(ao->output1.outputY.outFragments[i][0]);
+		p2 = &(ao->output1.outputCbcr.outFragments[i][0]);
+
+		CDBG("config_axi: O1, phy = 0x%lx, y_off = %d, "\
+			 "cbcr_off = %d\n", regptr->paddr,
+						 regptr->info.y_off, regptr->info.cbcr_off);
+
+			for (j = 0; j < ao->output1.fragmentCount; j++) {
+
+				*p1 = regptr->paddr + regptr->info.y_off;
+				CDBG("vfe_config_axi: p1 = 0x%x\n", *p1);
+				p1++;
+
+				*p2 = regptr->paddr + regptr->info.cbcr_off;
+				CDBG("vfe_config_axi: p2 = 0x%x\n", *p2);
+				p2++;
+			}
+			regptr++;
+		}
+	for (i = 0; i < ad->bufnum2; i++) {
+		p1 = &(ao->output2.outputY.outFragments[i][0]);
+		p2 = &(ao->output2.outputCbcr.outFragments[i][0]);
+
+		CDBG("config_axi: O2, phy = 0x%lx, y_off = %d, "\
+			 "cbcr_off = %d\n", regptr1->paddr,
+						 regptr1->info.y_off, regptr1->info.cbcr_off);
+
+			for (j = 0; j < ao->output2.fragmentCount; j++) {
+
+				*p1 = regptr1->paddr + regptr1->info.y_off;
+				CDBG("vfe_config_axi: p1 = 0x%x\n", *p1);
+				p1++;
+
+				*p2 = regptr1->paddr + regptr1->info.cbcr_off;
+				CDBG("vfe_config_axi: p2 = 0x%x\n", *p2);
+				p2++;
+			}
+			regptr1++;
+		}
+	}
+#endif
+
 }
 
 #define ERR_COPY_FROM_USER() \
@@ -503,13 +558,6 @@ static int vfe_proc_general(struct msm_vfe_command_8k *cmd)
 	case VFE_CMD_ID_TEST_GEN_START:
 		break;
 
-	case VFE_CMD_ID_EPOCH1_CONFIG:{
-			struct vfe_cmds_camif_epoch epoch1;
-			CHECKED_COPY_FROM_USER(&epoch1);
-			vfe_epoch1_config(&epoch1);
-		}
-		break;
-
 /*
   acknowledge from upper layer
 	these are not in general command.
@@ -622,6 +670,9 @@ static int vfe_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			b = (struct msm_frame *)(cmd->value);
 			p = *(unsigned long *)data;
 
+#ifndef CONFIG_720P_CAMERA
+			b->path = MSM_FRAME_ENC;
+
 			fack.ybufaddr[0] = (uint32_t) (p + b->y_off);
 
 			fack.chromabufaddr[0] = (uint32_t) (p + b->cbcr_off);
@@ -632,8 +683,19 @@ static int vfe_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			if (b->path == MSM_FRAME_ENC ||
 			    b->path == MSM_FRAME_PREV_2)
 				vfe_output2_ack(&fack);
+#else
+
+			fack.ybufaddr[0] = (uint32_t) (p + b->y_off);
+
+			fack.chromabufaddr[0] = (uint32_t) (p + b->cbcr_off);
 
+		if (b->path == OUTPUT_TYPE_P)
+			vfe_output_p_ack(&fack);
 
+		if ((b->path == OUTPUT_TYPE_V)
+			 || (b->path == OUTPUT_TYPE_S))
+			vfe_output_v_ack(&fack);
+#endif
 		}
 		break;
 
@@ -659,7 +721,7 @@ static int vfe_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			vfe_stats_af_ack(&ack);
 		}
 		break;
-
+#ifndef CONFIG_720P_CAMERA
 	case CMD_AXI_CFG_OUT1: {
 
 			BUG_ON(!axid);
@@ -693,8 +755,7 @@ static int vfe_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 		}
 		break;
 
-	case CMD_AXI_CFG_O1_AND_O2:
-	case CMD_AXI_CFG_SNAP_O1_AND_O2: {
+	case CMD_AXI_CFG_SNAP_O1_AND_O2:{
 
 			BUG_ON(!axid);
 
@@ -708,7 +769,57 @@ static int vfe_config(struct msm_vfe_cfg_cmd *cmd, void *data)
 			vfe_axi_output_config(&axio);
 		}
 		break;
+#else
+	case CMD_AXI_CFG_PREVIEW:
+	case CMD_RAW_PICT_AXI_CFG: {
+
+			BUG_ON(!axid);
+
+			if (copy_from_user(&axio, (void __user *)(vfecmd.value),
+				sizeof(axio))) {
+				pr_err("%s %d: copy_from_user failed\n",
+					__func__, __LINE__);
+			return -EFAULT;
+		}
+
+			vfe_config_axi(OUTPUT_2, axid, &axio);
+
+			axio.outputDataSize = 0;
+			vfe_axi_output_config(&axio);
+	}
+		break;
+
+	case CMD_AXI_CFG_SNAP: {
+
+			BUG_ON(!axid);
 
+			if (copy_from_user(&axio, (void __user *)(vfecmd.value),
+				sizeof(axio))) {
+				pr_err("%s %d: copy_from_user failed\n",
+					__func__, __LINE__);
+			return -EFAULT;
+		}
+
+			vfe_config_axi(OUTPUT_1_AND_2, axid, &axio);
+			vfe_axi_output_config(&axio);
+	}
+		break;
+
+	case CMD_AXI_CFG_VIDEO: {
+			BUG_ON(!axid);
+
+			if (copy_from_user(&axio, (void __user *)(vfecmd.value),
+				sizeof(axio))) {
+				pr_err("%s %d: copy_from_user failed\n",
+					__func__, __LINE__);
+			return -EFAULT;
+		}
+			vfe_config_axi(OUTPUT_1_AND_3, axid, &axio);
+			axio.outputDataSize = 0;
+			vfe_axi_output_config(&axio);
+	}
+		break;
+#endif
 	default:
 		break;
 	}			/* switch */
diff --git a/drivers/media/video/msm/msm_vfe8x.h b/drivers/media/video/msm/msm_vfe8x.h
index 09d5875..dc59b0f 100644
--- a/drivers/media/video/msm/msm_vfe8x.h
+++ b/drivers/media/video/msm/msm_vfe8x.h
@@ -108,10 +108,11 @@ enum vfe_cmd_id {
 	VFE_CMD_ID_STATS_WB_EXP_STOP,
 
 	VFE_CMD_ID_ASYNC_TIMER_SETTING,
-
-	/* epoch1 */
-	VFE_CMD_ID_EPOCH1_CONFIG,
-
+#ifdef CONFIG_720P_CAMERA
+	/* Video recording */
+	VFE_CMD_ID_START_RECORDING,
+	VFE_CMD_ID_STOP_RECORDING,
+#endif
 	/* max id  */
 	VFE_CMD_ID_MAX
 };
@@ -807,8 +808,15 @@ enum VFE_MESSAGE_ID {
 	VFE_MSG_ID_START_ACK,
 	VFE_MSG_ID_STOP_ACK,
 	VFE_MSG_ID_UPDATE_ACK,
+#ifndef CONFIG_720P_CAMERA
 	VFE_MSG_ID_OUTPUT1,
 	VFE_MSG_ID_OUTPUT2,
+#else
+	VFE_MSG_ID_OUTPUT_P,
+	VFE_MSG_ID_OUTPUT_V,
+	VFE_MSG_ID_OUTPUT_S,
+	VFE_MSG_ID_OUTPUT_T,
+#endif
 	VFE_MSG_ID_SNAPSHOT_DONE,
 	VFE_MSG_ID_STATS_AUTOFOCUS,
 	VFE_MSG_ID_STATS_WB_EXP,
diff --git a/drivers/media/video/msm/msm_vfe8x_proc.c b/drivers/media/video/msm/msm_vfe8x_proc.c
index 23ea197..7d6f83d 100644
--- a/drivers/media/video/msm/msm_vfe8x_proc.c
+++ b/drivers/media/video/msm/msm_vfe8x_proc.c
@@ -99,6 +99,7 @@ struct msm_vfe8x_ctrl {
 	void __iomem *vfebase;
 
 	void *syncdata;
+	struct msm_camera_sensor_info *s_info;
 };
 
 static struct msm_vfe8x_ctrl *ctrl;
@@ -365,7 +366,8 @@ static void vfe_write_lens_roll_off_table(struct vfe_cmd_roll_off_config *in)
 		writel(data, ctrl->vfebase + VFE_DMI_DATA_LO);
 
 		data = (((uint32_t) (*initB)) & 0x0000FFFF) |
-		    (((uint32_t) (*initGr)) << 16);
+		/* 20101011: fix mesh LSC */
+		    (((uint32_t) (*initGb)) << 16);
 		initB++;
 		initGb++;
 
@@ -378,13 +380,17 @@ static void vfe_write_lens_roll_off_table(struct vfe_cmd_roll_off_config *in)
 
 	/* pack and write delta table */
 	for (i = 0; i < VFE_ROLL_OFF_DELTA_TABLE_SIZE; i++) {
-		data = *pDeltaR | (*pDeltaGr << 16);
+		/* 20101011: fix mesh LSC */
+		data = (((int32_t)(*pDeltaR)) & 0x0000FFFF) |
+			(((int32_t)(*pDeltaGr))<<16);
 		pDeltaR++;
 		pDeltaGr++;
 
 		writel(data, ctrl->vfebase + VFE_DMI_DATA_LO);
+		/* 20101011: fix mesh LSC */
+		data = (((int32_t)(*pDeltaB)) & 0x0000FFFF) |
+			(((int32_t)(*pDeltaGb))<<16);
 
-		data = *pDeltaB | (*pDeltaGb << 16);
 		pDeltaB++;
 		pDeltaGb++;
 
@@ -602,6 +608,7 @@ static void vfe_addr_convert(struct msm_vfe_phy_info *pinfo,
 			     int *elen)
 {
 	switch (type) {
+#ifndef CONFIG_720P_CAMERA
 	case VFE_MSG_OUTPUT1:{
 			pinfo->y_phy =
 			    ((struct vfe_message *)data)->_u.msgOutput1.yBuffer;
@@ -656,6 +663,34 @@ static void vfe_addr_convert(struct msm_vfe_phy_info *pinfo,
 			*elen = sizeof(ctrl->extdata);
 		}
 		break;
+#else
+	case VFE_MSG_OUTPUT_P:
+	case VFE_MSG_OUTPUT_V:{
+		pinfo->y_phy =
+			((struct vfe_message *)data)->_u.msgOutput2.yBuffer;
+		pinfo->cbcr_phy =
+			((struct vfe_message *)data)->_u.msgOutput2.
+			cbcrBuffer;
+
+			CDBG("vfe_addr_convert, pinfo->y_phy = 0x%x\n",
+				pinfo->y_phy);
+		CDBG("vfe_addr_convert, pinfo->cbcr_phy = 0x%x\n",
+			pinfo->cbcr_phy);
+		/*pinfo->output_id = OUTPUT_TYPE_P;*/
+		ctrl->extdata.bpcInfo =
+			((struct vfe_message *)data)->_u.msgOutput2.bpcInfo;
+		ctrl->extdata.asfInfo =
+			((struct vfe_message *)data)->_u.msgOutput2.asfInfo;
+		ctrl->extdata.frameCounter =
+			((struct vfe_message *)data)->_u.msgOutput2.
+			frameCounter;
+		ctrl->extdata.pmData =
+		((struct vfe_message *)data)->_u.msgOutput2.pmData;
+		*ext = &ctrl->extdata;
+		*elen = sizeof(ctrl->extdata);
+	}
+		break;
+#endif
 
 	case VFE_MSG_STATS_AF:
 		pinfo->sbuf_phy =
@@ -672,10 +707,17 @@ static void vfe_addr_convert(struct msm_vfe_phy_info *pinfo,
 	}			/* switch */
 }
 
-static boolean vfe_send_output1_msg(struct msm_vfe_resp *rp,
+static boolean vfe_send_preview_msg(struct msm_vfe_resp *rp,
+			struct vfe_message *msg, void *data);
+static boolean vfe_send_video_msg(struct msm_vfe_resp *rp,
 			struct vfe_message *msg, void *data);
-static boolean vfe_send_output2_msg(struct msm_vfe_resp *rp,
+#ifdef CONFIG_720P_CAMERA
+static boolean vfe_send_mainimage_msg(struct msm_vfe_resp *rp,
 			struct vfe_message *msg, void *data);
+static boolean vfe_send_thumbnail_msg(struct msm_vfe_resp *rp,
+			struct vfe_message *msg, void *data);
+#endif
+
 static boolean vfe_send_af_stats_msg(struct msm_vfe_resp *rp,
 			struct vfe_message *msg, void *data);
 static boolean vfe_send_awb_stats_msg(struct msm_vfe_resp *rp,
@@ -700,8 +742,15 @@ static struct {
 	[VFE_MSG_ID_START_ACK] = { NULL, VFE_MSG_GENERAL },
 	[VFE_MSG_ID_STOP_ACK] = { NULL, VFE_MSG_GENERAL },
 	[VFE_MSG_ID_UPDATE_ACK] = { NULL, VFE_MSG_GENERAL },
-	[VFE_MSG_ID_OUTPUT1] = { vfe_send_output1_msg, VFE_MSG_OUTPUT1 },
-	[VFE_MSG_ID_OUTPUT2] = { vfe_send_output2_msg, VFE_MSG_OUTPUT2 },
+#ifndef CONFIG_720P_CAMERA
+	[VFE_MSG_ID_OUTPUT1] = { vfe_send_preview_msg, VFE_MSG_OUTPUT1 },
+	[VFE_MSG_ID_OUTPUT2] = { vfe_send_video_msg, VFE_MSG_OUTPUT2 },
+#else
+	[VFE_MSG_ID_OUTPUT_P] = { vfe_send_preview_msg, VFE_MSG_OUTPUT_P },
+	[VFE_MSG_ID_OUTPUT_V] = { vfe_send_video_msg, VFE_MSG_OUTPUT_V },
+	[VFE_MSG_ID_OUTPUT_S] = { vfe_send_mainimage_msg, VFE_MSG_OUTPUT_S },
+	[VFE_MSG_ID_OUTPUT_T] = { vfe_send_thumbnail_msg, VFE_MSG_OUTPUT_T },
+#endif
 	[VFE_MSG_ID_SNAPSHOT_DONE] = { NULL, VFE_MSG_SNAPSHOT },
 	[VFE_MSG_ID_STATS_AUTOFOCUS] = { vfe_send_af_stats_msg, VFE_MSG_STATS_AF },
 	[VFE_MSG_ID_STATS_WB_EXP] = { vfe_send_awb_stats_msg, VFE_MSG_STATS_WE },
@@ -727,7 +776,6 @@ static void vfe_proc_ops(enum VFE_MESSAGE_ID id, void *data)
 {
 	struct msm_vfe_resp *rp;
 	struct vfe_message *msg;
-	struct msm_sync *sync = (struct msm_sync *)ctrl->syncdata;
 
 	CDBG("ctrl->vfeOperationMode = %d, msgId = %d\n",
 	     ctrl->vfeOperationMode, id);
@@ -743,11 +791,17 @@ static void vfe_proc_ops(enum VFE_MESSAGE_ID id, void *data)
 	 * allocate and then immediately free the msm_vfe_resp structure,
 	 * which is wasteful.
 	 */
+#ifndef CONFIG_720P_CAMERA
 	if ((ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT) &&
 			(id == VFE_MSG_ID_OUTPUT1 ||
 			 id == VFE_MSG_ID_OUTPUT2))
 		return;
-
+#else
+	if ((ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT) &&
+			(id == VFE_MSG_ID_OUTPUT_T ||
+			 id == VFE_MSG_ID_OUTPUT_S))
+		return;
+#endif
 	rp = ctrl->resp->vfe_alloc(sizeof(*rp) +
 					(vfe_funcs[id].fn ? sizeof(*msg) : 0),
 					ctrl->syncdata,
@@ -760,7 +814,12 @@ static void vfe_proc_ops(enum VFE_MESSAGE_ID id, void *data)
 	rp->type = vfe_funcs[id].rt;
 	rp->evt_msg.type = MSM_CAMERA_MSG;
 	rp->evt_msg.msg_id = id;
+	rp->evt_msg.exttype = 0;
+
+	if (ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT) {
+		rp->evt_msg.exttype = VFE_MSG_SNAPSHOT;
 
+#if 0  /* google flashlight */
 	/* Turn off the flash if epoch1 is enabled and snapshot is done. */
 	if (ctrl->vfeCamifEpoch1Local.enable &&
 			ctrl->vfeOperationMode ==
@@ -768,6 +827,7 @@ static void vfe_proc_ops(enum VFE_MESSAGE_ID id, void *data)
 			id == VFE_MSG_ID_SNAPSHOT_DONE) {
 		ctrl->resp->flash_ctrl(sync, MSM_CAMERA_LED_OFF);
 		ctrl->vfeCamifEpoch1Local.enable = 0;
+#endif
 	}
 
 	if (!vfe_funcs[id].fn) {
@@ -781,6 +841,12 @@ static void vfe_proc_ops(enum VFE_MESSAGE_ID id, void *data)
 		else
 			rp->evt_msg.data = msg = 0;
 		rp->evt_msg.len = sizeof(*msg);
+
+		if (msg == NULL) {
+			pr_err("%s dsp send msg with NULL pointer\n",
+				__func__);
+			return ;
+		}
 		msg->_d = id;
 		if (vfe_funcs[id].fn(rp, msg, data) == FALSE) {
 			pr_info("%s: freeing memory: handler for %d "
@@ -853,8 +919,8 @@ static void vfe_process_error_irq(struct isr_queue_cmd *qcmd)
 static void vfe_process_camif_epoch1_irq(void)
 {
 	/* Turn on the flash. */
-	struct msm_sync *sync = (struct msm_sync *)ctrl->syncdata;
-	ctrl->resp->flash_ctrl(sync, MSM_CAMERA_LED_HIGH);
+	/*remove google flashlight*/
+	/*ctrl->resp->flash_ctrl(sync, MSM_CAMERA_LED_HIGH);*/
 
 	/* Disable the epoch1 interrupt. */
 	ctrl->vfeImaskLocal.camifEpoch1Irq = FALSE;
@@ -1325,9 +1391,25 @@ static void vfe_process_pingpong_irq(struct vfe_output_path *in,
 	}
 }
 
-static boolean vfe_send_output2_msg(struct msm_vfe_resp *rp,
+static boolean vfe_send_video_msg(struct msm_vfe_resp *rp,
 		struct vfe_message *msg, void *data)
 {
+#ifdef CONFIG_720P_CAMERA
+	struct vfe_msg_output *pPayload = data;
+
+	if (ctrl->vstate != VFE_STATE_ACTIVE)
+		return FALSE;
+	memcpy(&(msg->_u),
+		(void *)pPayload, sizeof(struct vfe_msg_output));
+
+	rp->phy.output_id = OUTPUT_TYPE_V;
+	CDBG("vfe_send_video_msg rp->type= %d\n",rp->type);
+
+	vfe_addr_convert(&(rp->phy),
+			rp->type, msg,
+			&(rp->extdata), &(rp->extlen));
+	return TRUE;
+#else
 	struct vfe_msg_output *pPayload = data;
 
 	if (ctrl->vstate != VFE_STATE_ACTIVE)
@@ -1337,7 +1419,6 @@ static boolean vfe_send_output2_msg(struct msm_vfe_resp *rp,
 	       (void *)pPayload, sizeof(struct vfe_msg_output));
 
 	ctrl->encPath.ackPending = TRUE;
-	rp->phy.output_id = MSM_FRAME_PREV_2;
 
 	if (!(ctrl->vfeRequestedSnapShotCount <= 3) &&
 	    (ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT))
@@ -1347,11 +1428,29 @@ static boolean vfe_send_output2_msg(struct msm_vfe_resp *rp,
 			rp->type, msg,
 			&(rp->extdata), &(rp->extlen));
 	return TRUE;
+#endif
 }
 
-static boolean vfe_send_output1_msg(struct msm_vfe_resp *rp,
+static boolean vfe_send_preview_msg(struct msm_vfe_resp *rp,
 		struct vfe_message *msg, void *data)
 {
+#ifdef CONFIG_720P_CAMERA
+	struct vfe_msg_output *pPayload = data;
+
+	if (ctrl->vstate != VFE_STATE_ACTIVE)
+		return FALSE;
+
+	memcpy(&(msg->_u), (void *)pPayload, sizeof(struct vfe_msg_output));
+
+	rp->phy.output_id = OUTPUT_TYPE_P;
+	CDBG("vfe_send_preview_msg rp->type= %d\n",rp->type);
+
+	vfe_addr_convert(&(rp->phy),
+			rp->type, msg,
+			&(rp->extdata), &(rp->extlen));
+
+	return TRUE;
+#else
 	struct vfe_msg_output *pPayload = data;
 
 	if (ctrl->vstate != VFE_STATE_ACTIVE)
@@ -1360,7 +1459,7 @@ static boolean vfe_send_output1_msg(struct msm_vfe_resp *rp,
 	memcpy(&(msg->_u), (void *)pPayload, sizeof(struct vfe_msg_output));
 
 	ctrl->viewPath.ackPending = TRUE;
-	rp->phy.output_id = MSM_FRAME_PREV_1;
+
 	if (!(ctrl->vfeRequestedSnapShotCount <= 3) &&
 	    (ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT))
 		ctrl->viewPath.ackPending = TRUE;
@@ -1370,8 +1469,59 @@ static boolean vfe_send_output1_msg(struct msm_vfe_resp *rp,
 			&(rp->extdata), &(rp->extlen));
 
 	return TRUE;
+#endif
+}
+
+#ifdef CONFIG_720P_CAMERA
+
+static boolean vfe_send_thumbnail_msg(struct msm_vfe_resp *rp,
+		struct vfe_message *msg, void *data)
+{
+	struct vfe_msg_output *pPayload = data;
+
+	if (ctrl->vstate != VFE_STATE_ACTIVE)
+		return FALSE;
+
+	memcpy(&(msg->_u), (void *)pPayload, sizeof(struct vfe_msg_output));
+
+	rp->phy.output_id = OUTPUT_TYPE_T;
+	CDBG("vfe_send_thumbnail_msg rp->type= %d\n",rp->type);
+
+	if (ctrl->viewPath.snapshotPendingCount <= 1)
+		ctrl->viewPath.ackPending = FALSE;
+
+	vfe_addr_convert(&(rp->phy),
+			rp->type, msg,
+			&(rp->extdata), &(rp->extlen));
+
+	return TRUE;
 }
 
+static boolean vfe_send_mainimage_msg(struct msm_vfe_resp *rp,
+		struct vfe_message *msg, void *data)
+{
+	struct vfe_msg_output *pPayload = data;
+
+	if (ctrl->vstate != VFE_STATE_ACTIVE)
+		return FALSE;
+
+	memcpy(&(msg->_u), (void *)pPayload, sizeof(struct vfe_msg_output));
+
+	rp->phy.output_id = OUTPUT_TYPE_S;
+	CDBG("vfe_send_mainimage_msg rp->type= %d\n",rp->type);
+
+	if (ctrl->encPath.snapshotPendingCount <=1 ) {
+		ctrl->encPath.ackPending = FALSE;
+	}
+
+	vfe_addr_convert(&(rp->phy),
+			rp->type, msg,
+			&(rp->extdata), &(rp->extlen));
+
+	return TRUE;
+}
+#endif
+
 static void vfe_send_output_msg(boolean whichOutputPath,
 				uint32_t yPathAddr, uint32_t cbcrPathAddr)
 {
@@ -1395,6 +1545,7 @@ static void vfe_send_output_msg(boolean whichOutputPath,
 	/* frame ID is common for both paths. */
 	msgPayload.frameCounter = ctrl->vfeFrameId;
 
+#ifndef CONFIG_720P_CAMERA
 	if (whichOutputPath) {
 		/* msgPayload.pmData = ctrl->vfePmData.encPathPmInfo; */
 		vfe_proc_ops(VFE_MSG_ID_OUTPUT2, &msgPayload);
@@ -1402,6 +1553,35 @@ static void vfe_send_output_msg(boolean whichOutputPath,
 		/* msgPayload.pmData = ctrl->vfePmData.viewPathPmInfo; */
 		vfe_proc_ops(VFE_MSG_ID_OUTPUT1, &msgPayload);
 	}
+#else
+		if (whichOutputPath) {/* vfe output2 physical path */
+		/* msgPayload.pmData = ctrl->vfePmData.encPathPmInfo; */
+		ctrl->encPath.ackPending = TRUE;
+
+		if (ctrl->vfeOperationMode == 0) {
+			if (ctrl->axiOutputMode == VFE_AXI_OUTPUT_MODE_Output1AndOutput2) {
+				/* video mode */
+				vfe_proc_ops(VFE_MSG_ID_OUTPUT_V, &msgPayload);
+			} else { /* preview mode */
+				vfe_proc_ops(VFE_MSG_ID_OUTPUT_P, &msgPayload);
+			}
+		} else {
+			vfe_proc_ops(VFE_MSG_ID_OUTPUT_S, &msgPayload);
+		}
+
+	} else {   /* physical output1 path from vfe */
+		ctrl->viewPath.ackPending = TRUE;
+
+		if (ctrl->vfeOperationMode == 0) {
+			vfe_proc_ops(VFE_MSG_ID_OUTPUT_P, &msgPayload);
+			CDBG(" ==== check output ==== video mode display output.\n");
+
+		} else {
+			vfe_proc_ops(VFE_MSG_ID_OUTPUT_T, &msgPayload);
+			CDBG(" ==== check output ==== snapshot mode thumbnail output.\n");
+		}
+	}
+#endif
 }
 
 static void vfe_process_frame_done_irq_multi_frag(struct vfe_output_path_combo
@@ -1595,6 +1775,7 @@ static void vfe_process_output_path_irq(struct vfe_interrupt_status *irqstatus)
 								      encPath);
 
 		} else {
+			CDBG("horng irqstatus->encIrq = %x\n", irqstatus->encIrq);
 			if (irqstatus->encIrq)
 				vfe_process_frame_done_irq_no_frag(&ctrl->
 								   encPath);
@@ -1614,6 +1795,8 @@ static void vfe_process_output_path_irq(struct vfe_interrupt_status *irqstatus)
 	}
 }
 
+static int preview_skipframe;
+#define FRAME_SKIP 2
 static void __vfe_do_tasklet(struct isr_queue_cmd *qcmd)
 {
 	if (qcmd->vfeInterruptStatus.regUpdateIrq) {
@@ -1623,6 +1806,7 @@ static void __vfe_do_tasklet(struct isr_queue_cmd *qcmd)
 
 	if (qcmd->vfeInterruptStatus.resetAckIrq) {
 		CDBG("%s: process resetAckIrq\n", __func__);
+		preview_skipframe = 0;
 		vfe_process_reset_irq();
 	}
 
@@ -1641,7 +1825,11 @@ static void __vfe_do_tasklet(struct isr_queue_cmd *qcmd)
 	/* next, check output path related interrupts. */
 	if (qcmd->vfeInterruptStatus.anyOutputPathIrqs) {
 		CDBG("irq: anyOutputPathIrqs\n");
-		vfe_process_output_path_irq(&qcmd->vfeInterruptStatus);
+		if(preview_skipframe > FRAME_SKIP ||
+			ctrl->vfeOperationMode == VFE_START_OPERATION_MODE_SNAPSHOT)
+			vfe_process_output_path_irq(&qcmd->vfeInterruptStatus);
+		else
+			preview_skipframe ++;
 	}
 
 	if (qcmd->vfeInterruptStatus.afPingpongIrq)
@@ -1713,6 +1901,9 @@ static void vfe_do_tasklet(unsigned long data)
 	int cnt = 0;
 	struct isr_queue_cmd *qcmd = NULL;
 
+    if (!ctrl)
+		return;
+
 	CDBG("%s\n", __func__);
 
 	while ((qcmd = next_irq_cmd())) {
@@ -1836,6 +2027,7 @@ int vfe_cmd_init(struct msm_vfe_callback *presp,
 	}
 
 	ctrl->syncdata = sdata;
+	ctrl->s_info = s_info;
 	return 0;
 
 cmd_init_failed3:
@@ -1858,7 +2050,11 @@ void vfe_cmd_release(struct platform_device *dev)
 
 	iounmap(ctrl->vfebase);
 	mem = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	release_mem_region(mem->start, (mem->end - mem->start) + 1);
+	if (mem == NULL) {
+		pr_err("%s : platform get resource is NULL pointer\n",
+			__func__);
+	} else
+		release_mem_region(mem->start, (mem->end - mem->start) + 1);
 
 	kfree(ctrl);
 	ctrl = 0;
@@ -2074,6 +2270,7 @@ void vfe_stats_wb_exp_ack(struct vfe_cmd_stats_wb_exp_ack *in)
 	ctrl->awbStatsControl.ackPending = FALSE;
 }
 
+#ifndef CONFIG_720P_CAMERA
 void vfe_output2_ack(struct vfe_cmd_output_ack *in)
 {
 	const uint32_t *psrc;
@@ -2114,6 +2311,69 @@ void vfe_output1_ack(struct vfe_cmd_output_ack *in)
 	ctrl->viewPath.ackPending = FALSE;
 }
 
+#else
+
+void vfe_output_v_ack(struct vfe_cmd_output_ack *in)
+{
+	const uint32_t *psrc;
+	uint32_t *pdest;
+	uint8_t i;
+
+	pdest = ctrl->encPath.nextFrameAddrBuf;
+
+//	CDBG("output2_ack: ack addr = 0x%x\n", in->ybufaddr[0]);
+	CDBG("video_frame_ack: ack addr = 0x%x\n", in->ybufaddr[0]);
+
+	psrc = in->ybufaddr;
+	for (i = 0; i < ctrl->encPath.fragCount; i++)
+		*pdest++ = *psrc++;
+
+	psrc = in->chromabufaddr;
+	for (i = 0; i < ctrl->encPath.fragCount; i++)
+		*pdest++ = *psrc++;
+
+	ctrl->encPath.ackPending = FALSE;
+}
+
+void vfe_output_p_ack(struct vfe_cmd_output_ack *in)
+{
+	const uint32_t *psrc;
+	uint32_t *pdest;
+	uint8_t i;
+
+	if (ctrl->axiOutputMode == VFE_AXI_OUTPUT_MODE_Output1AndOutput2 ) {
+		/* video mode, preview comes from output1 path */
+
+	pdest = ctrl->viewPath.nextFrameAddrBuf;
+
+	psrc = in->ybufaddr;
+	for (i = 0; i < ctrl->viewPath.fragCount; i++)
+		*pdest++ = *psrc++;
+
+	psrc = in->chromabufaddr;
+	for (i = 0; i < ctrl->viewPath.fragCount; i++)
+		*pdest++ = *psrc++;
+
+	ctrl->viewPath.ackPending = FALSE;
+
+	} else { /* preview mode, preview comes from output2 path. */
+		pdest = ctrl->encPath.nextFrameAddrBuf;
+
+		psrc = in->ybufaddr;
+		for (i = 0; i < ctrl->encPath.fragCount; i++)
+			*pdest++ = *psrc++;
+
+		psrc = in->chromabufaddr;
+		for (i = 0; i < ctrl->encPath.fragCount; i++)
+			*pdest++ = *psrc++;
+
+		ctrl->encPath.ackPending = FALSE;
+
+	}
+}
+
+#endif
+
 void vfe_start(struct vfe_cmd_start *in)
 {
 	uint32_t pmstatus = 0;
diff --git a/drivers/media/video/msm/msm_vfe8x_proc.h b/drivers/media/video/msm/msm_vfe8x_proc.h
index aef7eca..27db7df 100644
--- a/drivers/media/video/msm/msm_vfe8x_proc.h
+++ b/drivers/media/video/msm/msm_vfe8x_proc.h
@@ -1564,7 +1564,11 @@ void vfe_fov_crop_config(struct vfe_cmd_fov_crop_config *);
 void vfe_get_hw_version(struct vfe_cmd_hw_version *);
 void vfe_reset(void);
 void vfe_cmd_release(struct platform_device *);
+#ifndef CONFIG_720P_CAMERA
 void vfe_output1_ack(struct vfe_cmd_output_ack *);
 void vfe_output2_ack(struct vfe_cmd_output_ack *);
-void vfe_epoch1_config(struct vfe_cmds_camif_epoch *);
+#else
+void vfe_output_p_ack(struct vfe_cmd_output_ack *);
+void vfe_output_v_ack(struct vfe_cmd_output_ack *);
+#endif
 #endif /* __MSM_VFE8X_REG_H__ */
diff --git a/drivers/media/video/msm/mt9d112.c b/drivers/media/video/msm/mt9d112.c
index 5a6a8db..868445f 100644
--- a/drivers/media/video/msm/mt9d112.c
+++ b/drivers/media/video/msm/mt9d112.c
@@ -21,6 +21,7 @@
 #include <linux/i2c.h>
 #include <linux/uaccess.h>
 #include <linux/miscdevice.h>
+#include <linux/slab.h>
 #include <media/msm_camera.h>
 #include <mach/gpio.h>
 #include "mt9d112.h"
diff --git a/drivers/media/video/msm/mt9p012_fox.c b/drivers/media/video/msm/mt9p012_fox.c
index f2ff40a..299c59b 100644
--- a/drivers/media/video/msm/mt9p012_fox.c
+++ b/drivers/media/video/msm/mt9p012_fox.c
@@ -22,6 +22,7 @@
 #include <linux/uaccess.h>
 #include <linux/miscdevice.h>
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <media/msm_camera.h>
 #include <mach/gpio.h>
 #include <mach/camera.h>
diff --git a/drivers/media/video/msm/ov8810.c b/drivers/media/video/msm/ov8810.c
new file mode 100644
index 0000000..8e29135
--- /dev/null
+++ b/drivers/media/video/msm/ov8810.c
@@ -0,0 +1,2749 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include <mach/camera.h>
+#include <mach/vreg.h>
+#include <asm/mach-types.h>
+#include "ov8810.h"
+
+
+/* CAMIF output resolutions */
+/* 816x612, 24MHz MCLK 96MHz PCLK */
+#define OV8810_FULL_SIZE_DUMMY_PIXELS	0
+#define OV8810_FULL_SIZE_DUMMY_LINES	0
+#define OV8810_FULL_SIZE_WIDTH		3280
+#define OV8810_FULL_SIZE_HEIGHT		2456
+
+#define OV8810_QTR_SIZE_DUMMY_PIXELS	0
+#define OV8810_QTR_SIZE_DUMMY_LINES	0
+#define OV8810_QTR_SIZE_WIDTH		1632
+#define OV8810_QTR_SIZE_HEIGHT		1224
+
+#define OV8810_HRZ_FULL_BLK_PIXELS	696  /*stella 1203*/
+#define OV8810_VER_FULL_BLK_LINES	44
+#define OV8810_HRZ_QTR_BLK_PIXELS	890
+#define OV8810_VER_QTR_BLK_LINES	44
+
+static int cam_mode_sel = 0; /* 0: photo, 1: video@30fps, 2: video@24fps */
+/* 240: 26, 365: 24, 589: 21 */
+const int ov8810_ver_qtr_blk_lines_array[] = {44, 44, 365};
+
+/*=============================================================
+	SENSOR REGISTER DEFINES
+==============================================================*/
+#define Q8				0x00000100
+
+/* Omnivision8810 product ID register address */
+#define OV8810_PIDH_REG			0x300A
+#define OV8810_PIDL_REG			0x300B
+
+/* Omnivision8810 product ID */
+#define OV8810_PID			0x88
+/* Omnivision8810 version */
+#define OV8810_VER			0x10
+
+/* Time in milisecs for waiting for the sensor to reset */
+#define OV8810_RESET_DELAY_MSECS	66
+
+#define OV8810_DEFAULT_CLOCK_RATE	24000000
+
+/* Registers*/
+/* PLL Registers */
+#define REG_PRE_PLL_CLK_DIV		0x3011 /*0x0305*/
+#define REG_PLL_MULTIPLIER		0x3010
+#define REG_VT_CLK_DIV			0x300E	/*[7:4]VT_SYS_DIV, [3-0]VT_PIX_DIV*/
+#define REG_OP_CLK_DIV			0x300F	/*[7:4]OP_SYS_DIV, [3-0]OP_PIX_DIV*/
+
+/* ISP Enable Control */
+#define REG_ISP_ENABLE_CONTROL_00	0x3302
+#define REG_ISP_ENABLE_CONTROL_01	0x3301
+
+/* AWB Control */
+#define REG_AWB_CTRL_0			0x3320
+#define REG_AWB_CTRL_1			0x3321
+#define REG_AWB_CTRL_2			0x3322
+#define REG_AWB_CTRL_8			0x3328
+
+/* Output Size */
+#define REG_X_OUTPUT_SIZE_MSB		0x302C
+#define REG_X_OUTPUT_SIZE_LSB		0x302D
+#define REG_Y_OUTPUT_SIZE_MSB		0x302E
+#define REG_Y_OUTPUT_SIZE_LSB		0x302F
+
+/*Reserved register */
+#define REG_BINNING_CONTROL		0x3091
+
+/* Frame Fotmat */
+#define REG_FRAME_LENGTH_LINES_MSB	0x3020
+#define REG_FRAME_LENGTH_LINES_LSB	0x3021
+#define REG_LINE_LENGTH_PCK_MSB		0x3022
+#define REG_LINE_LENGTH_PCK_LSB		0x3023
+#define REG_EXTRA_VSYNC_WIDTH_MSB	0x301E
+#define REG_EXTRA_VSYNC_WIDTH_LSB	0x301F
+
+#define REG_X_ADDR_START_HIGH		0x3024
+#define REG_X_ADDR_START_LOW		0x3025
+#define REG_Y_ADDR_START_HIGH		0x3026
+#define REG_Y_ADDR_START_LOW		0x3027
+#define REG_X_ADDR_END_HIGH		0x3028
+#define REG_X_ADDR_END_LOW		0x3029
+#define REG_Y_ADDR_END_HIGH		0x302A
+#define REG_Y_ADDR_END_LOW		0x302B
+
+/* Gain setting register */
+#define OV8810_GAIN			0x3000
+#define OV8810_AEC_MSB			0x3002
+#define OV8810_AEC_LSB			0x3003
+
+/* additional gain function provided by OV8810,
+ * original gain can changed to 1x, 2x or 4x
+ * to increase the gain that OV8810 can provide */
+#define OV8810_REG_MUL_GAIN		0x3006
+#define MUL_GAIN_INIT_VALUE		0x00
+
+#define OV8810_MAX_EXPOSURE_GAIN	0x1FF
+
+/* Mode select register */
+#define OV8810_REG_MODE_SELECT		0x30FA	/* image system */
+#define OV8810_MODE_SELECT_STREAM	0x01	/* start streaming */
+#define OV8810_MODE_SELECT_SW_STANDBY	0x00	/* software standby */
+#define OV8810_REG_SOFTWARE_RESET	0x3012	/* 0x0103 */
+#define OV8810_SOFTWARE_RESET		0x80	/* 0x01 */
+
+/* AF Total steps parameters */
+#define OV8810_AF_MSB			0x30EC
+#define OV8810_AF_LSB			0x30ED
+
+#define OV8810_STEPS_NEAR_TO_CLOSEST_INF	42 /*43 stella0122 */
+#define OV8810_TOTAL_STEPS_NEAR_TO_FAR		42 /*43 stella0122 */
+
+/*Test pattern*/
+/* Color bar pattern selection */
+#define OV8810_COLOR_BAR_PATTERN_SEL_REG	0x307B
+
+/* Color bar enabling control */
+#define OV8810_COLOR_BAR_ENABLE_REG		0x307D
+
+/* I2C Address of the Sensor */
+#define OV8810_I2C_SLAVE_ID		0x6C
+
+/*LSC table length*/
+#define LSC_table_length 144
+/*============================================================================
+TYPE DECLARATIONS
+============================================================================*/
+
+/* 16bit address - 8 bit context register structure */
+#if 0
+typedef struct reg_addr_val_pair_struct {
+	uint16_t reg_addr;
+	uint8_t reg_val;
+} reg_struct_type;
+#endif
+
+struct awb_lsc_struct_type {
+       unsigned int caBuff[8];  /*awb_calibartion*/
+	struct reg_addr_val_pair_struct LSC_table[150];  /*lsc_calibration*/
+	uint32_t LSC_table_CRC;
+};
+
+enum ov8810_test_mode_t {
+	TEST_OFF,
+	TEST_1,
+	TEST_2,
+	TEST_3
+};
+
+enum ov8810_resolution_t {
+	QTR_SIZE,
+	FULL_SIZE,
+	INVALID_SIZE
+};
+
+/*LSC calibration*/
+int global_mode;
+/*TODO: should be use a header file to reference this function*/
+extern unsigned char *get_cam_awb_cal(void);
+
+static int sensor_probe_node = 0;
+
+static struct wake_lock ov8810_wake_lock;
+
+static inline void init_suspend(void)
+{
+	wake_lock_init(&ov8810_wake_lock, WAKE_LOCK_IDLE, "ov8810");
+}
+
+static inline void deinit_suspend(void)
+{
+	wake_lock_destroy(&ov8810_wake_lock);
+}
+
+static inline void prevent_suspend(void)
+{
+	wake_lock(&ov8810_wake_lock);
+}
+
+static inline void allow_suspend(void)
+{
+	wake_unlock(&ov8810_wake_lock);
+}
+
+/*============================================================================
+DATA DECLARATIONS
+============================================================================*/
+
+/*  96MHz PCLK @ 24MHz MCLK inc*/
+ /*stella1223 start*/
+static struct reg_addr_val_pair_struct ov8810_init_settings_array[] =
+{
+	/* Sensor clk setup */
+	{REG_OP_CLK_DIV, 0x04},
+	{REG_VT_CLK_DIV, 0x05},
+#if 1   /* weiting0414 prevent capture hang restore CLK */
+	{REG_PLL_MULTIPLIER, 0x28}, /*0x28 96MHz PCLK 0x18 64MHz PCLK*/
+	{REG_PRE_PLL_CLK_DIV, 0x22},
+#else
+        {REG_PLL_MULTIPLIER, 0x14}, /*Reduce internal clock to prevent hang Weiting0331*/
+        {REG_PRE_PLL_CLK_DIV, 0x21},
+#endif
+	{OV8810_GAIN, 8}, /*0x30},*/
+	{OV8810_AEC_MSB, 0x04},
+	{OV8810_AEC_LSB, 0xc4}, /*stella 1203*/
+	{REG_ISP_ENABLE_CONTROL_00, 0x20},
+	{0x30b2, 0x13}, /*driving strength*/
+	{0x30a0, 0x40},
+	{0x3098, 0x24},
+	{0x3099, 0x81},
+	{0x309a, 0x64},
+	{0x309b, 0x00},
+	{0x309d, 0x64},
+	{0x309e, 0x2d},
+	{REG_AWB_CTRL_0, 0xc2}, /*set wb manual*/
+	{REG_AWB_CTRL_1, 0x02},
+	{REG_AWB_CTRL_2, 0x04},
+	{REG_AWB_CTRL_8, 0x40},
+	{0x3329, 0xe3}, /*00},*/  /*stella 1203*/
+	{0x3306, 0x00},
+	{0x3316, 0x03},
+	{0x3079, 0x0a},
+	/*stella 1203*/
+	{0x3058, 0x01},
+	{0x3059, 0xa0},
+	{0x306b, 0x00},
+	{0x3065, 0x50},
+	{0x3067, 0x40},
+	{0x3069, 0x80},
+	{0x3071, 0x40},/*50 BLC trigger by gain 40 BLC every frame */
+	{0x3300, 0xef},
+	{0x3334, 0x02},
+	{0x3331, 0x08}, /*BLC level 8813*/ /*stella 1203*/
+	{0x3332, 0x08}, /*8813*/
+	{0x3333, 0x41},
+       /*Stella1221 for adding init size */
+       {0x30f8, 0x45},
+	{REG_FRAME_LENGTH_LINES_MSB,
+	((OV8810_QTR_SIZE_HEIGHT + OV8810_VER_QTR_BLK_LINES) & 0xFF00) >> 8},
+	{REG_FRAME_LENGTH_LINES_LSB,
+	((OV8810_QTR_SIZE_HEIGHT + OV8810_VER_QTR_BLK_LINES) & 0x00FF)},
+	{REG_LINE_LENGTH_PCK_MSB,
+	((OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS) & 0xFF00) >> 8},
+	{REG_LINE_LENGTH_PCK_LSB,
+	((OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS) & 0x00FF)},
+	{REG_X_ADDR_START_HIGH, 0x00},
+	{REG_X_ADDR_START_LOW, 0x04}, /*stella 1203*/
+	{REG_Y_ADDR_START_HIGH, 0x00},
+	{REG_Y_ADDR_START_LOW, 0x00},
+	{REG_X_ADDR_END_HIGH, 0x0c},
+	{REG_X_ADDR_END_LOW, 0xdb}, /*stella 1203*/
+	{REG_Y_ADDR_END_HIGH, 0x09},
+	{REG_Y_ADDR_END_LOW, 0x9f},
+	{REG_X_OUTPUT_SIZE_MSB, (OV8810_QTR_SIZE_WIDTH & 0xFF00) >> 8},
+	{REG_X_OUTPUT_SIZE_LSB, (OV8810_QTR_SIZE_WIDTH & 0x00FF)},
+	{REG_Y_OUTPUT_SIZE_MSB, (OV8810_QTR_SIZE_HEIGHT & 0xFF00) >> 8},
+	{REG_Y_OUTPUT_SIZE_LSB, (OV8810_QTR_SIZE_HEIGHT & 0x00FF)},
+	/*Stella1221 for adding init size */
+	/* {REG_BINNING_CONTROL, 0x00},*/ /*stella 1203*/
+	{OV8810_REG_MUL_GAIN, MUL_GAIN_INIT_VALUE},
+	{0x3082, 0x80},
+	{0x331e, 0x94},
+	{0x331f, 0x6e},
+	{0x3092, 0x00},
+	{0x3094, 0x01},
+	{0x3090, 0x2b}, /* for AN version 8a */ /*changed by Stella for 8813*/
+	{0x30ab, 0x44},
+	{0x3095, 0x0a},
+	{0x308d, 0x00},
+	{0x3082, 0x00},
+	{0x3080, 0x40},
+	{0x30aa, 0x59},
+	{0x30a9, 0x00},
+	{0x30be, 0x08},
+	{0x309f, 0x23},
+	{0x3065, 0x40},
+	{0x3068, 0x00},
+	{0x30bf, 0x80},
+	{0x309c, 0x00},
+	{0x3084, 0x44}, /*added by stella for 8813*/
+	{0x3016, 0x03}, /*added by stella for 8813*/
+	{0x30e9, 0x09}, /*changed by stella for 8813*/
+	{0x3075, 0x29},
+	{0x3076, 0x29},
+	{0x3077, 0x29},
+	{0x3078, 0x29},
+	{0x306a, 0x05},
+	{0x3015, 0x33}, /*changed by stella for 8813*/
+	/*stella 1203 start*/
+	{0x3090, 0x36},
+	{0x333e, 0x00},
+	{0x306a, 0x05},
+	/*stella 1203 end*/
+	{0x3087, 0x41},
+	{0x3090, 0x97}, /*99, QCT=97*/
+	{0x309e, 0x1b},
+	{0x30e3, 0x0e},
+	{0x30f0, 0x00},
+	{0x30f2, 0x00},
+	{0x30f4, 0x90},
+	/*stella 1203 start*/
+	{0x3347, 0x00},
+	{0x3347, 0x00},
+#if 0
+	{0x3092, 0x00}, //marked by QCT
+	{0x30f0, 0x10}, //marked by QCT
+	{0x30f1, 0x56}, //marked by QCT
+	{0x30fb, 0x8e}, //marked by QCT
+	{0x30f3, 0xa7}, //marked by QCT
+#endif
+	{0x3091, 0x08}, /*QCT for 8813*/
+	{0x3090, 0x97}, /*QCT for 8813*/
+	{0x30fb, 0xc9}, /*QCT for 8813*/
+	{0x308d, 0x02},
+	{0x30e7, 0x41},
+	{0x30b3, 0x08},
+	{0x33e5, 0x00},  /*30e5*/
+	{0x350e, 0x40},  /*305e*/
+	{0x301f, 0x00},
+	{0x309f, 0x23},
+	{0x3013, 0xc0},
+	{0x30e1, 0x90},
+	{0x3058, 0x01},
+	{0x3500, 0x40}, /* vsync_new */
+	{REG_BINNING_CONTROL, 0x00}, /*stella 0126*/
+	/*stella 1203 end*/
+};
+
+/*Vincent for LSC calibration*/
+static struct reg_addr_val_pair_struct lsc_table_array[] =
+{
+	{0x3358, 0x1f  },//{0x3358, 0x18},
+	{0x3359, 0x14  },//{0x3359, 0x0f},
+	{0x335a, 0x0f  },//{0x335a, 0x0c},
+	{0x335b, 0x0d  },//{0x335b, 0x0a},
+	{0x335c, 0x0d  },//{0x335c, 0x0a},
+	{0x335d, 0x0f  },//{0x335d, 0x0b},
+	{0x335e, 0x14  },//{0x335e, 0x0d},
+	{0x335f, 0x1d  },//{0x335f, 0x15},
+	{0x3360, 0x0f  },//{0x3360, 0x0b},
+	{0x3361, 0x0a  },//{0x3361, 0x09},
+	{0x3362, 0x07  },//{0x3362, 0x06},
+	{0x3363, 0x06  },//{0x3363, 0x05},
+	{0x3364, 0x06  },//{0x3364, 0x05},
+	{0x3365, 0x07  },//{0x3365, 0x06},
+	{0x3366, 0x09  },//{0x3366, 0x08},
+	{0x3367, 0x0d  },//{0x3367, 0x0b},
+	{0x3368, 0x09  },//{0x3368, 0x07},
+	{0x3369, 0x06  },//{0x3369, 0x05},
+	{0x336a, 0x04  },//{0x336a, 0x03},
+	{0x336b, 0x03  },//{0x336b, 0x02},
+	{0x336c, 0x03  },//{0x336c, 0x02},
+	{0x336d, 0x04  },//{0x336d, 0x03},
+	{0x336e, 0x06  },//{0x336e, 0x04},
+	{0x336f, 0x09  },//{0x336f, 0x06},
+	{0x3370, 0x07  },//{0x3370, 0x05},
+	{0x3371, 0x04  },//{0x3371, 0x04},
+	{0x3372, 0x01  },//{0x3372, 0x01},
+	{0x3373, 0x00  },//{0x3373, 0x00},
+	{0x3374, 0x00  },//{0x3374, 0x00},
+	{0x3375, 0x01  },//{0x3375, 0x01},
+	{0x3376, 0x04  },//{0x3376, 0x03},
+	{0x3377, 0x07  },//{0x3377, 0x05},
+	{0x3378, 0x08  },//{0x3378, 0x05},
+	{0x3379, 0x04  },//{0x3379, 0x03},
+	{0x337a, 0x01  },//{0x337a, 0x01},
+	{0x337b, 0x00  },//{0x337b, 0x00},
+	{0x337c, 0x00  },//{0x337c, 0x00},
+	{0x337d, 0x01  },//{0x337d, 0x00},
+	{0x337e, 0x04  },//{0x337e, 0x02},
+	{0x337f, 0x07  },//{0x337f, 0x05},
+	{0x3380, 0x09  },//{0x3380, 0x06},
+	{0x3381, 0x06  },//{0x3381, 0x04},
+	{0x3382, 0x04  },//{0x3382, 0x03},
+	{0x3383, 0x02  },//{0x3383, 0x02},
+	{0x3384, 0x02  },//{0x3384, 0x01},
+	{0x3385, 0x04  },//{0x3385, 0x02},
+	{0x3386, 0x06  },//{0x3386, 0x03},
+	{0x3387, 0x09  },//{0x3387, 0x05},
+	{0x3388, 0x0f  },//{0x3388, 0x0a},
+	{0x3389, 0x0a  },//{0x3389, 0x07},
+	{0x338a, 0x07  },//{0x338a, 0x05},
+	{0x338b, 0x07  },//{0x338b, 0x04},
+	{0x338c, 0x07  },//{0x338c, 0x04},
+	{0x338d, 0x07  },//{0x338d, 0x05},
+	{0x338e, 0x0a  },//{0x338e, 0x06},
+	{0x338f, 0x0f  },//{0x338f, 0x09},
+	{0x3390, 0x1d  },//{0x3390, 0x12},
+	{0x3391, 0x12  },//{0x3391, 0x0d},
+	{0x3392, 0x0d  },//{0x3392, 0x09},
+	{0x3393, 0x0b  },//{0x3393, 0x08},
+	{0x3394, 0x0b  },//{0x3394, 0x08},
+	{0x3395, 0x0d  },//{0x3395, 0x09},
+	{0x3396, 0x12  },//{0x3396, 0x0c},
+	{0x3397, 0x1a  },//{0x3397, 0x11},
+	{0x3398, 0x0f  },//{0x3398, 0x10},
+	{0x3399, 0x0d  },//{0x3399, 0x10},
+	{0x339a, 0x0e  },//{0x339a, 0x10},
+	{0x339b, 0x0f  },//{0x339b, 0x0e},
+	{0x339c, 0x11  },//{0x339c, 0x0e},
+	{0x339d, 0x0d  },//{0x339d, 0x0f},
+	{0x339e, 0x12  },//{0x339e, 0x0e},
+	{0x339f, 0x0e  },//{0x339f, 0x0f},
+	{0x33a0, 0x0f  },//{0x33a0, 0x0f},
+	{0x33a1, 0x0f  },//{0x33a1, 0x0f},
+	{0x33a2, 0x10  },//{0x33a2, 0x0f},
+	{0x33a3, 0x10  },//{0x33a3, 0x10},
+	{0x33a4, 0x0f  },//{0x33a4, 0x0e},
+	{0x33a5, 0x0d  },//{0x33a5, 0x10},
+	{0x33a6, 0x0f  },//{0x33a6, 0x11},
+	{0x33a7, 0x10  },//{0x33a7, 0x10},
+	{0x33a8, 0x10  },//{0x33a8, 0x10},
+	{0x33a9, 0x0f  },//{0x33a9, 0x0f},
+	{0x33aa, 0x10  },//{0x33aa, 0x0e},
+	{0x33ab, 0x0e  },//{0x33ab, 0x0f},
+	{0x33ac, 0x10  },//{0x33ac, 0x10},
+	{0x33ad, 0x11  },//{0x33ad, 0x10},
+	{0x33ae, 0x11  },//{0x33ae, 0x10},
+	{0x33af, 0x0f  },//{0x33af, 0x0f},
+	{0x33b0, 0x0f  },//{0x33b0, 0x0e},
+	{0x33b1, 0x0d  },//{0x33b1, 0x0f},
+	{0x33b2, 0x0d  },//{0x33b2, 0x0f},
+	{0x33b3, 0x0e  },//{0x33b3, 0x0f},
+	{0x33b4, 0x0f  },//{0x33b4, 0x0f},
+	{0x33b5, 0x10  },//{0x33b5, 0x0f},
+	{0x33b6, 0x12  },//{0x33b6, 0x0e},
+	{0x33b7, 0x0d  },//{0x33b7, 0x0d},
+	{0x33b8, 0x0c  },//{0x33b8, 0x0c},
+	{0x33b9, 0x0c  },//{0x33b9, 0x0c},
+	{0x33ba, 0x0c  },//{0x33ba, 0x0d},
+	{0x33bb, 0x0b  },//{0x33bb, 0x0f},
+	{0x33bc, 0x1b  },//{0x33bc, 0x16},
+	{0x33bd, 0x1b  },//{0x33bd, 0x17},
+	{0x33be, 0x1d  },//{0x33be, 0x17},
+	{0x33bf, 0x1d  },//{0x33bf, 0x17},
+	{0x33c0, 0x1e  },//{0x33c0, 0x17},
+	{0x33c1, 0x1c  },//{0x33c1, 0x14},
+	{0x33c2, 0x1a  },//{0x33c2, 0x17},
+	{0x33c3, 0x17  },//{0x33c3, 0x14},
+	{0x33c4, 0x15  },//{0x33c4, 0x13},
+	{0x33c5, 0x16  },//{0x33c5, 0x13},
+	{0x33c6, 0x19  },//{0x33c6, 0x14},
+	{0x33c7, 0x1e  },//{0x33c7, 0x15},
+	{0x33c8, 0x16  },//{0x33c8, 0x15},
+	{0x33c9, 0x12  },//{0x33c9, 0x12},
+	{0x33ca, 0x10  },//{0x33ca, 0x10},
+	{0x33cb, 0x10  },//{0x33cb, 0x10},
+	{0x33cc, 0x14  },//{0x33cc, 0x12},
+	{0x33cd, 0x19  },//{0x33cd, 0x14},
+	{0x33ce, 0x16  },//{0x33ce, 0x15},
+	{0x33cf, 0x12  },//{0x33cf, 0x12},
+	{0x33d0, 0x10  },//{0x33d0, 0x10},
+	{0x33d1, 0x11  },//{0x33d1, 0x10},
+	{0x33d2, 0x14  },//{0x33d2, 0x12},
+	{0x33d3, 0x1a  },//{0x33d3, 0x14},
+	{0x33d4, 0x18  },//{0x33d4, 0x16},
+	{0x33d5, 0x15  },//{0x33d5, 0x13},
+	{0x33d6, 0x13  },//{0x33d6, 0x12},
+	{0x33d7, 0x14  },//{0x33d7, 0x12},
+	{0x33d8, 0x17  },//{0x33d8, 0x13},
+	{0x33d9, 0x1b  },//{0x33d9, 0x15},
+	{0x33da, 0x18  },//{0x33da, 0x18},
+	{0x33db, 0x1a  },//{0x33db, 0x15},
+	{0x33dc, 0x1b  },//{0x33dc, 0x15},
+	{0x33dd, 0x1b  },//{0x33dd, 0x15},
+	{0x33de, 0x1b  },//{0x33de, 0x15},
+	{0x33df, 0x1c  },//{0x33df, 0x14},
+	{0x3350, 0x06  },//{0x3350, 0x06},
+	{0x3351, 0xab  },//{0x3351, 0xab},
+	{0x3352, 0x05  },//{0x3352, 0x05},
+	{0x3353, 0x00  },//{0x3353, 0x00},
+	{0x3354, 0x04  },//{0x3354, 0x04},
+	{0x3355, 0xf8  },//{0x3355, 0xf8},
+	{0x3356, 0x07  },//{0x3356, 0x07},
+	{0x3357, 0x74  },//{0x3357, 0x74},
+	/* lsc setting on sensor*/
+	{0x3300, 0xff}, /*enable lsc on sensor*/
+	/*move to the last*/
+	{OV8810_REG_MODE_SELECT, OV8810_MODE_SELECT_STREAM},
+};
+
+/*1632x1224; 24MHz MCLK 96MHz PCLK*/
+static struct reg_addr_val_pair_struct ov8810_qtr_settings_array[] =
+{
+	{0x30f8, 0x45},
+	{REG_FRAME_LENGTH_LINES_MSB,
+	((OV8810_QTR_SIZE_HEIGHT + OV8810_VER_QTR_BLK_LINES) & 0xFF00) >> 8},
+	{REG_FRAME_LENGTH_LINES_LSB,
+	((OV8810_QTR_SIZE_HEIGHT + OV8810_VER_QTR_BLK_LINES) & 0x00FF)},
+	{REG_LINE_LENGTH_PCK_MSB,
+	((OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS) & 0xFF00) >> 8},
+	{REG_LINE_LENGTH_PCK_LSB,
+	((OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS) & 0x00FF)},
+	{REG_X_ADDR_START_HIGH, 0x00},
+	{REG_X_ADDR_START_LOW, 0x04}, /*stella 1203*/
+	{REG_Y_ADDR_START_HIGH, 0x00},
+	{REG_Y_ADDR_START_LOW, 0x00},
+	{REG_X_ADDR_END_HIGH, 0x0c},
+	{REG_X_ADDR_END_LOW, 0xd8}, /*stella 1203=db*/ /*QCT:d8*/
+	{REG_Y_ADDR_END_HIGH, 0x09},
+	{REG_Y_ADDR_END_LOW, 0x9f},
+	{REG_X_OUTPUT_SIZE_MSB, (OV8810_QTR_SIZE_WIDTH & 0xFF00) >> 8},
+	{REG_X_OUTPUT_SIZE_LSB, (OV8810_QTR_SIZE_WIDTH & 0x00FF)},
+	{REG_Y_OUTPUT_SIZE_MSB, (OV8810_QTR_SIZE_HEIGHT & 0xFF00) >> 8},
+	{REG_Y_OUTPUT_SIZE_LSB, (OV8810_QTR_SIZE_HEIGHT & 0x00FF)},
+	 /*stella1202 for capture over exposure issue due to user space use 2X line count*/
+	{0x3068, 0x00},  /*changed for color edge, stella 1203*/
+	{0x307e, 0x00},
+	{0x3071, 0x40},/*50 BLC trigger by gain 40 BLC every frame */
+	{REG_ISP_ENABLE_CONTROL_01, 0x0B},
+	{REG_BINNING_CONTROL, 0x00}, //stella0127
+	{0x331c, 0x00},
+	{0x331d, 0x00},
+	{0x308a, 0x02},
+	{0x3072, 0x0d},
+	{0x3319, 0x04},
+	{0x309e, 0x09},
+	{0x300e, 0x05},
+	{0x300f, 0x04},
+	{0x33e4, 0x07},  /*lsc for 2:1 down sampling*/
+};
+
+ /*stella1223 end*/
+
+/* 3280x2456 Sensor Raw; 24MHz MCLK 96MHz PCLK*/
+static struct reg_addr_val_pair_struct ov8810_full_settings_array[] =
+{
+	{0x30f8, 0x40},
+	{REG_FRAME_LENGTH_LINES_MSB,
+	((OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES) & 0xFF00) >> 8},
+	{REG_FRAME_LENGTH_LINES_LSB,
+	((OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES) & 0x00FF)},
+	{REG_LINE_LENGTH_PCK_MSB,
+	((OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS) & 0xFF00) >> 8},
+	{REG_LINE_LENGTH_PCK_LSB,
+	((OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS) & 0x00FF)},
+	{REG_X_ADDR_START_HIGH, 0x00},
+	{REG_X_ADDR_START_LOW, 0x02}, /*stella 1203*/
+	{REG_Y_ADDR_START_HIGH, 0x00},
+	{REG_Y_ADDR_START_LOW, 0x00},
+	{REG_X_ADDR_END_HIGH, 0x0c},
+	{REG_X_ADDR_END_LOW, 0xdd}, /*stella 1203*/
+	{REG_Y_ADDR_END_HIGH, 0x09},
+	{REG_Y_ADDR_END_LOW, 0x9f},
+	{REG_X_OUTPUT_SIZE_MSB, (OV8810_FULL_SIZE_WIDTH & 0xFF00) >> 8},
+	{REG_X_OUTPUT_SIZE_LSB, (OV8810_FULL_SIZE_WIDTH & 0x00FF)},
+	{REG_Y_OUTPUT_SIZE_MSB, (OV8810_FULL_SIZE_HEIGHT & 0xFF00) >> 8},
+	{REG_Y_OUTPUT_SIZE_LSB, (OV8810_FULL_SIZE_HEIGHT & 0x00FF)},
+	/*stella1202 for capture over exposure issue
+	  due to user space use 2X line count */
+	{0x3068, 0x00}, /* changed for color edge stella 1203*/
+	{0x307e, 0x00},
+	{REG_ISP_ENABLE_CONTROL_01, 0x0B},
+	{REG_BINNING_CONTROL, 0x00}, //stella0127
+	{0x331c, 0x28},
+	{0x331d, 0x21},
+	{0x308a, 0x01},
+	{0x3072, 0x01},
+	{0x3319, 0x06},
+	{0x309e, 0x1b},
+	{0x300e, 0x05},
+	{0x300f, 0x04},
+	{0x33e4, 0x02},  /*lsc for full resolution*/
+};
+
+/* AF Tuning Parameters */
+
+static uint16_t ov8810_step_position_table[OV8810_TOTAL_STEPS_NEAR_TO_FAR+1];
+
+static uint8_t ov8810_damping_threshold = 10;
+static uint8_t ov8810_damping_course_step = 4;
+static uint8_t ov8810_damping_fine_step = 10;
+static uint8_t ov8810_damping_time_wait;
+static uint16_t ov8810_focus_debug; /*don't init to 0*/
+static uint16_t ov8810_use_default_damping = 1;
+static uint16_t ov8810_use_threshold_damping = 1; /*set to FALSE if too slow*/
+/*static uint32_t stored_line_length_ratio = 1 * Q8;*/
+
+/*Andy1217 write Line 1 frame ealier before Gain*/
+struct backup_line_gain_struct {
+	uint32_t line;
+	uint8_t mul;
+	uint16_t gain;
+	uint32_t extra_line_length;
+};
+
+static struct backup_line_gain_struct backup_line_gain[2];
+
+static uint16_t write_cnt;
+static uint16_t updated_BLC; /* only set to 0x50 after 1st update again*/
+
+uint8_t S3_to_0 = 0x1; /* 0x9 */
+
+/* static Variables*/
+static uint16_t step_position_table[OV8810_TOTAL_STEPS_NEAR_TO_FAR+1];
+
+
+/* FIXME: Changes from here */
+struct ov8810_work {
+	struct work_struct work;
+};
+
+static struct  ov8810_work *ov8810_sensorw;
+static struct  i2c_client *ov8810_client;
+
+static struct vreg *vreg_af_actuator;
+
+struct ov8810_ctrl {
+	const struct  msm_camera_sensor_info *sensordata;
+
+	uint32_t sensormode;
+	uint32_t fps_divider; 		/* init to 1 * 0x00000400 */
+	uint32_t pict_fps_divider; 	/* init to 1 * 0x00000400 */
+	uint16_t fps;
+
+	int16_t  curr_lens_pos;
+	uint16_t curr_step_pos;
+	uint16_t my_reg_gain;
+	uint32_t my_reg_line_count;
+	uint16_t total_lines_per_frame;
+
+	enum ov8810_resolution_t prev_res;
+	enum ov8810_resolution_t pict_res;
+	enum ov8810_resolution_t curr_res;
+	enum ov8810_test_mode_t  set_test;
+
+	unsigned short imgaddr;
+};
+
+
+static struct ov8810_ctrl *ov8810_ctrl;
+static struct platform_device *ov8810_pdev;
+
+struct ov8810_waitevent{
+	uint32_t waked_up;
+	wait_queue_head_t event_wait;
+};
+static struct ov8810_waitevent ov8810_event;
+
+static DECLARE_WAIT_QUEUE_HEAD(ov8810_wait_queue);
+DEFINE_SEMAPHORE(ov8810_sem);
+
+
+/*=============================================================*/
+
+static int ov8810_i2c_rxdata(unsigned short saddr,
+	unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+	{
+		.addr   = saddr,
+		.flags = 0,
+		.len   = 2,
+		.buf   = rxdata,
+	},
+	{
+		.addr  = saddr,
+		.flags = I2C_M_RD,
+		.len   = length,
+		.buf   = rxdata,
+	},
+	};
+	CDBG("%s: saddr=0x%X\n", __func__, saddr);
+	CDBG("%s: raddr=0x%X\n", __func__, *rxdata);
+
+	if (i2c_transfer(ov8810_client->adapter, msgs, 2) < 0) {
+		pr_err("ov8810_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+	CDBG("%s: rxdata=0x%X\n", __func__, *rxdata);
+
+	return 0;
+}
+static int32_t ov8810_i2c_txdata(unsigned short saddr,
+				 unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txdata,
+		 },
+	};
+	if (i2c_transfer(ov8810_client->adapter, msg, 1) < 0) {
+		pr_err("ov8810_i2c_txdata faild 0x%x\n", ov8810_client->addr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static int32_t ov8810_i2c_read(unsigned short raddr,
+				unsigned short *rdata, int rlen)
+{
+	int32_t rc = 0;
+	unsigned char buf[2];
+	int count = 0;
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (raddr & 0xFF00) >> 8;
+	buf[1] = (raddr & 0x00FF);
+retry:
+	rc = ov8810_i2c_rxdata(ov8810_client->addr, buf, rlen);
+
+	if (rc < 0) {
+		pr_err("ov8810_i2c_read 0x%x failed!\n", raddr);
+		printk(KERN_ERR "starting read retry policy count:%d\n", count);
+		udelay(10);
+		count++;
+		if (count < 20) {
+			if (count > 10)
+				udelay(100);
+		} else
+			return rc;
+		goto retry;
+	}
+
+	*rdata = (rlen == 2 ? buf[0] << 8 | buf[1] : buf[0]);
+	return rc;
+}
+
+
+static int32_t ov8810_i2c_write_b(unsigned short saddr,
+				unsigned short waddr, uint8_t bdata)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[3];
+	int count = 0;
+	CDBG("i2c_write_w_b, addr = 0x%x, val = 0x%x!\n", waddr, bdata);
+
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	buf[2] = bdata;
+
+retry:
+	CDBG("i2c_write_b addr = %d, val = %d\n", waddr, bdata);
+	rc = ov8810_i2c_txdata(saddr, buf, 3);
+
+	if (rc < 0) {
+		pr_err("i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+			 waddr, bdata);
+		pr_err(KERN_ERR "starting read retry policy count:%d\n", count);
+		udelay(10);
+		count++;
+		if (count < 20) {
+			if (count > 10)
+				udelay(100);
+		} else
+			return rc;
+		goto retry;
+	}
+
+	return rc;
+}
+
+
+/*for LSC calibration*/
+static int ov8810_update_lsc_table(struct sensor_cfg_data *cdata)
+{
+	int i = 0;
+	pr_info("[LSC calibration]ov8810_update_lsc_table\n");
+	for (i = 0; i < 144; i++) {
+		ov8810_i2c_write_b(
+			ov8810_client->addr,
+			cdata->cfg.lsctable.lsc_table[i].reg_addr,
+			cdata->cfg.lsctable.lsc_table[i].reg_val);
+		pr_info("[LSC calibration]update_lsc_table: 0x%x, 0x%x\n",
+				cdata->cfg.lsctable.lsc_table[i].reg_addr,
+				cdata->cfg.lsctable.lsc_table[i].reg_val);
+	}
+	/*enable lsc on sensor*/
+	ov8810_i2c_write_b(ov8810_client->addr, 0x3300, 0xff);
+	/*mirror on*/
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30f8, 0x45);
+	/*mirror on*/
+	ov8810_i2c_write_b(ov8810_client->addr, 0x3316, 0x03);
+	return 1;
+
+}
+
+/*20100330 vincent for LSC calibration*/
+static int ov8810_LSC_calibration_set_rawflag(struct sensor_cfg_data *cdata)
+{
+	global_mode = 1;
+	return 1;
+}
+
+#define MAX_FUSE_ID_INFO 11
+static int ov8810_i2c_read_fuseid(struct sensor_cfg_data *cdata)
+{
+	unsigned short fuse_id[MAX_FUSE_ID_INFO];
+	int count = 0;
+
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30d5, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30d6, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30d7, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30d8, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30d9, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30da, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30db, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30dc, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30dd, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30de, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x30df, 0xff);
+	ov8810_i2c_write_b(ov8810_client->addr, 0x303e, 0x55);
+	ov8810_i2c_read(0x30d5, &fuse_id[0], 2);
+	ov8810_i2c_read(0x30d6, &fuse_id[1], 2);
+	ov8810_i2c_read(0x30d7, &fuse_id[2], 2);
+	ov8810_i2c_read(0x30d8, &fuse_id[3], 2);
+	ov8810_i2c_read(0x30d9, &fuse_id[4], 2);
+	ov8810_i2c_read(0x30da, &fuse_id[5], 2);
+	ov8810_i2c_read(0x30db, &fuse_id[6], 2);
+	ov8810_i2c_read(0x30dc, &fuse_id[7], 2);
+	ov8810_i2c_read(0x30dd, &fuse_id[8], 2);
+	ov8810_i2c_read(0x30de, &fuse_id[9], 2);
+	ov8810_i2c_read(0x30df, &fuse_id[10], 2);
+	cdata->cfg.fuse.fuse_id_word1 = (uint32_t) fuse_id[0];
+	cdata->cfg.fuse.fuse_id_word2 = (uint32_t) fuse_id[1];
+	cdata->cfg.fuse.fuse_id_word3 = 0;
+	cdata->cfg.fuse.fuse_id_word4 = 0;
+	for (count = 0; count < MAX_FUSE_ID_INFO; count++)
+		pr_info("Ov8810 Get fuse: fuse_id[%d]: %x\n",
+			count, fuse_id[count]);
+	return 0;
+}
+
+
+static int32_t ov8810_af_i2c_write(uint16_t data)
+{
+	uint8_t code_val_msb, code_val_lsb; /* S3_to_0; */
+	uint32_t rc = 0;
+	/* S3_to_0 = 0x9;  S[3:0] */
+	code_val_msb = data >> 4; /* D[9:4] */
+	code_val_lsb = ((data & 0x000F) << 4) | S3_to_0;
+
+	CDBG("code value = %d ,D[9:4] = %d ,D[3:0] = %d\n",
+		data, code_val_msb, code_val_lsb);
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+				OV8810_AF_MSB, code_val_msb);
+
+	if (rc < 0) {
+		pr_err("Unable to write code_val_msb = %d\n", code_val_msb);
+		return rc;
+	}
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+				OV8810_AF_LSB, code_val_lsb);
+	if (rc < 0) {
+		pr_err("Unable to write code_val_lsb = %disclaimer\n",
+			code_val_lsb);
+		return rc;
+	}
+
+	return rc;
+} /* ov8810_af_i2c_write */
+
+static int32_t ov8810_move_focus(int direction, int32_t num_steps)
+{
+
+	int8_t step_direction;
+	int8_t dest_step_position;
+	uint16_t dest_lens_position, target_dist, small_step;
+	int16_t next_lens_position;
+	int32_t rc = 0;
+
+	if (num_steps == 0) {
+		return rc;
+	}
+
+	if (direction == MOVE_NEAR) {
+		step_direction = 1;
+	} else if (direction == MOVE_FAR) {
+		step_direction = -1;
+	} else {
+		pr_err("Illegal focus direction\n");
+		return -EINVAL;; /* CAMERA_INVALID_PARM; */
+	}
+
+	CDBG("%s, interpolate\n", __func__);
+	dest_step_position =
+		ov8810_ctrl->curr_step_pos + (step_direction * num_steps);
+
+	if (dest_step_position < 0)
+		dest_step_position = 0;
+	else if (dest_step_position > OV8810_TOTAL_STEPS_NEAR_TO_FAR)
+		dest_step_position = OV8810_TOTAL_STEPS_NEAR_TO_FAR;
+
+	dest_lens_position = ov8810_step_position_table[dest_step_position];
+
+	/* Taking small damping steps */
+	target_dist = step_direction *
+		(dest_lens_position - ov8810_ctrl->curr_lens_pos);
+
+	if (target_dist == 0) {
+		return rc;
+	}
+
+	if (ov8810_use_threshold_damping &&
+		(step_direction < 0) &&
+		(target_dist >=
+		ov8810_step_position_table[ov8810_damping_threshold])) {
+
+		/* change to variable */
+		small_step = (uint16_t)(target_dist/ov8810_damping_fine_step);
+		ov8810_damping_time_wait = 1;
+	} else {
+		small_step = (uint16_t)(target_dist/ov8810_damping_course_step);
+		ov8810_damping_time_wait = 4;
+	}
+
+	for (next_lens_position =
+		ov8810_ctrl->curr_lens_pos + (step_direction * small_step);
+		(step_direction * next_lens_position) <=
+		(step_direction * dest_lens_position);
+		next_lens_position += (step_direction * small_step)) {
+
+		if (ov8810_af_i2c_write(next_lens_position) < 0)
+			return -EBUSY;
+
+		ov8810_ctrl->curr_lens_pos = next_lens_position;
+
+		if (ov8810_ctrl->curr_lens_pos != dest_lens_position) {
+			mdelay(ov8810_damping_time_wait);
+		}
+	}
+
+	if (ov8810_ctrl->curr_lens_pos != dest_lens_position) {
+
+		if (ov8810_af_i2c_write(dest_lens_position) < 0) {
+			return -EBUSY;
+		}
+	}
+
+	/* Storing the current lens Position */
+	ov8810_ctrl->curr_lens_pos = dest_lens_position;
+	ov8810_ctrl->curr_step_pos = dest_step_position;
+
+	CDBG("done\n");
+	return rc;
+}
+
+static int32_t ov8810_set_default_focus(uint8_t af_step)
+{
+	int16_t position;
+	int32_t rc = 0;
+	ov8810_damping_time_wait = 4;
+
+	if (ov8810_use_default_damping) {
+
+		/* when lens is uninitialized */
+		if (ov8810_ctrl->curr_lens_pos == -1
+			|| (ov8810_focus_debug == 1)) {
+
+		position = ov8810_step_position_table[ov8810_damping_threshold];
+		rc =  ov8810_af_i2c_write(position);
+
+		if (rc < 0) {
+			return rc;
+		}
+
+		ov8810_ctrl->curr_step_pos = ov8810_damping_threshold;
+		ov8810_ctrl->curr_lens_pos = position;
+		mdelay(ov8810_damping_time_wait);
+		}
+
+		rc = ov8810_move_focus(MOVE_FAR, ov8810_ctrl->curr_step_pos);
+		if (rc < 0)
+			return rc;
+	} else {
+		rc = ov8810_af_i2c_write(ov8810_step_position_table[0]);
+		if (rc < 0)
+			return rc;
+
+		ov8810_ctrl->curr_step_pos = 0;
+		ov8810_ctrl->curr_lens_pos = ov8810_step_position_table[0];
+	}
+
+	return rc;
+}
+
+
+static void ov8810_get_pict_fps(uint16_t fps, uint16_t *pfps)
+{
+	/* input fps is preview fps in Q8 format */
+
+	uint32_t divider, d1, d2;
+
+	uint16_t snapshot_height, preview_height, preview_width, snapshot_width;
+
+	if (ov8810_ctrl->prev_res == QTR_SIZE) {
+		preview_width =
+			OV8810_QTR_SIZE_WIDTH  + OV8810_HRZ_QTR_BLK_PIXELS ;
+		preview_height =
+			OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel] ;
+	} else {
+		/* full size resolution used for preview. */
+		preview_width =
+			OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS ;
+		preview_height =
+			OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES ;
+	}
+
+	if (ov8810_ctrl->pict_res == QTR_SIZE) {
+		snapshot_width =
+			OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS ;
+		snapshot_height =
+			OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel] ;
+
+	} else {
+		snapshot_width =
+			OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS;
+		snapshot_height =
+			OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES;
+	}
+
+	d1 = preview_height * 0x00000400 / snapshot_height;
+	d2 = preview_width * 0x00000400 / snapshot_width;
+
+	divider = (uint32_t) (d1 * d2) / 0x00000400;
+	*pfps = (uint16_t)(fps * divider / 0x00000400);
+
+} /* endof ov8810_get_pict_fps */
+
+static uint16_t ov8810_get_prev_lines_pf(void)
+{
+	if (ov8810_ctrl->prev_res == QTR_SIZE) {
+		return (OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES);
+	}
+}
+
+static uint16_t ov8810_get_prev_pixels_pl(void)
+{
+	if (ov8810_ctrl->prev_res == QTR_SIZE) {
+		return (OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS);
+	} else  {
+		return (OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS);
+}
+}
+
+static uint16_t ov8810_get_pict_lines_pf(void)
+{
+	if (ov8810_ctrl->pict_res == QTR_SIZE) {
+		return (OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES);
+	}
+}
+
+static uint16_t ov8810_get_pict_pixels_pl(void)
+{
+	if (ov8810_ctrl->pict_res == QTR_SIZE) {
+		return (OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS);
+	} else  {
+		return (OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS);
+	}
+}
+
+static uint32_t ov8810_get_pict_max_exp_lc(void)
+{
+	if (ov8810_ctrl->pict_res == QTR_SIZE) {
+		return (OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES);
+	}
+}
+
+static int32_t ov8810_set_fps(struct fps_cfg *fps)
+{
+	int32_t rc = 0;
+	ov8810_ctrl->fps_divider = fps->fps_div;
+	ov8810_ctrl->pict_fps_divider = fps->pict_fps_div;
+	ov8810_ctrl->fps = fps->f_mult;
+	return rc;
+}
+
+
+static int32_t ov8810_write_exp_gain
+			(uint16_t mul, uint16_t gain, uint32_t line)
+{
+	uint16_t aec_msb;
+	uint16_t aec_lsb;
+	int32_t rc = 0;
+	uint32_t total_lines_per_frame;
+	uint32_t total_pixels_per_line;
+	/*uint32_t line_length_ratio = 1 * Q8;*/
+	/**uint8_t ov8810_offset = 2; */
+	uint32_t extra_line_length = 0;
+	uint16_t extra_line_msb = 0;
+	uint16_t extra_line_lsb = 0;
+	uint32_t phy_line = 0;
+	uint8_t phy_mul = MUL_GAIN_INIT_VALUE;
+	uint16_t phy_gain = 0;
+	uint32_t phy_extra_line_length = 0;
+	const uint16_t postpone_frames = 4;
+	uint16_t do_write = 1; /* assume do things */
+	uint16_t ori_reg_mul_gain;
+	uint8_t ori_reg_mul_gain_8bit;
+
+	CDBG("%s start, mul = %d gain = %d line = %d\n", __func__,
+		mul, gain, line);
+
+	if (ov8810_ctrl->curr_res == QTR_SIZE) {
+		total_lines_per_frame =
+			(OV8810_QTR_SIZE_HEIGHT + ov8810_ver_qtr_blk_lines_array[cam_mode_sel]);
+		total_pixels_per_line =
+			OV8810_QTR_SIZE_WIDTH + OV8810_HRZ_QTR_BLK_PIXELS;
+	} else {
+		total_lines_per_frame =
+			(OV8810_FULL_SIZE_HEIGHT + OV8810_VER_FULL_BLK_LINES);
+		total_pixels_per_line =
+			OV8810_FULL_SIZE_WIDTH + OV8810_HRZ_FULL_BLK_PIXELS;
+	}
+
+	if (line > total_lines_per_frame - 4) {
+		extra_line_length =
+			(uint32_t)(line - (total_lines_per_frame-4));
+		line = total_lines_per_frame - 4;
+	} else {
+		extra_line_length = (uint16_t)0;
+	}
+
+	phy_line = line;
+	phy_mul = mul;
+	phy_gain = gain;
+	phy_extra_line_length = extra_line_length;
+
+	/* postpone writing gain only apply to preview */
+	if (ov8810_ctrl->sensormode == SENSOR_PREVIEW_MODE) {
+
+	/* need time to wait for aec stable (prevent black preview) */
+	mdelay(6);
+
+	CDBG("Stella: write_cnt=%d, pre_line = %d, line = %d," \
+		"pre_mul = %d mul = %d," \
+		"pre_gain = %d gain = %d," \
+		"pre_extra_line_length =%d extra_line_length = %d\n",
+		write_cnt,
+		backup_line_gain[1].line, line,
+		backup_line_gain[1].mul, mul,
+		backup_line_gain[1].gain, gain,
+		backup_line_gain[1].extra_line_length, extra_line_length);
+
+	if (write_cnt == 0 && (
+		backup_line_gain[1].line != line ||
+		backup_line_gain[1].mul != mul ||
+		backup_line_gain[1].gain != gain ||
+		backup_line_gain[1].extra_line_length != extra_line_length)) {
+
+		backup_line_gain[1].line = line;
+		backup_line_gain[1].mul = mul;
+		backup_line_gain[1].gain = gain;
+		backup_line_gain[1].extra_line_length = extra_line_length;
+		phy_line = backup_line_gain[1].line;
+		phy_mul = backup_line_gain[0].mul;
+		phy_gain = backup_line_gain[0].gain;
+		phy_extra_line_length = backup_line_gain[0].extra_line_length;
+		write_cnt++;
+	} else if (write_cnt >= 1 && write_cnt < postpone_frames) {
+		phy_line = backup_line_gain[1].line;
+		phy_mul = backup_line_gain[1].mul;
+		phy_gain = backup_line_gain[1].gain;
+		phy_extra_line_length = backup_line_gain[1].extra_line_length;
+
+		CDBG("updated_BLC = %d\n", updated_BLC);
+		if (updated_BLC == 5) {
+			/*50 BLC trigger by gain 40 BLC every frame */
+			pr_info("### BLC to 0x50 ###\n");
+#if 0
+			ov8810_i2c_write_b(ov8810_client->addr, 0x3071, 0x50);
+#endif
+		}
+		if (updated_BLC <= 5)
+			updated_BLC++;
+
+		if (write_cnt > 1)
+			do_write = 0;
+		write_cnt++;
+	} else {
+		write_cnt = 0;
+		do_write = 0;
+	}
+
+	if (do_write) {
+		backup_line_gain[0].line = phy_line;
+		backup_line_gain[0].mul = phy_mul;
+		backup_line_gain[0].gain = phy_gain;
+		backup_line_gain[0].extra_line_length = phy_extra_line_length;
+	}
+
+	}
+#if 0
+	pr_info("Stella: backup_line_gain[0].line = %d\n",
+		backup_line_gain[0].line);
+	pr_info("Stella: backup_line_gain[0].mul = %d\n",
+		backup_line_gain[0].mul);
+	pr_info("Stella: backup_line_gain[0].gain = %d\n",
+		backup_line_gain[0].gain);
+	pr_info("Stella: backup_line_gain[0].extra_line_length = %d\n",
+		backup_line_gain[0].extra_line_length);
+	pr_info("Stella: backup_line_gain[1].line = %d\n",
+		backup_line_gain[1].line);
+	pr_info("Stella: backup_line_gain[1].mul = %d\n",
+		backup_line_gain[1].mul);
+	pr_info("Stella: backup_line_gain[1].gain = %d\n",
+		backup_line_gain[1].gain);
+	pr_info("Stella: backup_line_gain[1].extra_line_length = %d\n",
+		backup_line_gain[1].extra_line_length);
+
+	pr_info("Stella: phy_line=%d\n", phy_line);
+	pr_info("Stella: phy_gain=%d\n", phy_gain);
+	pr_info("Stella: phy_extra_line_length=%d\n", phy_extra_line_length);
+#endif
+
+	extra_line_msb = (uint16_t)(phy_extra_line_length & 0xFF00) >> 8;
+	extra_line_lsb = (uint16_t)(phy_extra_line_length & 0x00FF);
+
+	aec_msb = (uint16_t)(phy_line & 0xFF00) >> 8;
+	aec_lsb = (uint16_t)(phy_line & 0x00FF);
+
+	if (!do_write)
+		return rc;
+
+/*Move the read function out of group update to prevent hang Weiting0331*/
+	rc = ov8810_i2c_read(OV8810_REG_MUL_GAIN,
+		&ori_reg_mul_gain, 2);
+	if (rc < 0) {
+		pr_err("read OV8810_REG_MUL_GAIN fail\n");
+		return rc;
+	}
+
+
+	/* since we do STREAM ON here, don't do group update for snapshot */
+	if (ov8810_ctrl->sensormode != SENSOR_SNAPSHOT_MODE) {
+		/*for group update top*/
+		/* weiting0414 prevent capture hang, enable 0x30b7[2] */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30b7, 0x8c);
+		if (rc < 0)
+			return rc;
+	}
+
+	/* FIXME: prevent black preview by restoring 0x30bf -> 0x80 */
+	rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30bf, 0x80);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_AEC_MSB, (uint8_t)aec_msb);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_AEC_LSB, (uint8_t)aec_lsb);
+	if (rc < 0)
+		return rc;
+
+	ori_reg_mul_gain_8bit =
+		(uint8_t)((ori_reg_mul_gain & 0xFF00) >> 8);
+	CDBG("%s, read OV8810_REG_MUL_GAIN ori_reg_mul_gain = %x\n",
+		__func__, ori_reg_mul_gain_8bit);
+	ori_reg_mul_gain_8bit =
+		(ori_reg_mul_gain_8bit & 0xFC) | (phy_mul & 0x03);
+	CDBG("%s, read OV8810_REG_MUL_GAIN ori_reg_mul_gain = %x\n",
+		__func__, ori_reg_mul_gain_8bit);
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+		OV8810_REG_MUL_GAIN, ori_reg_mul_gain_8bit);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+		OV8810_GAIN, (uint8_t)phy_gain);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+		REG_EXTRA_VSYNC_WIDTH_MSB, (uint8_t)extra_line_msb);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+		REG_EXTRA_VSYNC_WIDTH_LSB, (uint8_t)extra_line_lsb);
+	if (rc < 0)
+		return rc;
+
+	if (ov8810_ctrl->sensormode != SENSOR_SNAPSHOT_MODE) {
+		/* for group update bottom */
+		/* weiting0414 prevent capture hang , enable 0x30b7[2] */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30b7, 0x84);
+		if (rc < 0)
+			return rc;
+
+		/* for group update enable */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30ff, 0xff);
+		if (rc < 0)
+			return rc;
+		/* weiting0414 prevent capture hang ,
+			retry I2C write to make sure enable */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30ff, 0xff);
+		if (rc < 0)
+			return rc;
+	}
+
+	if (ov8810_ctrl->sensormode == SENSOR_RAW_SNAPSHOT_MODE) {
+	    pr_info("sleep 500 ms for safety raw snapshot");
+		msleep(500);
+    }
+
+	/* STREAM ON for SNAPSHOT */
+	if (ov8810_ctrl->sensormode == SENSOR_SNAPSHOT_MODE) {
+		pr_info("ov8810_ctrl: STREAM ON for SNAPSHOT\n");
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_REG_MODE_SELECT,
+			OV8810_MODE_SELECT_STREAM);
+		if (rc < 0)
+			return rc;
+		msleep(50);
+	}
+
+	/*stored_line_length_ratio = line_length_ratio;*/
+	return rc;
+
+} /* endof ov8810_write_exp_gain*/
+
+/* ### this function is not called for userspace ### */
+static int32_t ov8810_set_pict_exp_gain
+			(uint16_t mul, uint16_t gain, uint32_t line)
+{
+	int32_t rc = 0;
+	rc = ov8810_write_exp_gain(mul, gain, line);
+	return rc;
+} /* endof ov8810_set_pict_exp_gain*/
+
+/* remove test code */
+#if 0
+static int32_t ov8810_test(enum ov8810_test_mode_t mo)
+{
+	int32_t rc = 0;
+	if (mo == TEST_OFF) {
+		return rc;
+	}
+
+	/* Activate  the Color bar test pattern */
+	if (mo == TEST_1) {
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_COLOR_BAR_ENABLE_REG, 0xa0);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			0x3085, 0x20);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			0x306c, 0x00);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_COLOR_BAR_PATTERN_SEL_REG, 0x02);
+		if (rc < 0) {
+			return rc;
+		}
+	}
+
+	return rc;
+
+}
+#endif
+
+
+uint32_t Crc32CheckSumByte(uint8_t *pData, uint32_t uiLen, uint32_t preValue)
+{
+	const uint32_t crc32table[256] = {
+		/* 0x00 */ 0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+		/* 0x04 */ 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+		/* 0x08 */ 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+		/* 0x0C */ 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+		/* 0x10 */ 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+		/* 0x14 */ 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+		/* 0x18 */ 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+		/* 0x1C */ 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+		/* 0x20 */ 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+		/* 0x24 */ 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+		/* 0x28 */ 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+		/* 0x2C */ 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+		/* 0x30 */ 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+		/* 0x34 */ 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+		/* 0x38 */ 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+		/* 0x3C */ 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+		/* 0x40 */ 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+		/* 0x44 */ 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+		/* 0x48 */ 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+		/* 0x4C */ 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+		/* 0x50 */ 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+		/* 0x54 */ 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+		/* 0x58 */ 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+		/* 0x5C */ 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+		/* 0x60 */ 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+		/* 0x64 */ 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+		/* 0x68 */ 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+		/* 0x6C */ 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+		/* 0x70 */ 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+		/* 0x74 */ 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+		/* 0x78 */ 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+		/* 0x7C */ 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+		/* 0x80 */ 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+		/* 0x84 */ 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+		/* 0x88 */ 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+		/* 0x8C */ 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+		/* 0x90 */ 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+		/* 0x94 */ 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+		/* 0x98 */ 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+		/* 0x9C */ 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+		/* 0xA0 */ 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+		/* 0xA4 */ 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+		/* 0xA8 */ 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+		/* 0xAC */ 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+		/* 0xB0 */ 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+		/* 0xB4 */ 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+		/* 0xB8 */ 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+		/* 0xBC */ 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+		/* 0xC0 */ 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+		/* 0xC4 */ 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+		/* 0xC8 */ 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+		/* 0xCC */ 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+		/* 0xD0 */ 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+		/* 0xD4 */ 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+		/* 0xD8 */ 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+		/* 0xDC */ 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+		/* 0xE0 */ 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+		/* 0xE4 */ 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+		/* 0xE8 */ 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+		/* 0xEC */ 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+		/* 0xF0 */ 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+		/* 0xF4 */ 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+		/* 0xF8 */ 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+		/* 0xFC */ 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,};
+	uint32_t i, CheckSum, cvalue;
+
+	CheckSum = preValue;
+	for (i = 0; i < uiLen; i++) {
+		cvalue = *pData;
+		CheckSum =
+			(CheckSum>>8) ^
+			crc32table[(CheckSum & 0xFF) ^
+			(cvalue & 0xFF)];
+		pData++;
+	}
+	return CheckSum;
+}
+
+static int32_t HTC_update_ov8810_lsc_registers(void)
+{
+	int i;
+	struct awb_lsc_struct_type *awb_lsc_data_ptr;
+	awb_lsc_data_ptr = (struct awb_lsc_struct_type *)get_cam_awb_cal();
+
+	for (i = 0; i < 8; i++) {
+		pr_info(KERN_INFO"[LSC calibration]  read AWB table 0x%x\n",
+			awb_lsc_data_ptr->caBuff[i]);
+	}
+
+	for (i = 0; i < LSC_table_length; i++) {
+		pr_info("[LSC calibration]  read LSC table 0x%x, 0x%x\n",
+			awb_lsc_data_ptr->LSC_table[i].reg_addr,
+			awb_lsc_data_ptr->LSC_table[i].reg_val);
+	}
+
+       if (awb_lsc_data_ptr->LSC_table_CRC ==
+		Crc32CheckSumByte(
+			(uint8_t *) awb_lsc_data_ptr->LSC_table,
+			150 * sizeof(struct reg_addr_val_pair_struct), 0) &&
+		awb_lsc_data_ptr->LSC_table_CRC != 0) {
+
+		pr_info("[LSC calibration]checksum pass,use calibrated LSC\n");
+
+		for (i = 0; i < LSC_table_length; i++) {
+			ov8810_i2c_write_b(ov8810_client->addr,
+				awb_lsc_data_ptr->LSC_table[i].reg_addr,
+				awb_lsc_data_ptr->LSC_table[i].reg_val);
+		}
+		/*enable lsc on sensor*/
+		ov8810_i2c_write_b(ov8810_client->addr, 0x3300, 0xff);
+		/*move to the last*/
+		ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_REG_MODE_SELECT, OV8810_MODE_SELECT_STREAM);
+
+	} else {/*use default LSC table*/
+	      pr_info("[LSC calibration]checksum fail\n");
+	      return false;
+	}
+	return true;
+}
+
+static int32_t initialize_ov8810_registers(void)
+{
+	int32_t i, array_length;
+	int32_t rc = 0;
+
+	mdelay(5);
+	ov8810_i2c_write_b(
+		ov8810_client->addr,
+		OV8810_REG_SOFTWARE_RESET,
+		OV8810_SOFTWARE_RESET);
+	mdelay(5);
+	ov8810_i2c_write_b(
+		ov8810_client->addr,
+		OV8810_REG_MODE_SELECT,
+		OV8810_MODE_SELECT_SW_STANDBY);
+	mdelay(1);
+	array_length = sizeof(ov8810_init_settings_array) /
+		sizeof(ov8810_init_settings_array[0]);
+
+	/* Configure sensor for Preview mode and Snapshot mode */
+	for (i = 0; i < array_length; i++) {
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			ov8810_init_settings_array[i].reg_addr,
+			ov8810_init_settings_array[i].reg_val);
+		if (rc < 0)
+			return rc;
+	}
+
+	/*use calibrated LSC table*/
+	if (HTC_update_ov8810_lsc_registers()) {
+		pr_info("[LSC calibration] use calibrated LSC table done!\n");
+	} else {/*use default LSC table*/
+		array_length =
+			sizeof(lsc_table_array) / sizeof(lsc_table_array[0]);
+
+		for (i = 0; i < array_length; i++) {
+			rc = ov8810_i2c_write_b(ov8810_client->addr,
+				lsc_table_array[i].reg_addr,
+				lsc_table_array[i].reg_val);
+		}
+		pr_info("[LSC calibration] use default LSC table done\n");
+	}
+	return rc;
+} /* end of initialize_ov8810_ov8m0vc_registers. */
+
+static int32_t ov8810_setting(int rt)
+{
+	int32_t rc = 0;
+	int32_t i, array_length;
+	static int16_t did_snapshot;
+	uint16_t ori_reg_mul_gain;
+	uint8_t ori_reg_mul_gain_8bit;
+
+	uint16_t i2c_ret = 0;
+
+	write_cnt = 0;
+
+	pr_info("ov8810_setting rt = %d\n", rt);
+
+	if (rt == FULL_SIZE) {
+
+		ov8810_i2c_read(0x30b7, &i2c_ret, 1);
+		pr_info("0x30b7, i2c_ret = 0x%X\n", i2c_ret);
+    /*Retry writing group update bottom to ensure capture settings can be updated Weiting0331*/
+		while (i2c_ret != 0x84) {
+
+		/* for group update bottom */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30b7, 0x84);
+		if (rc < 0)
+			return rc;
+
+		/* for group update enable */
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30ff, 0xff);
+		if (rc < 0)
+			return rc;
+
+		msleep(50);
+		ov8810_i2c_read(0x30b7, &i2c_ret, 1);
+		pr_info("retry 0x30b7, i2c_ret = 0x%X\n", i2c_ret);
+		};
+	}
+
+	rc = ov8810_i2c_write_b(ov8810_client->addr,
+		OV8810_REG_MODE_SELECT,
+		OV8810_MODE_SELECT_SW_STANDBY);
+	if (rc < 0) {
+		return rc;
+	}
+
+	ov8810_i2c_read(OV8810_REG_MODE_SELECT, &i2c_ret, 1);
+	pr_info("OV8810_REG_MODE_SELECT, i2c_ret = 0x%X\n", i2c_ret);
+
+	switch (rt) {
+
+	case QTR_SIZE:
+
+		array_length = sizeof(ov8810_qtr_settings_array) /
+			sizeof(ov8810_qtr_settings_array[0]);
+
+		/* Configure sensor for XGA preview mode */
+		for (i = 0; i < array_length; i++) {
+			rc = ov8810_i2c_write_b(ov8810_client->addr,
+				ov8810_qtr_settings_array[i].reg_addr,
+				ov8810_qtr_settings_array[i].reg_val);
+
+			if (rc < 0) {
+				return rc;
+			}
+		}
+
+/* reconfigure the qtr height to adjust frame rate */
+{
+		uint16_t fl_line = 0;
+		fl_line = OV8810_QTR_SIZE_HEIGHT +
+			ov8810_ver_qtr_blk_lines_array[cam_mode_sel];
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			REG_FRAME_LENGTH_LINES_MSB,
+			(fl_line & 0xFF00) >> 8);
+		if (rc < 0)
+			return rc;
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			REG_FRAME_LENGTH_LINES_LSB,
+			fl_line & 0x00FF);
+		if (rc < 0)
+			return rc;
+#if 0
+		if (cam_mode_sel > 0)  {
+		pr_info("andy write binning ctrl 0x00, cam_mode_sel %d\n", cam_mode_sel);
+		    rc = ov8810_i2c_write_b(ov8810_client->addr, //weiting ori c0
+			   REG_BINNING_CONTROL, 0x00);
+		if (rc < 0)
+			return rc;
+
+		}
+#endif
+}
+
+
+#if 1 /* this is supposed to prevent abnormal color when restart preview */
+
+		if (!did_snapshot)
+		{
+			memset(&backup_line_gain, 0,
+				sizeof(struct backup_line_gain_struct));
+			backup_line_gain[0].line = 0x4c4;
+			backup_line_gain[0].mul = MUL_GAIN_INIT_VALUE;
+			backup_line_gain[0].gain = 8; /*0x30;*/
+			backup_line_gain[0].extra_line_length = 0;
+		}
+
+		CDBG("backup_line_gain[0].line = %d" \
+			"backup_line_gain[0].mul = %d" \
+			"backup_line_gain[0].gain = %d" \
+			"backup_line_gain[0].extra_line_length = %d",
+			backup_line_gain[0].line,
+			backup_line_gain[0].mul,
+			backup_line_gain[0].gain,
+			backup_line_gain[0].extra_line_length);
+
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_AEC_MSB,
+			(uint8_t)((backup_line_gain[0].line & 0xFF00) >> 8));
+		if (rc < 0)
+			return rc;
+
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_AEC_LSB,
+			(uint8_t)(backup_line_gain[0].line & 0x00FF));
+		if (rc < 0)
+			return rc;
+
+		rc = ov8810_i2c_read(OV8810_REG_MUL_GAIN, &ori_reg_mul_gain, 2);
+		if (rc < 0) {
+			pr_err("read OV8810_REG_MUL_GAIN fail\n");
+			return rc;
+		}
+		ori_reg_mul_gain_8bit =
+			(uint8_t)((ori_reg_mul_gain & 0xFF00)>>8);
+		CDBG("%s, read OV8810_REG_MUL_GAIN ori_reg_mul_gain = %x\n",
+			__func__, ori_reg_mul_gain_8bit);
+		ori_reg_mul_gain_8bit =
+			(ori_reg_mul_gain_8bit & 0xFC) |
+			(backup_line_gain[0].mul & 0x03);
+		CDBG("%s, read OV8810_REG_MUL_GAIN ori_reg_mul_gain = %x\n",
+			__func__, ori_reg_mul_gain_8bit);
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_REG_MUL_GAIN, ori_reg_mul_gain_8bit);
+		if (rc < 0)
+			return rc;
+
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_GAIN,
+			(uint8_t)(backup_line_gain[0].gain & 0x00FF));
+		if (rc < 0)
+			return rc;
+
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			REG_EXTRA_VSYNC_WIDTH_MSB,
+			(uint8_t)((backup_line_gain[0].extra_line_length
+			& 0xFF00) >> 8));
+		if (rc < 0)
+			return rc;
+
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			REG_EXTRA_VSYNC_WIDTH_LSB,
+			(uint8_t)(backup_line_gain[0].extra_line_length
+			& 0x00FF));
+		if (rc < 0)
+			return rc;
+
+#endif
+		did_snapshot = 0;
+
+		ov8810_ctrl->curr_res = QTR_SIZE;
+
+		break;
+
+	case FULL_SIZE:
+		if (rc < 0)
+			return rc;
+		array_length = sizeof(ov8810_full_settings_array) /
+			sizeof(ov8810_full_settings_array[0]);
+		/* Configure sensor for QXGA capture mode */
+		for (i = 0; i < array_length; i++) {
+			rc = ov8810_i2c_write_b(ov8810_client->addr,
+				ov8810_full_settings_array[i].reg_addr,
+				ov8810_full_settings_array[i].reg_val);
+			if (rc < 0)
+				return rc;
+		}
+		did_snapshot = 1;
+		ov8810_ctrl->curr_res = FULL_SIZE;
+		break;
+
+	default:
+		rc = -EFAULT;
+		return rc;
+	}
+
+	/*disablt LSC for calibration*/
+	pr_info("[LSC calibration] global_mode=%d!!!!\n", global_mode);
+	/*take raw picture for LSC calibration*/
+	if (global_mode) {
+		/*disable sensor LSC*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x3300, 0xef);
+		/*mirror off*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x30f8, 0x00);
+		/*mirror off*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x3316, 0x02);
+		pr_info("[LSC calibration]turn off LSC!Mirror On\n");
+
+		/*fix gain & linecount*/
+		/*Gain=0x9,exp=008d*/
+		/*so luma taget = 100 to mfg light source*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x3000, 0x9);
+		/*AEC_MSB*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x3002, 0x00);
+		/*AEC_LSB*/
+		rc = ov8810_i2c_write_b(ov8810_client->addr, 0x3003, 0x8d);
+		pr_info("[LSC calibration]fix gain & linecount\n");
+		global_mode = 0;
+	}
+
+	if (ov8810_ctrl->sensormode != SENSOR_SNAPSHOT_MODE) {
+		msleep(50);
+		rc = ov8810_i2c_write_b(ov8810_client->addr,
+			OV8810_REG_MODE_SELECT,
+			OV8810_MODE_SELECT_STREAM);
+		if (rc < 0)
+			return rc;
+
+		updated_BLC = 0;
+	}
+
+/* remove test code
+	rc = ov8810_test(ov8810_ctrl->set_test);
+	if (rc < 0)
+		return rc;
+*/
+
+	return rc;
+} /*endof  ov8810_setting*/
+
+static int32_t ov8810_video_config(int mode)
+{
+	int32_t rc = 0;
+	static int pre_sel = 0;
+	int cur_sel = (cam_mode_sel > 1)?1:0;
+
+	ov8810_ctrl->sensormode = mode;
+
+	pr_info("%s cam_mode_sel %d cur_sel %d \n", __func__, cam_mode_sel, cur_sel);
+
+	if (ov8810_ctrl->curr_res != ov8810_ctrl->prev_res
+		|| pre_sel != cur_sel
+		)  {
+	       rc = ov8810_setting(ov8810_ctrl->prev_res);
+	       if (rc < 0)
+	               return rc;
+
+	} else {
+	       ov8810_ctrl->curr_res = ov8810_ctrl->prev_res;
+	}
+
+	pre_sel = cur_sel;
+
+	ov8810_ctrl->sensormode = mode;
+
+	return rc;
+
+} /*end of ov354_video_config*/
+
+static int32_t ov8810_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	ov8810_ctrl->sensormode = mode;
+
+	if (ov8810_ctrl->curr_res != ov8810_ctrl->pict_res) {
+		rc = ov8810_setting(ov8810_ctrl->pict_res);
+		if (rc < 0)
+			return rc;
+	} else {
+		ov8810_ctrl->curr_res = ov8810_ctrl->pict_res;
+	}
+	ov8810_ctrl->sensormode = mode;
+
+	return rc;
+
+} /*end of ov8810_snapshot_config*/
+
+static int32_t ov8810_raw_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	ov8810_ctrl->sensormode = mode;
+	if (ov8810_ctrl->curr_res != ov8810_ctrl->pict_res) {
+		rc = ov8810_setting(ov8810_ctrl->pict_res);
+		if (rc < 0)
+			return rc;
+	} else {
+		ov8810_ctrl->curr_res = ov8810_ctrl->pict_res;
+	} /* Update sensor resolution */
+
+	ov8810_ctrl->sensormode = mode;
+
+	return rc;
+
+} /*end of ov8810_raw_snapshot_config*/
+
+static int32_t ov8810_set_sensor_mode(int mode,
+	int res)
+{
+	int32_t rc = 0;
+	struct msm_camera_sensor_info *sinfo = ov8810_pdev->dev.platform_data;
+
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		rc = ov8810_video_config(mode);
+		break;
+
+	case SENSOR_SNAPSHOT_MODE:
+		pr_info("KPI PA: start sensor snapshot config: %d\n", __LINE__);
+		sinfo->kpi_sensor_start = ktime_to_ns(ktime_get());
+		rc = ov8810_snapshot_config(mode);
+		break;
+
+	case SENSOR_RAW_SNAPSHOT_MODE:
+		/*global_mode = 1; //20100330 vincent lsc calibration*/
+		pr_info("KPI PA: start sensor snapshot config: %d\n", __LINE__);
+		sinfo->kpi_sensor_start = ktime_to_ns(ktime_get());
+		rc = ov8810_raw_snapshot_config(mode);
+		break;
+
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static int32_t ov8810_power_down(void)
+{
+	return 0;
+}
+
+static int ov8810_probe_read_id(const struct msm_camera_sensor_info *data)
+{
+	int32_t rc = 0;
+	uint16_t  chipidh = 0; /*, chipidl;*/
+	uint16_t  def_chipid = 0;
+	msleep(20);
+	pr_info("%s, ov8810_probe_init_sensor 1\n", __func__);
+	/* 3. Read sensor Model ID: */
+	if (ov8810_i2c_read(OV8810_PIDH_REG, &chipidh, 2) < 0) {
+		rc = -1;
+		pr_err("read sensor id fail\n");
+	}
+
+	pr_info("ov8810 model_id + ver = 0x%x\n", chipidh);
+
+	/* 4. Compare sensor ID to OV8810 ID: */
+	def_chipid = (((OV8810_PID << 8) & 0xFF00) + (OV8810_VER & 0x00FF));
+	pr_info("%s, Expected id=0x%x\n", __func__, def_chipid);
+
+	if (chipidh < def_chipid) {
+		rc = -ENODEV;
+		pr_err("read sensor id incorrect\n");
+	}
+
+	pr_info("%s, vreg_get vreg_af_actuator\n", __func__);
+	vreg_af_actuator = vreg_get(0, "gp5");
+	if (IS_ERR(vreg_af_actuator))
+		return PTR_ERR(vreg_af_actuator);
+
+	data->camera_set_source(MAIN_SOURCE);
+	pr_info(" ov8810_probe_init_sensor finishes\n");
+	return rc;
+}
+
+static int ov8810_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+
+	int i;
+	int32_t  rc = 0;
+	/*stella0122*/
+	uint16_t ov8810_nl_region_boundary = 5; /*3;*/
+	uint16_t ov8810_nl_region_code_per_step = 35; /*101;*/
+	uint16_t ov8810_l_region_code_per_step = 20; /*18;*/
+	int timeout;
+	pr_info("Calling ov8810_sensor_open_init\n");
+
+	down(&ov8810_sem);
+
+	if (data == NULL) {
+		pr_info("data is a NULL pointer\n");
+		return -EINVAL;
+	}
+	/*check whether resume done*/
+	timeout = wait_event_interruptible_timeout(
+		ov8810_event.event_wait,
+		ov8810_event.waked_up,
+		30*HZ);
+	pr_info("wait event : %d timeout:%d\n", ov8810_event.waked_up, timeout);
+	if (timeout == 0) {
+		up(&ov8810_sem);
+		return rc;
+	}
+	msm_camio_probe_on(ov8810_pdev);
+	ov8810_ctrl = kzalloc(sizeof(struct ov8810_ctrl), GFP_KERNEL);
+	if (!ov8810_ctrl) {
+		pr_err("ov8810_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+	ov8810_ctrl->curr_lens_pos = -1;
+	ov8810_ctrl->fps_divider = 1 * 0x00000400;
+	ov8810_ctrl->pict_fps_divider = 1 * 0x00000400;
+	ov8810_ctrl->set_test = TEST_OFF;
+	ov8810_ctrl->prev_res = QTR_SIZE;
+	ov8810_ctrl->pict_res = FULL_SIZE;
+	ov8810_ctrl->curr_res = INVALID_SIZE;
+	if (data)
+		ov8810_ctrl->sensordata = data;
+
+	/*switch pclk and mclk between main cam and 2nd cam*/
+	/*only for supersonic*/
+	pr_info("doing clk switch (ov8810)\n");
+	if(data->camera_clk_switch != NULL)
+		data->camera_clk_switch();
+
+	/*PWD config*/
+	pr_info("%s, GPIO(%d) sensor_pwd 0\n", __func__, data->sensor_pwd);
+	rc = gpio_request(data->sensor_pwd, "ov8810");
+	if (!rc)
+		gpio_direction_output(data->sensor_pwd, 0);
+	else
+		pr_err("GPIO (%d) request faile\n", data->sensor_pwd);
+	gpio_free(data->sensor_pwd);
+	mdelay(3);
+
+	/* enable mclk first */
+	msm_camio_clk_rate_set(OV8810_DEFAULT_CLOCK_RATE);
+	msm_camio_camif_pad_reg_reset();
+	msleep(3);
+	/*Pull reset*/
+	rc = gpio_request(data->sensor_reset, "ov8810");
+	if (!rc)
+		gpio_direction_output(data->sensor_reset, 1);
+	else
+		pr_err("GPIO (%d) request faile\n", data->sensor_reset);
+	gpio_free(data->sensor_reset);
+	msleep(20);
+	/*read sensor id*/
+	rc = ov8810_probe_read_id(data);
+
+	ov8810_ctrl->sensormode = SENSOR_PREVIEW_MODE ;
+
+	pr_info("%s, initialize_ov8810_registers: %d\n", __func__, __LINE__);
+	if (rc < 0)
+		goto init_fail;
+	#if 1 /*move to probe up sensor*/
+      /* Initialize Sensor registers */
+	rc = initialize_ov8810_registers();
+	if (rc < 0)
+		return rc;
+	pr_info("%s, ov8810_setting preview %d\n", __func__, __LINE__);
+
+	if (ov8810_ctrl->curr_res != ov8810_ctrl->prev_res) {
+		rc = ov8810_setting(ov8810_ctrl->prev_res);
+		if (rc < 0)
+			goto init_fail;
+	} else {
+		ov8810_ctrl->curr_res = ov8810_ctrl->prev_res;
+	}
+	#endif
+
+	pr_info("%s, enable AF actuator %d\n", __func__, __LINE__);
+
+	/* enable AF actuator */
+	rc = vreg_enable(vreg_af_actuator);
+	if (!rc) {
+
+		rc = vreg_set_level(vreg_af_actuator, 2800); /*2v8*/
+		if (rc)
+		{
+		pr_err("vreg_af_actuator vreg_set_level 2v8 failed!\n");
+		goto init_fail;
+		}
+		}
+	else {
+		pr_err("vreg_af_actuator vreg_enable failed!\n");
+		goto init_fail;
+	}
+
+	msleep(20);
+
+	pr_info("%s, set step_position_table %d\n", __func__, __LINE__);
+
+	ov8810_ctrl->fps = 30*Q8;
+
+	step_position_table[0] = 0;
+
+	for (i = 1; i <= OV8810_TOTAL_STEPS_NEAR_TO_FAR; i++) {
+		if (i <= ov8810_nl_region_boundary) {
+			ov8810_step_position_table[i] =
+				ov8810_step_position_table[i-1] +
+				ov8810_nl_region_code_per_step;
+		} else {
+			ov8810_step_position_table[i] =
+				ov8810_step_position_table[i-1] +
+				ov8810_l_region_code_per_step;
+		}
+	}
+
+	 /* generate test pattern */
+	pr_info("%s, generate test pattern, %d, rc=%d\n",
+		__func__, __LINE__, rc);
+
+	if (rc < 0)
+		goto init_fail;
+	else
+		goto init_done;
+	    /* reset the driver state */
+init_fail:
+	pr_err("%s: init_fail\n", __func__);
+	vreg_disable(vreg_af_actuator);
+	if (ov8810_ctrl) {
+		kfree(ov8810_ctrl);
+		ov8810_ctrl = NULL;
+	}
+init_done:
+	up(&ov8810_sem);
+	pr_info("%s: init_done\n", __func__);
+	return rc;
+
+} /*endof ov8810_sensor_open_init*/
+
+static int ov8810_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&ov8810_wait_queue);
+	return 0;
+}
+
+static const struct i2c_device_id ov8810_i2c_id[] = {
+	{ "ov8810", 0},
+	{ }
+};
+
+static int ov8810_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	pr_info("ov8810_probe called!\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	ov8810_sensorw = kzalloc(sizeof(struct ov8810_work), GFP_KERNEL);
+	if (!ov8810_sensorw) {
+		pr_err("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, ov8810_sensorw);
+	ov8810_init_client(client);
+	ov8810_client = client;
+
+	msleep(50);
+
+	pr_info("ov8810_probe successed! rc = %d\n", rc);
+	return 0;
+
+probe_failure:
+	pr_err("ov8810_probe failed! rc = %d\n", rc);
+	return rc;
+}
+
+static int ov8810_probe_init_done(const struct msm_camera_sensor_info *data)
+{
+	gpio_request(data->sensor_pwd, "ov8810");
+	gpio_direction_output(data->sensor_pwd, 1);
+	gpio_free(data->sensor_pwd);
+	mdelay(1);
+	gpio_request(data->sensor_reset, "ov8810");
+	gpio_direction_output(data->sensor_reset, 0);
+	gpio_free(data->sensor_reset);
+	return 0;
+}
+
+static int ov8810_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int rc;
+	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+
+	if (!sinfo->need_suspend)
+		return 0;
+	ov8810_event.waked_up = 0;
+
+	pr_info("ov8810: camera suspend\n");
+
+	pr_info("%s, vreg_af_actuator vreg_disable\n", __func__);
+	vreg_disable(vreg_af_actuator);
+
+	rc = gpio_request(sinfo->sensor_reset, "ov8810");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_reset, 0);
+	else
+		pr_info("ov8810: request GPIO(sensor_reset) :%d faile\n",
+			sinfo->sensor_reset);
+
+	gpio_free(sinfo->sensor_reset);
+	msleep(10);
+		rc = gpio_request(sinfo->sensor_pwd, "ov8810");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_pwd, 0);
+	else
+		pr_info("ov8810: request GPIO(sensor_reset) :%d faile\n",
+			sinfo->sensor_pwd);
+
+	gpio_free(sinfo->sensor_pwd);
+
+	pr_info("ov8810:suspend done\n");
+	return rc;
+}
+
+static void ov8810_resume(struct early_suspend *handler)
+{
+	int rc = 0;
+	struct msm_camera_sensor_info *sinfo = ov8810_pdev->dev.platform_data;
+	pr_info("ov8810_resume\n");
+
+	/*check whether need resume*/
+	if (!sinfo->need_suspend)
+		return;
+
+	/*check whether already suspend*/
+	if (ov8810_event.waked_up == 1) {
+		pr_info("Ov8810: No nesesary to do Resume\n");
+		return;
+	}
+
+	mdelay(5);
+	/*power down setup*/
+	pr_info("%s, sensor_pwd 0\n", __func__);
+	rc = gpio_request(sinfo->sensor_pwd, "ov8810");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_pwd, 0);
+	else
+		pr_err("GPIO (%d) request faile\n", sinfo->sensor_pwd);
+	gpio_free(sinfo->sensor_pwd);
+	mdelay(5);
+	/*reset setup */
+	rc = gpio_request(sinfo->sensor_reset, "ov8810");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_reset, 1);
+	else
+		pr_err("GPIO (%d) request faile\n", sinfo->sensor_reset);
+	gpio_free(sinfo->sensor_reset);
+
+	/*init msm,clk ,GPIO,enable*/
+	pr_info("%s, msm_camio_probe_on\n", __func__);
+	msm_camio_probe_on(ov8810_pdev);
+	msm_camio_clk_enable(CAMIO_MDC_CLK);
+
+	/*set MCLK*/
+	pr_info("%s, msm_camio_clk_rate_set = %d\n",
+		__func__, OV8810_DEFAULT_CLOCK_RATE);
+	msm_camio_clk_rate_set(OV8810_DEFAULT_CLOCK_RATE);
+	msleep(100);
+
+	/*read sensor id*/
+	rc = ov8810_probe_read_id(sinfo);
+	if (rc < 0)
+		pr_err("OV8810 resume faile :can not read sensor ID\n");
+
+	/* Initialize Sensor registers */
+	rc = initialize_ov8810_registers();
+	if (rc < 0)
+		return;
+	msleep(20);
+	/*resume done*/
+	ov8810_probe_init_done(sinfo);
+	/*turn off MCLK*/
+	msm_camio_probe_off(ov8810_pdev);
+	msm_camio_clk_disable(CAMIO_MDC_CLK);
+
+	ov8810_event.waked_up = 1;
+	pr_info("ov8810:resume done\n");
+	wake_up(&ov8810_event.event_wait);
+	return;
+}
+
+
+static int __exit ov8810_i2c_remove(struct i2c_client *client)
+{
+	struct ov8810_work_t *sensorw = i2c_get_clientdata(client);
+	free_irq(client->irq, sensorw);
+	deinit_suspend();
+	ov8810_client = NULL;
+	kfree(sensorw);
+	return 0;
+}
+
+static struct i2c_driver ov8810_i2c_driver = {
+	.id_table = ov8810_i2c_id,
+	.probe	= ov8810_i2c_probe,
+	.remove = __exit_p(ov8810_i2c_remove),
+	.driver = {
+		.name = "ov8810",
+	},
+};
+
+
+static struct early_suspend early_suspend_ov8810 = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN+1,
+	.resume = ov8810_resume,
+	.suspend = NULL,
+};
+
+static const char *Ov8810Vendor = "OmniVision";
+static const char *Ov8810NAME = "ov8810";
+static const char *Ov8810Size = "8M";
+
+static ssize_t sensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "%s %s %s\n", Ov8810Vendor, Ov8810NAME, Ov8810Size);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+DEFINE_MUTEX(cam_mode_lock);
+
+static ssize_t sensor_read_cam_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	mutex_lock(&cam_mode_lock);
+	length = sprintf(buf, "%d\n", cam_mode_sel);
+	mutex_unlock(&cam_mode_lock);
+	return length;
+}
+
+static ssize_t sensor_set_cam_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+	mutex_lock(&cam_mode_lock);
+	tmp = buf[0] - 0x30; /* only get the first char */
+	cam_mode_sel = tmp;
+	mutex_unlock(&cam_mode_lock);
+	return count;
+}
+
+static ssize_t sensor_read_node(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", sensor_probe_node);
+	return length;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+static DEVICE_ATTR(cam_mode, 0644, sensor_read_cam_mode, sensor_set_cam_mode);
+static DEVICE_ATTR(node, 0444, sensor_read_node, NULL);
+
+static struct kobject *android_ov8810;
+
+static int ov8810_sysfs_init(void)
+{
+	int ret = 0;
+	pr_info("ov8810:kobject creat and add\n");
+	android_ov8810 = kobject_create_and_add("android_camera", NULL);
+	if (android_ov8810 == NULL) {
+		pr_info("ov8810_sysfs_init: subsystem_register failed\n");
+		ret = -ENOMEM;
+		return ret ;
+	}
+	pr_info("Ov8810:sysfs_create_file\n");
+	ret = sysfs_create_file(android_ov8810, &dev_attr_sensor.attr);
+	if (ret) {
+		pr_info("ov8810_sysfs_init: sysfs_create_file failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(android_ov8810, &dev_attr_cam_mode.attr);
+	if (ret) {
+		pr_info("ov8810_sysfs_init: dev_attr_cam_mode failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(android_ov8810, &dev_attr_node.attr);
+	if (ret) {
+		pr_info("ov8810_sysfs_init: dev_attr_node failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	return ret;
+
+error:
+	kobject_del(android_ov8810);
+	return ret;
+}
+
+
+int ov8810_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cdata;
+	long rc = 0;
+
+	if (copy_from_user(&cdata,
+			(void *)argp,
+			sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	down(&ov8810_sem);
+
+	CDBG("ov8810_sensor_config: cfgtype = %d\n",
+	  cdata.cfgtype);
+		switch (cdata.cfgtype) {
+		case CFG_GET_PICT_FPS:
+				ov8810_get_pict_fps(
+				cdata.cfg.gfps.prevfps,
+				&(cdata.cfg.gfps.pictfps));
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_L_PF:
+			cdata.cfg.prevl_pf =
+			ov8810_get_prev_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_P_PL:
+			cdata.cfg.prevp_pl =
+				ov8810_get_prev_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_L_PF:
+			cdata.cfg.pictl_pf =
+				ov8810_get_pict_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_P_PL:
+			cdata.cfg.pictp_pl =
+				ov8810_get_pict_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_MAX_EXP_LC:
+			cdata.cfg.pict_max_exp_lc =
+				ov8810_get_pict_max_exp_lc();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_SET_FPS:
+		case CFG_SET_PICT_FPS:
+			rc = ov8810_set_fps(&(cdata.cfg.fps));
+			break;
+
+		case CFG_SET_EXP_GAIN:
+			rc =
+				ov8810_write_exp_gain(
+					cdata.cfg.exp_gain.mul,
+					cdata.cfg.exp_gain.gain,
+					cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_PICT_EXP_GAIN:
+			rc =
+				ov8810_set_pict_exp_gain(
+					cdata.cfg.exp_gain.mul,
+					cdata.cfg.exp_gain.gain,
+					cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_MODE:
+			rc = ov8810_set_sensor_mode(cdata.mode,
+						cdata.rs);
+			break;
+
+		case CFG_PWR_DOWN:
+			rc = ov8810_power_down();
+			break;
+
+		case CFG_MOVE_FOCUS:
+			rc =
+				ov8810_move_focus(
+					cdata.cfg.focus.dir,
+					cdata.cfg.focus.steps);
+			break;
+
+		case CFG_SET_DEFAULT_FOCUS:
+			rc =
+				ov8810_set_default_focus(
+					cdata.cfg.focus.steps);
+			break;
+
+		case CFG_SET_EFFECT:
+			rc = ov8810_set_default_focus(
+						cdata.cfg.effect);
+			break;
+
+		case CFG_I2C_IOCTL_R_OTP:{
+			rc = ov8810_i2c_read_fuseid(&cdata);
+			if (copy_to_user
+				(argp, &cdata, sizeof(struct sensor_cfg_data))
+			    )
+			rc = -EFAULT;
+			}
+			break;
+
+		case CFG_SET_OV_LSC:
+			rc = ov8810_update_lsc_table(&cdata);
+			break;
+
+		/*20100330 vincent for lsc calibration*/
+		case CFG_SET_OV_LSC_RAW_CAPTURE:
+			rc = ov8810_LSC_calibration_set_rawflag(&cdata);
+			break;
+
+		default:
+			rc = -EFAULT;
+			break;
+		}
+
+	prevent_suspend();
+	up(&ov8810_sem);
+
+	return rc;
+}
+
+
+
+
+static int ov8810_sensor_release(void)
+{
+	int rc = -EBADF;
+
+	down(&ov8810_sem);
+	/*Pull hi PWD*/
+	gpio_request(ov8810_ctrl->sensordata->sensor_pwd, "ov8810");
+	gpio_direction_output(ov8810_ctrl->sensordata->sensor_pwd, 1);
+	gpio_free(ov8810_ctrl->sensordata->sensor_pwd);
+	/*Pull low RST*/
+	gpio_request(ov8810_ctrl->sensordata->sensor_reset, "ov8810");
+	gpio_direction_output(ov8810_ctrl->sensordata->sensor_reset, 0);
+	gpio_free(ov8810_ctrl->sensordata->sensor_reset);
+
+	pr_info("vreg_af_actuator vreg_disable\n");
+	vreg_disable(vreg_af_actuator);
+	msleep(20);
+	pr_info("%s, %d\n", __func__, __LINE__);
+	/*MCLK off*/
+	msm_camio_probe_off(ov8810_pdev);
+	if (ov8810_ctrl) {
+		kfree(ov8810_ctrl);
+		ov8810_ctrl = NULL;
+	}
+	mdelay(3);
+	allow_suspend();
+	pr_info("ov8810_release completed\n");
+	up(&ov8810_sem);
+
+	return rc;
+}
+
+static int ov8810_sensor_probe(struct msm_camera_sensor_info *info,
+		struct msm_sensor_ctrl *s)
+{
+	int rc = 0;
+	rc = i2c_add_driver(&ov8810_i2c_driver);
+	if (rc < 0 || ov8810_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_fail;
+	}
+
+	pr_info("ov8810 s->node %d\n", s->node);
+	sensor_probe_node = s->node;
+	/*switch pclk and mclk between main cam and 2nd cam*/
+	/*only for supersonic*/
+	pr_info("Ov8810: doing clk switch (ov8810)\n");
+	if(info->camera_clk_switch != NULL)
+		info->camera_clk_switch();
+	mdelay(5);
+	/*power down setup*/
+	rc = gpio_request(info->sensor_pwd, "ov8810");
+	if (!rc)
+		gpio_direction_output(info->sensor_pwd, 0);
+	else
+		pr_err("GPIO (%d) request faile\n", info->sensor_pwd);
+	gpio_free(info->sensor_pwd);
+	mdelay(5);
+	/*reset setup */
+	rc = gpio_request(info->sensor_reset, "ov8810");
+	if (!rc)
+		gpio_direction_output(info->sensor_reset, 1);
+	else
+		pr_err("GPIO (%d) request faile\n", info->sensor_reset);
+	gpio_free(info->sensor_reset);
+
+	/*set MCLK*/
+	pr_info("%s, msm_camio_clk_rate_set %d\n",
+		__func__, OV8810_DEFAULT_CLOCK_RATE);
+       msm_camio_clk_rate_set(OV8810_DEFAULT_CLOCK_RATE);
+	msleep(100);
+	/*read sensor id*/
+	rc = ov8810_probe_read_id(info);
+	if (rc < 0)
+		goto probe_fail;
+
+	/* Initialize Sensor registers */
+	rc = initialize_ov8810_registers();
+	if (rc < 0)
+		return rc;
+
+	if (info->camera_main_set_probe != NULL)
+		info->camera_main_set_probe(true);
+	init_suspend();
+	s->s_init = ov8810_sensor_open_init;
+	s->s_release = ov8810_sensor_release;
+	s->s_config  = ov8810_sensor_config;
+	msleep(20);
+	ov8810_probe_init_done(info);
+	/*register late resuem*/
+	register_early_suspend(&early_suspend_ov8810);
+	/*init wait event*/
+	init_waitqueue_head(&ov8810_event.event_wait);
+	/*init waked_up value*/
+	ov8810_event.waked_up = 1;
+	/*write sysfs*/
+	ov8810_sysfs_init();
+	pr_info("%s: ov8810_probe_init_done %d\n",  __func__, __LINE__);
+	goto probe_done;
+
+probe_fail:
+	pr_err("SENSOR PROBE FAILS!\n");
+probe_done:
+	return rc;
+
+}
+
+static int ov8810_vreg_enable(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	int rc;
+	pr_info("%s camera vreg on\n", __func__);
+
+	if (sdata->camera_power_on == NULL) {
+		pr_err("sensor platform_data didnt register\n");
+		return -EIO;
+	}
+	rc = sdata->camera_power_on();
+	return rc;
+}
+
+
+static int ov8810_vreg_disable(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	int rc;
+	printk(KERN_INFO "%s camera vreg off\n", __func__);
+	if (sdata->camera_power_off == NULL) {
+		pr_err("sensor platform_data didnt register\n");
+		return -EIO;
+	}
+	rc = sdata->camera_power_off();
+	return rc;
+}
+
+
+static int __ov8810_probe(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	printk("__ov8810_probe\n");
+	ov8810_pdev = pdev;
+	if (sdata->camera_main_get_probe != NULL) {
+		if (sdata->camera_main_get_probe()) {
+			pr_info("__ov8810_probe camera main get probed already.\n");
+			return 0;
+		}
+	}
+	return msm_camera_drv_start(pdev, ov8810_sensor_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __ov8810_probe,
+	.driver = {
+		.name = "msm_camera_ov8810",
+		.owner = THIS_MODULE,
+	},
+	.suspend = ov8810_suspend,
+};
+
+static int __init ov8810_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(ov8810_init);
diff --git a/drivers/media/video/msm/ov8810.h b/drivers/media/video/msm/ov8810.h
new file mode 100644
index 0000000..48219d2
--- /dev/null
+++ b/drivers/media/video/msm/ov8810.h
@@ -0,0 +1,61 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef OV8810_H
+#define OV8810_H
+
+#endif
+
diff --git a/drivers/media/video/msm/ov9665.c b/drivers/media/video/msm/ov9665.c
new file mode 100644
index 0000000..6d1ab50
--- /dev/null
+++ b/drivers/media/video/msm/ov9665.c
@@ -0,0 +1,1168 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include "ov9665.h"
+
+/* OV9665 Registers and their values */
+/* Sensor Core Registers */
+#define  REG_OV9665_MODEL_ID_H 0x0A
+#define  REG_OV9665_MODEL_ID_L 0x0B
+#define  OV9665_MODEL_ID     0x9663
+
+/*  SOC Registers Page 1  */
+#define  REG_OV9665_SENSOR_RESET     0x301A
+#define  REG_OV9665_STANDBY_CONTROL  0x3202
+#define  REG_OV9665_MCU_BOOT         0x3386
+
+struct ov9665_work {
+	struct work_struct work;
+};
+
+static struct ov9665_work *ov9665_sensorw;
+static struct i2c_client *ov9665_client;
+
+struct ov9665_ctrl {
+	const struct msm_camera_sensor_info *sensordata;
+};
+
+static struct ov9665_ctrl *ov9665_ctrl;
+static int op_mode;
+static DECLARE_WAIT_QUEUE_HEAD(ov9665_wait_queue);
+DEFINE_SEMAPHORE(ov9665_sem);
+
+static int sensor_probe_node = 0;
+
+static enum wb_mode current_wb = CAMERA_AWB_AUTO;
+static int ov9665_set_wb(enum wb_mode wb_value);
+
+#define MAX_I2C_RETRIES 20
+static int i2c_transfer_retry(struct i2c_adapter *adap,
+			struct i2c_msg *msgs,
+			int len)
+{
+	int i2c_retry = 0;
+	int ns; /* number sent */
+
+	while (i2c_retry++ < MAX_I2C_RETRIES) {
+		ns = i2c_transfer(adap, msgs, len);
+		if (ns == len)
+			break;
+		pr_err("%s: try %d/%d: i2c_transfer sent: %d, len %d\n",
+			__func__,
+			i2c_retry, MAX_I2C_RETRIES, ns, len);
+		msleep(10);
+	}
+
+	return ns == len ? 0 : -EIO;
+}
+
+
+static int ov9665_i2c_txdata(unsigned short saddr,
+				  unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txdata,
+		 },
+	};
+
+	if (i2c_transfer_retry(ov9665_client->adapter, msg, 1) < 0) {
+		pr_info("ov9665_i2c_txdata failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int ov9665_i2c_write(unsigned short saddr,
+				 unsigned char waddr, unsigned char wdata,
+				 enum ov9665_width width)
+{
+	int rc = -EIO;
+	unsigned char buf[4];
+	memset(buf, 0, sizeof(buf));
+	switch (width) {
+	case WORD_LEN:{
+			buf[0] = (waddr & 0xFF00) >> 8;
+			buf[1] = (waddr & 0x00FF);
+			buf[2] = (wdata & 0xFF00) >> 8;
+			buf[3] = (wdata & 0x00FF);
+
+			rc = ov9665_i2c_txdata(saddr, buf, 4);
+		}
+		break;
+
+	case BYTE_LEN:{
+			buf[0] = waddr;
+			buf[1] = wdata;
+			rc = ov9665_i2c_txdata(saddr, buf, 2);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	if (rc < 0)
+		pr_info("i2c_write failed, addr = 0x%x, val = 0x%x!\n",
+		     waddr, wdata);
+
+	return rc;
+}
+
+static int ov9665_i2c_write_table(struct ov9665_i2c_reg_conf const
+				       *reg_conf_tbl, int num_of_items_in_table)
+{
+	int i;
+	int rc = -EIO;
+
+	for (i = 0; i < num_of_items_in_table; i++) {
+		rc = ov9665_i2c_write(ov9665_client->addr,
+				       reg_conf_tbl->waddr, reg_conf_tbl->wdata,
+				       reg_conf_tbl->width);
+		if (rc < 0)
+			break;
+		if (reg_conf_tbl->mdelay_time != 0)
+			mdelay(reg_conf_tbl->mdelay_time);
+		reg_conf_tbl++;
+	}
+
+	return rc;
+}
+
+static int ov9665_i2c_rxdata(unsigned short saddr,
+			      unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = 1,
+		 .buf = rxdata,
+		 },
+		{
+		 .addr = saddr,
+		 .flags = I2C_M_RD,
+		 .len = length,
+		 .buf = rxdata,
+		 },
+	};
+
+	if (i2c_transfer_retry(ov9665_client->adapter, msgs, 2) < 0) {
+		pr_info("ov9665_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static int ov9665_i2c_read(unsigned short saddr,
+				unsigned short raddr, unsigned char *rdata)
+{
+	int rc = 0;
+	unsigned char buf[1];
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+	buf[0] = raddr;
+	rc = ov9665_i2c_rxdata(saddr, buf,1);
+	if (rc < 0)
+		return rc;
+	*rdata = buf[0];
+	if (rc < 0)
+		pr_info("ov9665_i2c_read failed!\n");
+
+	return rc;
+}
+
+
+static int ov9665_i2c_write_mask(
+	unsigned char addr,unsigned char Data, unsigned char Mask)
+{
+	int rc = 0;
+	unsigned char temp;
+	rc = ov9665_i2c_read(ov9665_client->addr, addr, &temp);
+	if(rc < 0){
+		pr_err("ov9665 error : read i2c error\n");
+		return rc;
+	}
+	temp = (temp&(~Mask))|Data;
+	rc = ov9665_i2c_write(ov9665_client->addr, addr, temp, BYTE_LEN);
+	if(rc < 0){
+		pr_err("ov9665 error : write i2c error\n");
+		return rc;
+	}
+	return rc;
+}
+
+
+static int ov9665_pwd(const struct msm_camera_sensor_info *info){
+	int rc=0;
+	rc = gpio_request(info->sensor_pwd, "ov9665");
+	if (!rc)
+		gpio_direction_output(info->sensor_pwd, 0);
+	else
+		pr_err("GPIO(%d) request faile",info->sensor_pwd);
+	gpio_free(info->sensor_pwd);
+	/*for 2nd camera 2nd source*/
+	/*main camera pwd pull down*/
+	rc = gpio_request(105, "ov9665");
+	if (!rc)
+		gpio_direction_output(105, 0);
+	else
+		pr_err("GPIO(105) request faile");
+	gpio_free(105);
+	return rc;
+}
+
+static int ov9665_reset(const struct msm_camera_sensor_info *dev)
+{
+	int rc = 0;
+	rc = gpio_request(dev->sensor_reset, "ov9665");
+
+	if (!rc)
+		rc = gpio_direction_output(dev->sensor_reset, 1);
+	else
+		pr_err("GPIO(%d) request faile",dev->sensor_reset);
+
+	gpio_free(dev->sensor_reset);
+	return rc;
+}
+
+static int ov9665_reg_init(void)
+{
+	int rc = 0;
+	rc = ov9665_i2c_write_table(&ov9665_regs.register_init[0],
+			ov9665_regs.register_init_size);
+	return rc;
+}
+
+static int ov9665_init_done(const struct msm_camera_sensor_info *info)
+{
+	int rc = 0;
+	rc = gpio_request(info->sensor_pwd, "ov9665");
+	if (!rc)
+		gpio_direction_output(info->sensor_pwd, 1);
+	else
+		pr_err("GPIO(%d) request faile",info->sensor_pwd);
+	gpio_free(info->sensor_pwd);
+	return rc;
+}
+
+
+static int ov9665_set_sensor_mode(int mode)
+{
+	unsigned char shading, gain;
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		op_mode = SENSOR_PREVIEW_MODE;
+		pr_info("ov9665:sensor set mode: preview\n");
+		ov9665_i2c_write(ov9665_client->addr, 0x63, 0x00, BYTE_LEN);
+		/*Windowing*/
+		ov9665_i2c_write(ov9665_client->addr, 0x12, 0x40, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x4d, 0x09, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x17, 0x0c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x18, 0x5d, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x19, 0x02, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x1a, 0x3f, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x03, 0x83, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x32, 0xad, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x2b, 0x00, BYTE_LEN);
+		/*scaling*/
+		ov9665_i2c_write(ov9665_client->addr, 0x64, 0xa4, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xab, 0xe7, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xb9, 0x50, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xba, 0x3c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbb, 0x50, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbc, 0x3c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x85, 0xe7, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x0d, 0x92, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x0d, 0x90, BYTE_LEN);
+		/*enable 3A*/
+		ov9665_i2c_write(ov9665_client->addr, 0x13, 0xe7, BYTE_LEN);
+		ov9665_set_wb(current_wb);
+		/*VGA 30fps*/
+		ov9665_i2c_write(ov9665_client->addr, 0x11, 0x80, BYTE_LEN);
+		//ov9665_i2c_write(ov9665_client->addr, 0x09, 0x01, BYTE_LEN);
+		mdelay(400);/*skip 2 break frame */
+		break;
+
+	case SENSOR_SNAPSHOT_MODE:
+		pr_info("ov9665:sensor set mode: snapshot\n");
+		op_mode = SENSOR_SNAPSHOT_MODE;
+		/*disable 3A*/
+		ov9665_i2c_write(ov9665_client->addr, 0x13, 0xe0, BYTE_LEN);
+		/*SXGA 7.5fps*/
+		ov9665_i2c_write(ov9665_client->addr, 0x11, 0x81, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x63, 0x01, BYTE_LEN);
+		/*Windowing*/
+		ov9665_i2c_write(ov9665_client->addr, 0x12, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x4d, 0x11, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x17, 0x0c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x18, 0x5d, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x19, 0x01, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x1a, 0x82, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x03, 0x83, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x32, 0x24, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x2b, 0x00, BYTE_LEN);
+		/*scaling*/
+		ov9665_i2c_write(ov9665_client->addr, 0x64, 0x24, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xab, 0xe7, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xb9, 0xa0, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xba, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbb, 0xa0, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbc, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x85, 0xe7, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x0d, 0x82, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0x0d, 0x80, BYTE_LEN);
+		mdelay(400); /*wait for AE stable*/
+		break;
+	case SENSOR_GET_EXP:
+		ov9665_i2c_read(ov9665_client->addr, 0x83, &shading);
+		ov9665_i2c_read(ov9665_client->addr, 0x00, &gain);
+		if (gain >= 0x36) //5.5xgain
+			ov9665_i2c_write
+				(ov9665_client->addr, 0x83, 0x06, BYTE_LEN);
+		else if (gain < 0x34) //5x gain
+			ov9665_i2c_write
+				(ov9665_client->addr, 0x83, 0x07, BYTE_LEN);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ov9665_set_effect(int effect)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	switch (effect) {
+	case CAMERA_EFFECT_OFF:
+		#if 1/*color matrix*/
+		ov9665_i2c_write(ov9665_client->addr, 0xbd, 0x04, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbe, 0x1f, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbf, 0x03, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc0, 0x0d, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc1, 0x24, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc2, 0x30, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc3, 0x34, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc4, 0x34, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc5, 0x01, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc6, 0x9c, BYTE_LEN);
+		#endif
+		#if 0/*control by SDE*/
+		ov9665_i2c_write(ov9665_client->addr, 0xc7, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc8, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xcd, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xce, 0x80, BYTE_LEN);
+		#endif
+		break;
+
+	case CAMERA_EFFECT_MONO:
+		#if 1/*color matrix*/
+		ov9665_i2c_write(ov9665_client->addr, 0xbd, 0x09, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbe, 0x12, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbf, 0x03, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc0, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc1, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc2, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc3, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc4, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc5, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc6, 0x00, BYTE_LEN);
+		#endif
+		#if 0/*control by SDE*/
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x18, 0x18);
+		ov9665_i2c_write(ov9665_client->addr, 0xCD, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xCE, 0x80, BYTE_LEN);
+		#endif
+		break;
+
+	case CAMERA_EFFECT_NEGATIVE:
+		#if 0/*control by SDE*/
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x40, 0x58);
+		/*ov9665_i2c_write(ov9665_client->addr, 0xC7, 0x90, BYTE_LEN);*/
+		#endif
+		break;
+
+	case CAMERA_EFFECT_SEPIA:
+		#if 1/*user color matrix*/
+		ov9665_i2c_write(ov9665_client->addr, 0xbd, 0x09, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbe, 0x09, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xbf, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc0, 0x06, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc1, 0x08, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc2, 0x07, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc3, 0x0a, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc4, 0x04, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc5, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc6, 0x98, BYTE_LEN);
+		#endif
+		#if 0/*control by SDE*/
+		ov9665_i2c_write(ov9665_client->addr, 0xc7, 0x90, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xc8, 0x18, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xCD, 0x40, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr, 0xCE, 0xa0, BYTE_LEN);
+		#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int ov9665_set_antibanding(enum antibanding_mode antibanding_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	switch (antibanding_value) {
+	case CAMERA_ANTI_BANDING_50HZ:
+		ov9665_i2c_write_mask(0x0c, 0x00, 0x02);
+		ov9665_i2c_write_mask(0x0c, 0x04, 0x04);
+		break;
+	case CAMERA_ANTI_BANDING_60HZ:
+		ov9665_i2c_write_mask(0x0c, 0x00, 0x02);
+		ov9665_i2c_write_mask(0x0c, 0x00, 0x04);
+		break;
+	case CAMERA_ANTI_BANDING_AUTO:
+		ov9665_i2c_write_mask(0x0c, 0x02, 0x02);
+		break;
+	}
+	return 0;
+}
+
+
+static int ov9665_set_brightness(enum brightness_t brightness_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	ov9665_i2c_write_mask(0xc8, 0x04, 0x04);
+	switch (brightness_value) {
+	case CAMERA_BRIGHTNESS_N4:
+		ov9665_i2c_write_mask(0xc7, 0x18, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x40, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_N3:
+		ov9665_i2c_write_mask(0xc7, 0x18, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x30, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_N2:
+		ov9665_i2c_write_mask(0xc7, 0x18, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x20, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_N1:
+		ov9665_i2c_write_mask(0xc7, 0x18, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x10, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_D:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x00, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_P1:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x10, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_P2:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x20, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_P3:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x30, BYTE_LEN);
+		break;
+	case CAMERA_BRIGHTNESS_P4:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x18);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd1, 0x40, BYTE_LEN);
+		break;
+	default:
+		 break;
+	}
+	return 0;
+}
+
+
+static int ov9665_set_wb(enum wb_mode wb_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	switch (wb_value) {
+	case CAMERA_AWB_AUTO:
+		ov9665_i2c_write(ov9665_client->addr,
+			0x13, 0xe7, BYTE_LEN);
+		break;
+	case CAMERA_AWB_CLOUDY:
+		ov9665_i2c_write(ov9665_client->addr,
+			0x13, 0xe5, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x01, 0x40, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x02, 0x68, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x16, 0x46, BYTE_LEN);
+		break;
+	case CAMERA_AWB_INDOOR_HOME:
+		ov9665_i2c_write(ov9665_client->addr,
+			0x13, 0xe5, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x01, 0x62, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x02, 0x3c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x16, 0x41, BYTE_LEN);
+		break;
+	case CAMERA_AWB_INDOOR_OFFICE:
+		ov9665_i2c_write(ov9665_client->addr,
+			0x13, 0xe5, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x01, 0x50, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x02, 0x40, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x16, 0x40, BYTE_LEN);
+		break;
+	case CAMERA_AWB_SUNNY:
+		ov9665_i2c_write(ov9665_client->addr,
+			0x13, 0xe5, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x01, 0x35, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x02, 0x52, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x16, 0x40, BYTE_LEN);
+		break;
+	default:
+		break;
+	}
+	current_wb = wb_value;
+	return 0;
+}
+
+
+static int ov9665_set_sharpness(enum sharpness_mode sharpness_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	ov9665_i2c_write_mask(0xab, 0x04, 0x04);
+	switch (sharpness_value) {
+	case CAMERA_SHARPNESS_X0:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xad, 0x20, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd9, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xda, 0x00, BYTE_LEN);
+		break;
+	case CAMERA_SHARPNESS_X1:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xad, 0x22, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd9, 0x01, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xda, 0x00, BYTE_LEN);
+		break;
+	case CAMERA_SHARPNESS_X2:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xad, 0x24, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd9, 0x13, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xda, 0x00, BYTE_LEN);
+		break;
+	case CAMERA_SHARPNESS_X3:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xad, 0x28, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd9, 0x26, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xda, 0x22, BYTE_LEN);
+		break;
+	case CAMERA_SHARPNESS_X4:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xad, 0x2c, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd9, 0x6a, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xda, 0x66, BYTE_LEN);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+
+static int ov9665_set_saturation(enum saturation_mode saturation_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	switch (saturation_value) {
+	case CAMERA_SATURATION_X0:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x02, 0x02);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcb, 0x00, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcc, 0x00, BYTE_LEN);
+		break;
+	case CAMERA_SATURATION_X05:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x02, 0x02);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcb, 0x20, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcc, 0x20, BYTE_LEN);
+		break;
+	case CAMERA_SATURATION_X1:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x02, 0x02);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcb, 0x40, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcc, 0x40, BYTE_LEN);
+		break;
+	case CAMERA_SATURATION_X15:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x02, 0x02);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcb, 0x60, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcc, 0x60, BYTE_LEN);
+		break;
+	case CAMERA_SATURATION_X2:
+		ov9665_i2c_write_mask(0xc7, 0x10, 0x10);
+		ov9665_i2c_write_mask(0xc8, 0x02, 0x02);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcb, 0x80, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0xcc, 0x80, BYTE_LEN);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int ov9665_set_contrast(enum contrast_mode contrast_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+	ov9665_i2c_write_mask(0xc7, 0x34, 0x34);
+	ov9665_i2c_write_mask(0xc8, 0x04, 0x04);
+	ov9665_i2c_write_mask(0x64, 0x02, 0x02);
+	switch (contrast_value) {
+	case CAMERA_CONTRAST_N2:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd0, 0x08, BYTE_LEN);
+		break;
+	case CAMERA_CONTRAST_N1:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd0, 0x10, BYTE_LEN);
+		break;
+	case CAMERA_CONTRAST_D:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd0, 0x20, BYTE_LEN);
+		break;
+	case CAMERA_CONTRAST_P1:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd0, 0x30, BYTE_LEN);
+		break;
+	case CAMERA_CONTRAST_P2:
+		ov9665_i2c_write(ov9665_client->addr,
+			0xd0, 0x40, BYTE_LEN);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int ov9665_set_front_camera_mode(enum frontcam_t frontcam_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	switch (frontcam_value) {
+	case CAMERA_MIRROR:
+		/*mirror and flip*/
+		ov9665_i2c_write(ov9665_client->addr,
+			0x04, 0xa8, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x33, 0xc8, BYTE_LEN);
+		break;
+	case CAMERA_REVERSE:
+		/*reverse mode*/
+		ov9665_i2c_write(ov9665_client->addr,
+			0x04, 0x28, BYTE_LEN);
+		ov9665_i2c_write(ov9665_client->addr,
+			0x33, 0xc0, BYTE_LEN);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int ov9665_sensor_init(const struct msm_camera_sensor_info *data)
+{
+	uint8_t model_id_h = 0,model_id_l = 0;
+	uint16_t model_id;
+	int rc = 0;
+	pr_info("ov9665_sensor_init_probe \n");
+	/* Read the Model ID of the sensor */
+	rc = ov9665_i2c_read(ov9665_client->addr,
+			      REG_OV9665_MODEL_ID_H, &model_id_h);
+	if (rc < 0)
+		goto init_probe_fail;
+
+	rc = ov9665_i2c_read(ov9665_client->addr,
+			      REG_OV9665_MODEL_ID_L, &model_id_l);
+	if (rc < 0)
+		goto init_probe_fail;
+	model_id = (((model_id_h << 8) & 0xFF00) +(model_id_l));
+	pr_info("ov9665: model_id = 0x%x\n", model_id);
+	/* Check if it matches it with the value in Datasheet */
+	if (model_id != OV9665_MODEL_ID) {
+		rc = -EINVAL;
+		goto init_probe_fail;
+	}
+
+
+	return rc;
+init_probe_fail:
+	return rc;
+}
+
+int ov9665_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+	int rc = 0;
+	ov9665_ctrl = kzalloc(sizeof(struct ov9665_ctrl), GFP_KERNEL);
+	if (!ov9665_ctrl) {
+		pr_info("ov9665_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+
+	if (data == NULL) {
+		pr_err("%s sensor data is NULL\n", __func__);
+		return -EINVAL;
+	}
+	ov9665_ctrl->sensordata = data;
+	/*switch PCLK and MCLK to 2nd cam*/
+	pr_info("ov9665: ov9665_sensor_probe switch clk\n");
+	if(data->camera_clk_switch != NULL)
+		data->camera_clk_switch();
+
+	/* Config power down */
+	rc = gpio_request(data->sensor_pwd, "ov9665");
+	if (!rc)
+		gpio_direction_output(data->sensor_pwd, 0);
+	else
+		pr_info("GPIO(%d) request faile",data->sensor_pwd);
+	gpio_free(data->sensor_pwd);
+	mdelay(3);
+	/* Input MCLK = 24MHz */
+	msm_camio_clk_rate_set(24000000);
+	mdelay(5);
+
+	/* Config reset */
+	rc = gpio_request(data->sensor_reset, "ov9665");
+	if (!rc)
+		gpio_direction_output(data->sensor_reset, 1);
+	else
+		pr_info("GPIO(%d) request faile", data->sensor_reset);
+	gpio_free(data->sensor_reset);
+	mdelay(20);
+	msm_camio_camif_pad_reg_reset();
+
+	rc = ov9665_i2c_write_table(&ov9665_regs.plltbl[0],
+				     ov9665_regs.plltbl_size);
+
+	/*read ID*/
+	rc = ov9665_sensor_init(data);
+	if (rc < 0) {
+		pr_info("ov9665_sensor_init failed!\n");
+		goto init_fail;
+	}
+	/*set initial register*/
+	rc = ov9665_reg_init();
+	if (rc < 0) {
+		pr_info("ov9665_sensor_reg_init failed!\n");
+		goto init_fail;
+	}
+init_done:
+	return rc;
+
+init_fail:
+	/* remove free ov9665_ctrl to prevent kernel panic in sensor release */
+	pr_info("ov9665_sensor_open_init failed\n");
+	return rc;
+}
+
+static int ov9665_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&ov9665_wait_queue);
+	return 0;
+}
+
+int ov9665_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cfg_data;
+	long rc = 0;
+	if (copy_from_user(&cfg_data,
+			   (void *)argp, sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	switch (cfg_data.cfgtype) {
+	case CFG_SET_MODE:
+		rc = ov9665_set_sensor_mode(cfg_data.mode);
+		break;
+
+	case CFG_SET_EFFECT:
+		rc = ov9665_set_effect(cfg_data.cfg.effect);
+		if(rc < 0)
+			return rc;
+		break;
+
+	case CFG_SET_ANTIBANDING:
+		rc = ov9665_set_antibanding
+				(cfg_data.cfg.antibanding_value);
+		break;
+	case CFG_SET_BRIGHTNESS:
+		rc = ov9665_set_brightness
+				(cfg_data.cfg.brightness_value);
+		break;
+	case CFG_SET_WB:
+		rc = ov9665_set_wb(cfg_data.cfg.wb_value);
+		break;
+	case CFG_SET_SHARPNESS:
+		rc = ov9665_set_sharpness
+			(cfg_data.cfg.sharpness_value);
+		break;
+	case CFG_SET_SATURATION:
+		rc = ov9665_set_saturation
+			(cfg_data.cfg.saturation_value);
+		break;
+	case CFG_SET_CONTRAST:
+		rc = ov9665_set_contrast(cfg_data.cfg.contrast_value);
+		break;
+	case CFG_SET_FRONT_CAMERA_MODE:
+		rc = ov9665_set_front_camera_mode(cfg_data.cfg.frontcam_value);
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+int ov9665_sensor_release(void)
+{
+	int rc = 0;
+	down(&ov9665_sem);
+
+	rc = gpio_request(ov9665_ctrl->sensordata->sensor_pwd, "ov9665");
+	if (!rc)
+		gpio_direction_output(ov9665_ctrl->sensordata->sensor_pwd, 1);
+	else
+		pr_info("GPIO(%d) request faile",
+			ov9665_ctrl->sensordata->sensor_pwd);
+	gpio_free(ov9665_ctrl->sensordata->sensor_pwd);
+
+	if (ov9665_ctrl->sensordata->camera_get_source() == SECOND_SOURCE) {
+		rc = gpio_request(
+			ov9665_ctrl->sensordata->sensor_reset, "ov9665");
+		if (!rc)
+			gpio_direction_output(
+			ov9665_ctrl->sensordata->sensor_reset, 0);
+		else
+			pr_info("GPIO(%d) request faile",
+				ov9665_ctrl->sensordata->sensor_reset);
+		gpio_free(ov9665_ctrl->sensordata->sensor_reset);
+	}
+
+
+	if (ov9665_ctrl) {
+		kfree(ov9665_ctrl);
+		ov9665_ctrl = NULL;
+	}
+
+	up(&ov9665_sem);
+
+	return rc;
+}
+
+static const char *Ov9665Vendor = "OmniVision";
+static const char *Ov9665NAME = "ov9665";
+static const char *Ov9665Size = "1M";
+static uint32_t htcwc_value;
+
+static ssize_t sensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "%s %s %s\n", Ov9665Vendor, Ov9665NAME, Ov9665Size);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static ssize_t htcwc_get(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", htcwc_value);
+	return length;
+}
+
+static ssize_t htcwc_set(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+
+	tmp = buf[0] - 0x30; /* only get the first char */
+
+#if 0
+	if (strcmp(current->comm,"com.android.camera")!=0){
+		pr_info("No permission : not camera ap\n");
+		return -EINVAL;
+	}
+#endif
+
+	htcwc_value = tmp;
+	//pr_info("current_comm = %s\n", current->comm);
+	pr_info("htcwc_value = %d\n", htcwc_value);
+	return count;
+}
+
+static ssize_t sensor_read_node(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", sensor_probe_node);
+	return length;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+static DEVICE_ATTR(htcwc, 0777, htcwc_get, htcwc_set);
+static DEVICE_ATTR(node, 0444, sensor_read_node, NULL);
+
+static struct kobject *android_ov9665;
+
+static int ov9665_sysfs_init(void)
+{
+	int ret ;
+	pr_info("ov9665:kobject creat and add\n");
+	android_ov9665 = kobject_create_and_add("android_camera2", NULL);
+	if (android_ov9665 == NULL) {
+		pr_info("ov9665_sysfs_init: subsystem_register " \
+		"failed\n");
+		ret = -ENOMEM;
+		return ret ;
+	}
+	pr_info("ov9665:sysfs_create_file\n");
+	ret = sysfs_create_file(android_ov9665, &dev_attr_sensor.attr);
+	if (ret) {
+		pr_info("ov9665_sysfs_init: sysfs_create_file " \
+		"failed\n");
+		kobject_del(android_ov9665);
+	}
+
+	ret = sysfs_create_file(android_ov9665, &dev_attr_htcwc.attr);
+	if (ret) {
+		pr_info("ov9665_sysfs_init: sysfs_create_file htcwc failed\n");
+		kobject_del(android_ov9665);
+	}
+
+	ret = sysfs_create_file(android_ov9665, &dev_attr_node.attr);
+	if (ret) {
+		pr_info("ov9665_sysfs_init: dev_attr_node failed\n");
+		kobject_del(android_ov9665);
+	}
+
+	return 0 ;
+}
+
+
+static int ov9665_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int rc = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		rc = -ENOTSUPP;
+		goto probe_failure;
+	}
+
+	ov9665_sensorw = kzalloc(sizeof(struct ov9665_work), GFP_KERNEL);
+
+	if (!ov9665_sensorw) {
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, ov9665_sensorw);
+	ov9665_init_client(client);
+	ov9665_client = client;
+
+	pr_info("ov9665_probe succeeded!\n");
+
+	return 0;
+
+probe_failure:
+	kfree(ov9665_sensorw);
+	ov9665_sensorw = NULL;
+	pr_info("ov9665_probe failed!\n");
+	return rc;
+}
+
+static const struct i2c_device_id ov9665_i2c_id[] = {
+	{"ov9665", 0},
+	{},
+};
+
+static struct i2c_driver ov9665_i2c_driver = {
+	.id_table = ov9665_i2c_id,
+	.probe = ov9665_i2c_probe,
+	.remove = __exit_p(ov9665_i2c_remove),
+	.driver = {
+		   .name = "ov9665",
+		   },
+};
+
+static int ov9665_sensor_probe(struct msm_camera_sensor_info *info,
+				struct msm_sensor_ctrl *s)
+{
+	int rc = i2c_add_driver(&ov9665_i2c_driver);
+	if (rc < 0 || ov9665_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_done;
+	}
+
+	pr_info("ov9665 s->node %d\n", s->node);
+	sensor_probe_node = s->node;
+
+	/*switch clk source*/
+	pr_info("ov9665: ov9665_sensor_probe switch clk\n");
+	if(info->camera_clk_switch != NULL)
+		info->camera_clk_switch();
+
+
+	/* Config power down */
+	if(ov9665_pwd(info)<0)
+		goto probe_fail;
+	mdelay(3);
+
+	/*Config reset */
+	if(ov9665_reset(info)<0)
+		goto probe_fail;
+	mdelay(5);
+
+	/*MCLK enable*/
+	pr_info("ov9665: MCLK enable clk\n");
+	msm_camio_clk_rate_set(24000000);
+	mdelay(100);
+
+	/* PLL Setup Start */
+	rc = ov9665_i2c_write_table(&ov9665_regs.plltbl[0],
+				     ov9665_regs.plltbl_size);
+
+	rc = ov9665_sensor_init(info);
+	if (rc < 0)
+		goto probe_fail;
+	/*set initial register*/
+	rc = ov9665_reg_init();
+	if (rc < 0)
+		goto probe_fail;
+	if (info->camera_main_set_probe != NULL)
+		info->camera_main_set_probe(true);
+
+	s->s_init = ov9665_sensor_open_init;
+	s->s_release = ov9665_sensor_release;
+	s->s_config = ov9665_sensor_config;
+
+	/*init done*/
+	mdelay(800);
+	ov9665_init_done(info);
+	ov9665_sysfs_init();
+
+probe_done:
+	pr_info("%s %s:%d\n", __FILE__, __func__, __LINE__);
+	return rc;
+probe_fail:
+	pr_err("OV9665 probe faile\n");
+	return rc;
+
+}
+
+static int __ov9665_probe(struct platform_device *pdev)
+{
+	int rc;
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+
+	if (sdata->camera_main_get_probe != NULL) {
+		if (sdata->camera_main_get_probe()) {
+			pr_info("__s5k6aafx_probe camera main get probed already.\n");
+			return 0;
+		}
+	}
+	return msm_camera_drv_start(pdev, ov9665_sensor_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __ov9665_probe,
+	.driver = {
+		   .name = "msm_camera_ov9665",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init ov9665_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(ov9665_init);
diff --git a/drivers/media/video/msm/ov9665.h b/drivers/media/video/msm/ov9665.h
new file mode 100644
index 0000000..e399b86
--- /dev/null
+++ b/drivers/media/video/msm/ov9665.h
@@ -0,0 +1,54 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef MT9D112_H
+#define MT9D112_H
+
+#include <linux/types.h>
+#include <mach/camera.h>
+
+extern struct ov9665_reg ov9665_regs;
+
+enum ov9665_width {
+	WORD_LEN,
+	BYTE_LEN
+};
+
+struct ov9665_i2c_reg_conf {
+	unsigned short waddr;
+	unsigned short wdata;
+	enum ov9665_width width;
+	unsigned short mdelay_time;
+};
+
+struct ov9665_reg {
+	const struct ov9665_i2c_reg_conf *register_init;
+	uint16_t register_init_size;
+	const struct register_address_value_pair *prev_snap_reg_settings;
+	uint16_t prev_snap_reg_settings_size;
+	const struct register_address_value_pair *noise_reduction_reg_settings;
+	uint16_t noise_reduction_reg_settings_size;
+	const struct ov9665_i2c_reg_conf *plltbl;
+	uint16_t plltbl_size;
+	const struct ov9665_i2c_reg_conf *stbl;
+	uint16_t stbl_size;
+	const struct ov9665_i2c_reg_conf *rftbl;
+	uint16_t rftbl_size;
+};
+
+#endif /* MT9D112_H */
diff --git a/drivers/media/video/msm/ov9665_reg.c b/drivers/media/video/msm/ov9665_reg.c
new file mode 100644
index 0000000..46cd435
--- /dev/null
+++ b/drivers/media/video/msm/ov9665_reg.c
@@ -0,0 +1,210 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ov9665.h"
+
+
+static const struct ov9665_i2c_reg_conf const pll_setup_tbl[] = {
+	{0x3E, 0xD0, BYTE_LEN, 5},
+	{0x3E, 0xD0, BYTE_LEN, 5},
+	{0x12, 0x80, BYTE_LEN, 5}
+};
+
+/* sensor register init*/
+static const struct ov9665_i2c_reg_conf const register_init_tbl[] = {
+	/*sensor reset*/
+	{0x12, 0x80, BYTE_LEN, 1},
+	/*sensor IO output*/
+	{0xd5, 0xff, BYTE_LEN, 1},
+	{0xd6, 0x3f, BYTE_LEN, 1},
+	/*Clock 24MHz 10FPS*/
+	{0x3d, 0x3c, BYTE_LEN, 1},
+	{0x11, 0x80, BYTE_LEN, 1},/*0x81 24MHz,0x80 48MHz*/
+	{0x2a, 0x00, BYTE_LEN, 1},
+	{0x2b, 0x00, BYTE_LEN, 1},
+	/*power control*/
+	{0x3a, 0xd9, BYTE_LEN, 1},
+	{0x3b, 0x00, BYTE_LEN, 1},
+	{0x3c, 0x58, BYTE_LEN, 1},
+	{0x3e, 0x50, BYTE_LEN, 1},
+	{0x71, 0x00, BYTE_LEN, 1},
+	/*driving strengh*/
+	{0x09, 0x03, BYTE_LEN, 1},
+	/*Data Format YUV*/
+	{0xD7, 0x10, BYTE_LEN, 1},
+	{0x6a, 0x24, BYTE_LEN, 1},
+	{0x85, 0xe7, BYTE_LEN, 1},
+	/*sample option*/
+	{0x63, 0x01, BYTE_LEN, 1},
+	/*Windowing*/
+	{0x17, 0x0c, BYTE_LEN, 1},
+	{0x18, 0x5c, BYTE_LEN, 1},
+	{0x19, 0x01, BYTE_LEN, 1},
+	{0x1a, 0x82, BYTE_LEN, 1},
+	{0x03, 0x0f, BYTE_LEN, 1},
+	{0x2b, 0x00, BYTE_LEN, 1},
+	{0x32, 0x34, BYTE_LEN, 1},
+	/*BLC*/
+	{0x36, 0xb4, BYTE_LEN, 1},
+	{0x65, 0x10, BYTE_LEN, 1},
+	{0x70, 0x02, BYTE_LEN, 1},
+	{0x71, 0x9c, BYTE_LEN, 1},
+	{0x72, 0xc0, BYTE_LEN, 1}, /*For preview greenish in lowlight Weiting*/
+	{0x64, 0x24, BYTE_LEN, 1},
+	/*AEC ,Average ,9 zone*/
+	{0x43, 0x00, BYTE_LEN, 1},
+	{0x5d, 0x55, BYTE_LEN, 1},
+	{0x5e, 0x57, BYTE_LEN, 1},
+	{0x5f, 0x21, BYTE_LEN, 1},
+	/*Brightness*/
+	{0x24, 0x40, BYTE_LEN, 1}, /*upper bc 35ori 39*/
+	{0x25, 0x35, BYTE_LEN, 1}, /*lower bc 2aori 2e*/
+	{0x26, 0x82, BYTE_LEN, 1},
+	/*BF 60Hz*/
+	/*0x48 for 8xgain 28 for 4xgain  68for 16xgain*/
+	{0x14, 0x48, BYTE_LEN, 1},
+	{0x0c, 0x38, BYTE_LEN, 1},
+	{0x4f, 0x9e, BYTE_LEN, 1},
+	{0x50, 0x84, BYTE_LEN, 1},
+	{0x5a, 0x67, BYTE_LEN, 1},
+	/*LC enable*/
+	{0x7d, 0x00, BYTE_LEN, 1},
+	{0x7e, 0xa0, BYTE_LEN, 1},
+	{0x7f, 0x00, BYTE_LEN, 1},
+	{0x80, 0x09, BYTE_LEN, 1},
+	{0x81, 0x0a, BYTE_LEN, 1},
+	{0x82, 0x09, BYTE_LEN, 1},
+	{0x83, 0x07, BYTE_LEN, 1}, /*07 enable LC 06 disable*/
+	/*AWB advance*/
+	{0x96, 0xf0, BYTE_LEN, 1},
+	{0x97, 0x0a, BYTE_LEN, 1},
+	{0x92, 0x17, BYTE_LEN, 1},
+	{0x94, 0x38, BYTE_LEN, 1},
+	{0x93, 0x33, BYTE_LEN, 1},
+	{0x95, 0x49, BYTE_LEN, 1},
+	{0x91, 0xd8, BYTE_LEN, 1},
+	{0x90, 0xdf, BYTE_LEN, 1},
+	{0x8e, 0x4a, BYTE_LEN, 1},
+	{0x8f, 0x59, BYTE_LEN, 1},
+	{0x8d, 0x12, BYTE_LEN, 1},
+	{0x8c, 0x11, BYTE_LEN, 1},
+	{0x8b, 0x0c, BYTE_LEN, 1},
+	{0x86, 0x9e, BYTE_LEN, 1},
+	{0x87, 0x11, BYTE_LEN, 1},
+	{0x88, 0x22, BYTE_LEN, 1},
+	{0x89, 0x05, BYTE_LEN, 1},
+	{0x8a, 0x03, BYTE_LEN, 1},
+	/*Gamma enable for outdoor 1228*/
+	{0x9b, 0x05, BYTE_LEN, 1},  /*ori0x08  htc0d*/
+	{0x9c, 0x10, BYTE_LEN, 1},  /*ori0x16  htc19*/
+	{0x9d, 0x28, BYTE_LEN, 1},  /*ori0x2f   htc2e*/
+	{0x9e, 0x51, BYTE_LEN, 1},  /*ori0x56   htc51*/
+	{0x9f, 0x60, BYTE_LEN, 1},  /*ori0x66   htc60*/
+	{0xa0, 0x6c, BYTE_LEN, 1},  /*ori0x75   htc6c*/
+	{0xa1, 0x77, BYTE_LEN, 1},  /*ori0x80   htc77*/
+	{0xa2, 0x81, BYTE_LEN, 1},  /*ori0x88   htc81*/
+	{0xa3, 0x8a, BYTE_LEN, 1},  /*ori0x8f    htc8a*/
+	{0xa4, 0x93, BYTE_LEN, 1},  /*ori0x96   htc93*/
+	{0xa5, 0xa1, BYTE_LEN, 1},  /*ori0xa3   htca1*/
+	{0xa6, 0xae, BYTE_LEN, 1},  /*ori0xaf    htcae*/
+	{0xa7, 0xc4, BYTE_LEN, 1},  /*ori0xc4    htcc4*/
+	{0xa8, 0xd6, BYTE_LEN, 1},  /*ori0xd7    htcd6*/
+	{0xa9, 0xe7, BYTE_LEN, 1},  /*ori0xe8    htce7*/
+	{0xaa, 0x21, BYTE_LEN, 1},  /*ori0x20    htc21*/
+	/*De-noise enable auto*/
+	{0xab, 0xe7, BYTE_LEN, 1},
+	{0xb0, 0x43, BYTE_LEN, 1},
+	{0xac, 0x04, BYTE_LEN, 1},
+	{0x84, 0x80, BYTE_LEN, 1}, // For stronger de-noise ori0x50
+	/*Sharpness*/
+	{0xad, 0x24, BYTE_LEN, 1}, //Sharpness of 0-2xgain ori0x22
+	{0xd9, 0x13, BYTE_LEN, 1}, //Sharpness of 2-4,4-8xgain ori0x64
+	{0xda, 0x00, BYTE_LEN, 1}, //Sharpness of >8xgain ori0xa8
+	{0xae, 0x10, BYTE_LEN, 1},
+	/*Scaling*/
+	{0xab, 0xe7, BYTE_LEN, 1},
+	{0xb9, 0xa0, BYTE_LEN, 1},
+	{0xba, 0x80, BYTE_LEN, 1},
+	{0xbb, 0xa0, BYTE_LEN, 1},
+	{0xbc, 0x80, BYTE_LEN, 1},
+	/*CMX*/
+	{0xbd, 0x04, BYTE_LEN, 1}, /*0x08   unit0a*/
+	{0xbe, 0x1f, BYTE_LEN, 1}, /*0x19   unit12*/
+	{0xbf, 0x03, BYTE_LEN, 1}, /*0x02   unit03*/
+	{0xc0, 0x0d, BYTE_LEN, 1}, /*0x05   unit05  06*/
+	{0xc1, 0x24, BYTE_LEN, 1}, /*0x28   unit0b  2c*/
+	{0xc2, 0x30, BYTE_LEN, 1}, /*0x2e   unit10  33*/
+	{0xc3, 0x34, BYTE_LEN, 1}, /*0x27   unit10  2b*/
+	{0xc4, 0x34, BYTE_LEN, 1}, /*0x26   unit0d  2a*/
+	{0xc5, 0x01, BYTE_LEN, 1}, /*0x00   unit03*/
+	{0xc6, 0x9c, BYTE_LEN, 1}, /*0x98   unit98*/
+	{0xc7, 0x18, BYTE_LEN, 1}, /*0x18   unit98*/
+	{0x69, 0x48, BYTE_LEN, 1},
+	/*UV ave*/
+	{0x74, 0xc0, BYTE_LEN, 1},
+	/*SAT & Brightness*/
+	{0xc7, 0x18, BYTE_LEN, 1},
+	{0xc8, 0x06, BYTE_LEN, 1},
+	{0xcb, 0x40, BYTE_LEN, 1},
+	{0xcc, 0x40, BYTE_LEN, 1},
+	{0xcf, 0x00, BYTE_LEN, 1},
+	{0xd0, 0x20, BYTE_LEN, 1},
+	{0xd1, 0x00, BYTE_LEN, 1},
+	/*BLC*/
+	{0x0d, 0x82, BYTE_LEN, 1},
+	{0x0d, 0x80, BYTE_LEN, 1},
+	#if 1
+	/*UV adjustment*/
+	{0xd2, 0x80, BYTE_LEN, 1},
+	{0x7c, 0x18, BYTE_LEN, 1},
+	{0x65, 0x01, BYTE_LEN, 1},
+	{0x66, 0x00, BYTE_LEN, 1},
+	{0x41, 0xa0, BYTE_LEN, 1},
+	{0x5b, 0x08, BYTE_LEN, 1},
+	{0x60, 0x05, BYTE_LEN, 1},
+	{0x05, 0x06, BYTE_LEN, 1},
+	{0x03, 0x4f, BYTE_LEN, 1},
+	{0x72, 0xc0, BYTE_LEN, 1},
+	#endif
+	/*output driving current*/
+	{0x09, 0x03, BYTE_LEN, 1},
+	/*H/V sync signal control*/
+	{0xd8, 0xc4, BYTE_LEN, 1},
+	{0x15, 0x02, BYTE_LEN, 1},
+	/*night mode*/
+	{0x03, 0x8f, BYTE_LEN, 1}, //Control the min fps 4f ->1/2 8f ->1/4 cf->1/8
+	{0x0f, 0x4e, BYTE_LEN, 1},
+	{0x06, 0x50, BYTE_LEN, 1}, //keep fps 30 when gain<4
+#if 1
+	/*mirror and flip*/
+	{0x04, 0xa8, BYTE_LEN, 1},
+	{0x33, 0xc8, BYTE_LEN, 1}
+#else
+	/*reverse mode*/
+	{0x04, 0x28, BYTE_LEN, 1},
+	{0x33, 0xc0, BYTE_LEN, 1}
+#endif
+};
+
+
+struct ov9665_reg ov9665_regs = {
+	.register_init = &register_init_tbl,
+	.register_init_size = ARRAY_SIZE(register_init_tbl),
+	.plltbl = pll_setup_tbl,
+	.plltbl_size = ARRAY_SIZE(pll_setup_tbl),
+};
diff --git a/drivers/media/video/msm/s5k3e2fx.c b/drivers/media/video/msm/s5k3e2fx.c
index 8a101c6..e548d58 100644
--- a/drivers/media/video/msm/s5k3e2fx.c
+++ b/drivers/media/video/msm/s5k3e2fx.c
@@ -14,11 +14,13 @@
 #include <mach/camera.h>
 #include <linux/clk.h>
 #include <linux/wakelock.h>
+#include <linux/earlysuspend.h>
+
 
 static uint16_t g_usModuleVersion;	/*0: rev.4, 1: rev.5 */
 
 /* prepare for modify PCLK*/
-#define REG_PLL_MULTIPLIER_LSB_VALUE	  0xA6
+#define REG_PLL_MULTIPLIER_LSB_VALUE      0xA6
 /* 0xA6 for PCLK=83MHz */
 /* 0xA0 for PCLK=80MHz */
 /* 0x90 for PCLK=72MHz */
@@ -44,11 +46,6 @@ static uint16_t g_usModuleVersion;	/*0: rev.4, 1: rev.5 */
 #define GROUPED_PARAMETER_HOLD        0x01
 #define GROUPED_PARAMETER_UPDATE      0x00
 
-/* Greenish in low light */
-#define REG_MASK_CORRUPTED_FRAMES     0x0105
-#define MASK                          0x01
-#define NO_MASK                       0x00
-
 /* PLL Registers */
 #define REG_PRE_PLL_CLK_DIV           0x0305
 #define REG_PLL_MULTIPLIER_MSB        0x0306
@@ -139,7 +136,7 @@ static uint16_t g_usModuleVersion;	/*0: rev.4, 1: rev.5 */
 #define REG_301B_RESERVED             0x301B
 #define REG_30BD_RESERVED             0x30BD
 #define REG_30C2_RESERVED             0x30C2
-#define REG_3151_RESERVED             0x3151
+#define REG_3151_RESERVED             0x3151 /* 100202 the right address is 0x3151 */
 #define REG_3029_RESERVED             0x3029
 #define REG_30BF_RESERVED             0x30BF
 #define REG_3022_RESERVED             0x3022
@@ -171,8 +168,6 @@ static uint16_t g_usModuleVersion;	/*0: rev.4, 1: rev.5 */
 #define REG_Y_ADDR_END_MSB            0x034A
 #define REG_Y_ADDR_END_LSB            0x034B
 
-#define NUM_INIT_REG                  94
-#define NUM_LC_REG                    434
 
 struct s5k3e2fx_i2c_reg_conf {
 	unsigned short waddr;
@@ -180,32 +175,21 @@ struct s5k3e2fx_i2c_reg_conf {
 };
 
 /* Separate the EVT4/EVT5 sensor init and LC setting start */
-struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
+
+struct s5k3e2fx_i2c_reg_conf Init_setting_evt4[] = {
 /*EVT4 */
-	{
 	 {REG_PRE_PLL_CLK_DIV, 0x06},	/* PLL setting */
 	 {REG_PLL_MULTIPLIER_MSB, 0x00},
-	 {REG_PLL_MULTIPLIER_LSB, REG_PLL_MULTIPLIER_LSB_VALUE},
+	 {REG_PLL_MULTIPLIER_LSB, 0x83},
 	 {REG_VT_PIX_CLK_DIV, 0x08},
 	 {REG_VT_SYS_CLK_DIV, 0x01},
 	 {REG_OP_PIX_CLK_DIV, 0x08},
 	 {REG_OP_SYS_CLK_DIV, 0x01},
-/* Data Format */
-	 {REG_CCP_DATA_FORMAT_MSB, 0x0a},
-	 {REG_CCP_DATA_FORMAT_LSB, 0x0a},
 /* Preview Output Size */
 	 {REG_X_OUTPUT_SIZE_MSB, 0x05},
 	 {REG_X_OUTPUT_SIZE_LSB, 0x10},
 	 {REG_Y_OUTPUT_SIZE_MSB, 0x03},
 	 {REG_Y_OUTPUT_SIZE_LSB, 0xcc},
-	 {REG_X_ADDR_START_MSB, 0x00},
-	 {REG_X_ADDR_START_LSB, 0x08},
-	 {REG_Y_ADDR_START_MSB, 0x00},
-	 {REG_Y_ADDR_START_LSB, 0x08},
-	 {REG_X_ADDR_END_MSB, 0x0a},
-	 {REG_X_ADDR_END_LSB, 0x27},
-	 {REG_Y_ADDR_END_MSB, 0x07},
-	 {REG_Y_ADDR_END_LSB, 0x9f},
 /* Frame format */
 	 {REG_FRAME_LENGTH_LINES_MSB, 0x03},
 	 {REG_FRAME_LENGTH_LINES_LSB, 0xe2},
@@ -231,72 +215,44 @@ struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
 	 {REG_S1S_END, 0x93},
 	 {REG_S3_START, 0x05},
 	 {REG_S3_END, 0x3a},
-	 {REG_CMP_EN_START, 0x10},
 	 {REG_CLP_SL_START, 0x02},
 	 {REG_CLP_SL_END, 0x3e},
-	 {REG_OFF_START, 0x02},
 	 {REG_RMP_EN_START, 0x0e},
 	 {REG_TX_START, 0x46},
 	 {REG_TX_END, 0x64},
 	 {REG_STX_WIDTH, 0x1e},
-	 {REG_CLAMP_ON, 0x00},
 	 {REG_301D_RESERVED, 0x3f},
 	 {REG_VPIX, 0x04},
 	 {REG_3028_RESERVED, 0x40},
 	 {REG_3070_RESERVED, 0xdf},
-	 {REG_3072_RESERVED, 0x20},
 	 {REG_301B_RESERVED, 0x73},
 	 {REG_OFFSET, 0x02},
 	 {REG_30BD_RESERVED, 0x06},
 	 {REG_30C2_RESERVED, 0x0b},
 	 {REG_SHADE_CLK_ENABLE, 0x81},
-	 {REG_3151_RESERVED, 0xe6},
+	 {0x3151, 0xe6},
 	 {REG_3029_RESERVED, 0x02},
 	 {REG_30BF_RESERVED, 0x00},
 	 {REG_3022_RESERVED, 0x87},
 	 {REG_3019_RESERVED, 0x60},
-	 {REG_3019_RESERVED, 0x60},
-	 {REG_3019_RESERVED, 0x60},
-	 {REG_3019_RESERVED, 0x60},
-	 {REG_3019_RESERVED, 0x60},
-	 {REG_3019_RESERVED, 0x60},
+	 {0x3146, 0x3c},
 	 {REG_3152_RESERVED, 0x08},
-	 {REG_3150_RESERVED, 0x50}, /* from 0x40 to 0x50 for PCLK=80MHz */
-/* Inverse PCLK = 0x50 */
-	 {REG_3157_RESERVED, 0x04}, /* from 0x00 to 0x04 for PCLK=80MHz */
-/* PCLK Delay offset; 0x0a will delay around 4ns at 80MHz */
-	 {REG_3159_RESERVED, 0x0f}, /* from 0x00 to 0x0f for PCLK=80MHz */
+	 {REG_3159_RESERVED, 0x0A},
 /* HS, VS driving strength [3:2]=>VS, [1:0]=>HS 00:2mA, 01:4mA, 10:6mA,
  * 11:8mA
  */
-	 {REG_315A_RESERVED, 0xf0}, /* from 0x10 to 0xf0 for PCLK=80MHz */
+	 {REG_315A_RESERVED, 0xAA},
 /* PCLK, DATA driving strength [7:6]=>data, [5:4]=>PCLK 00:2mA, 01:4mA
  * 10:6mA, 11:8mA
  */
 /* AEC Setting */
-	 {REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB, 0x00},
 	 {REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB, REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB_VALUE},
 	 {REG_FINE_INTEGRATION_TIME, 0x02},
 	 {REG_COARSE_INTEGRATION_TIME, 0x03},
-/* Preview LC config Setting */
-	 {REG_SH4CH_BLK_WIDTH_R, 0x52},
-	 {REG_SH4CH_BLK_HEIGHT_R, 0x3e},
-	 {REG_SH4CH_STEP_X_R_MSB, 0x03},
-	 {REG_SH4CH_STEP_X_R_LSB, 0x1f},
-	 {REG_SH4CH_STEP_Y_R_MSB, 0x04},
-	 {REG_SH4CH_STEP_Y_R_LSB, 0x21},
-	 {REG_SH4CH_START_BLK_CNT_X_R, 0x04},
-	 {REG_SH4CH_START_BLK_INT_X_R, 0x00},
-	 {REG_SH4CH_START_FRAC_X_R_MSB, 0x0c},
-	 {REG_SH4CH_START_FRAC_X_R_LSB, 0x7c},
-	 {REG_SH4CH_START_BLK_CNT_Y_R, 0x04},
-	 {REG_SH4CH_START_BLK_INT_Y_R, 0x00},
-	 {REG_SH4CH_START_FRAC_Y_R_MSB, 0x10},
-	 {REG_SH4CH_START_FRAC_Y_R_LSB, 0x84},
-	 },
+};
 
+struct s5k3e2fx_i2c_reg_conf Init_setting_evt5[] = {
 /* EVT5 */
-	{
 	 {REG_PRE_PLL_CLK_DIV, 0x06}, /* PLL setting */
 	 {REG_PLL_MULTIPLIER_MSB, 0x00},
 	 {REG_PLL_MULTIPLIER_LSB, REG_PLL_MULTIPLIER_LSB_VALUE},
@@ -313,13 +269,13 @@ struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
 	 {REG_Y_OUTPUT_SIZE_MSB, 0x03},
 	 {REG_Y_OUTPUT_SIZE_LSB, 0xcc},
 	 {REG_X_ADDR_START_MSB, 0x00},
-	 {REG_X_ADDR_START_LSB, 0x08},
+	 {REG_X_ADDR_START_LSB, 0x00},  /* 100202 Change to 00 to the same as DesireC */
 	 {REG_Y_ADDR_START_MSB, 0x00},
-	 {REG_Y_ADDR_START_LSB, 0x08},
+	 {REG_Y_ADDR_START_LSB, 0x00},  /* 100202 Change to 00 to the same as DesireC */
 	 {REG_X_ADDR_END_MSB, 0x0a},
-	 {REG_X_ADDR_END_LSB, 0x27},
+	 {REG_X_ADDR_END_LSB, 0x2F},  /* 100202 Change to 2F to the same as DesireC */
 	 {REG_Y_ADDR_END_MSB, 0x07},
-	 {REG_Y_ADDR_END_LSB, 0x9f},
+	 {REG_Y_ADDR_END_LSB, 0xA7},  /* 100202 Change to A7 to the same as DesireC */
 /* Frame format */
 	 {REG_FRAME_LENGTH_LINES_MSB, 0x03},
 	 {REG_FRAME_LENGTH_LINES_LSB, 0xe2},
@@ -364,7 +320,7 @@ struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
 	 {REG_30BD_RESERVED, 0x06},
 	 {REG_30C2_RESERVED, 0x0b},
 	 {REG_SHADE_CLK_ENABLE, 0x81},
-	 {REG_3151_RESERVED, 0xe6},
+	 {REG_3151_RESERVED, 0xe6}, /* 100202 the right address is 0x3151 */
 	 {REG_3029_RESERVED, 0x02},
 	 {REG_30BF_RESERVED, 0x00},
 	 {REG_3022_RESERVED, 0x87},
@@ -388,7 +344,6 @@ struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
  * 10:6mA, 11:8mA
  */
 /* AEC Setting */
-	 {REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB, 0x00},
 	 {REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB, REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB_VALUE},
 	 {REG_FINE_INTEGRATION_TIME, 0x02},
 	 {REG_COARSE_INTEGRATION_TIME, 0x03},
@@ -407,454 +362,463 @@ struct s5k3e2fx_i2c_reg_conf Init_setting[2][NUM_INIT_REG] = {
 	 {REG_SH4CH_START_BLK_INT_Y_R, 0x00},
 	 {REG_SH4CH_START_FRAC_Y_R_MSB, 0x10},
 	 {REG_SH4CH_START_FRAC_Y_R_LSB, 0x84},
-	 }
 };
 
-struct s5k3e2fx_i2c_reg_conf lc_setting[2][NUM_LC_REG] = {
-/*EVT4 */
-	{
-	/*EVT4 */  /* 100108 Modify LC setting DNP light source t75-r73*/
+struct s5k3e2fx_i2c_reg_conf lc_setting_evt4[] = {
+	/*EVT4 */
 	{0x3200, 0x00},
-	{0x3201, 0x99},
-	{0x3202, 0xc1},
+	{0x3201, 0xbe},
+	{0x3202, 0x4e},
 	{0x3203, 0x0f},
-	{0x3204, 0xd0},
-	{0x3205, 0x1b},
+	{0x3204, 0xb9},
+	{0x3205, 0x07},
 	{0x3206, 0x00},
-	{0x3207, 0x24},
-	{0x3208, 0x8d},
+	{0x3207, 0x4b},
+	{0x3208, 0xdf},
 	{0x3209, 0x0f},
-	{0x320a, 0xee},
-	{0x320b, 0x0f},
+	{0x320a, 0xc6},
+	{0x320b, 0x39},
 	{0x320c, 0x00},
-	{0x320d, 0x04},
-	{0x320e, 0x5c},
+	{0x320d, 0x13},
+	{0x320e, 0xee},
 	{0x320f, 0x00},
-	{0x3210, 0x07},
-	{0x3211, 0x68},
+	{0x3210, 0x14},
+	{0x3211, 0x79},
 	{0x3212, 0x0f},
-	{0x3213, 0xc2},
-	{0x3214, 0x82},
+	{0x3213, 0x9d},
+	{0x3214, 0xed},
 	{0x3215, 0x00},
-	{0x3216, 0x29},
-	{0x3217, 0x3e},
+	{0x3216, 0x3d},
+	{0x3217, 0x02},
 	{0x3218, 0x0f},
-	{0x3219, 0xd3},
-	{0x321a, 0x63},
+	{0x3219, 0xa8},
+	{0x321a, 0x6a},
 	{0x321b, 0x00},
-	{0x321c, 0x22},
-	{0x321d, 0x6c},
+	{0x321c, 0x4c},
+	{0x321d, 0x9a},
 	{0x321e, 0x0f},
-	{0x321f, 0xf8},
-	{0x3220, 0xce},
+	{0x321f, 0xfb},
+	{0x3220, 0xdb},
 	{0x3221, 0x0f},
-	{0x3222, 0xed},
-	{0x3223, 0x30},
+	{0x3222, 0xc8},
+	{0x3223, 0x1a},
 	{0x3224, 0x00},
-	{0x3225, 0x37},
-	{0x3226, 0x87},
+	{0x3225, 0x5b},
+	{0x3226, 0xf3},
 	{0x3227, 0x0f},
-	{0x3228, 0xc2},
-	{0x3229, 0x87},
+	{0x3228, 0xae},
+	{0x3229, 0xe3},
 	{0x322a, 0x00},
-	{0x322b, 0x2a},
-	{0x322c, 0xc6},
+	{0x322b, 0x5b},
+	{0x322c, 0xc8},
 	{0x322d, 0x0f},
-	{0x322e, 0xf3},
-	{0x322f, 0xd9},
+	{0x322e, 0xc3},
+	{0x322f, 0xf6},
 	{0x3230, 0x0f},
-	{0x3231, 0xea},
-	{0x3232, 0x1a},
+	{0x3231, 0xe4},
+	{0x3232, 0xb3},
 	{0x3233, 0x00},
-	{0x3234, 0x2d},
-	{0x3235, 0x9f},
+	{0x3234, 0x58},
+	{0x3235, 0xdf},
 	{0x3236, 0x0f},
-	{0x3237, 0xde},
-	{0x3238, 0x7d},
+	{0x3237, 0xbf},
+	{0x3238, 0x67},
 	{0x3239, 0x00},
-	{0x323a, 0x37},
-	{0x323b, 0x1e},
+	{0x323a, 0x3c},
+	{0x323b, 0x8e},
 	{0x323c, 0x0f},
-	{0x323d, 0xed},
-	{0x323e, 0x9c},
-	{0x323f, 0x0f},
-	{0x3240, 0xf6},
+	{0x323d, 0xd0},
+	{0x323e, 0x3d},
+	{0x323f, 0x00},
+	{0x3240, 0x11},
 	{0x3241, 0xfd},
 	{0x3242, 0x00},
-	{0x3243, 0x15},
-	{0x3244, 0xeb},
+	{0x3243, 0x1a},
+	{0x3244, 0xf0},
 	{0x3245, 0x0f},
-	{0x3246, 0xd3},
-	{0x3247, 0xca},
+	{0x3246, 0xbd},
+	{0x3247, 0x5d},
 	{0x3248, 0x00},
-	{0x3249, 0x08},
-	{0x324a, 0xe6},
+	{0x3249, 0x22},
+	{0x324a, 0x32},
 	{0x324b, 0x0f},
-	{0x324c, 0xf4},
-	{0x324d, 0x7a},
+	{0x324c, 0xff},
+	{0x324d, 0x2e},
 	{0x324e, 0x0f},
-	{0x324f, 0xed},
-	{0x3250, 0x1e},
+	{0x324f, 0xeb},
+	{0x3250, 0x0c},
 	{0x3251, 0x00},
-	{0x3252, 0x0d},
-	{0x3253, 0x46},
+	{0x3252, 0x11},
+	{0x3253, 0xbd},
 	{0x3254, 0x00},
-	{0x3255, 0x0c},
-	{0x3256, 0x3e},
-	{0x3257, 0x00},
-	{0x3258, 0x09},
-	{0x3259, 0xcf},
+	{0x3255, 0x17},
+	{0x3256, 0xda},
+	{0x3257, 0x0f},
+	{0x3258, 0xeb},
+	{0x3259, 0xf9},
 	{0x325a, 0x00},
-	{0x325b, 0x09},
-	{0x325c, 0xb5},
+	{0x325b, 0x00},
+	{0x325c, 0x81},
 	{0x325d, 0x0f},
-	{0x325e, 0xec},
-	{0x325f, 0x47},
+	{0x325e, 0xdf},
+	{0x325f, 0x3e},
 	{0x3260, 0x00},
-	{0x3261, 0x1d},
-	{0x3262, 0xd8},
+	{0x3261, 0x2c},
+	{0x3262, 0x9f},
 	{0x3263, 0x0f},
-	{0x3264, 0xf7},
-	{0x3265, 0x11},
+	{0x3264, 0xe9},
+	{0x3265, 0xd7},
 	{0x3266, 0x0f},
-	{0x3267, 0xea},
-	{0x3268, 0x3d},
+	{0x3267, 0xd1},
+	{0x3268, 0x83},
 	{0x3269, 0x00},
-	{0x326a, 0x09},
-	{0x326b, 0xcc},
+	{0x326a, 0x3e},
+	{0x326b, 0x18},
 	{0x326c, 0x00},
-	{0x326d, 0x9b},
-	{0x326e, 0x73},
+	{0x326d, 0xcb},
+	{0x326e, 0x32},
 	{0x326f, 0x0f},
-	{0x3270, 0xd4},
-	{0x3271, 0x9e},
+	{0x3270, 0xaf},
+	{0x3271, 0xe3},
 	{0x3272, 0x00},
-	{0x3273, 0x1a},
-	{0x3274, 0x87},
+	{0x3273, 0x51},
+	{0x3274, 0xc8},
 	{0x3275, 0x0f},
-	{0x3276, 0xfd},
-	{0x3277, 0xeb},
-	{0x3278, 0x0f},
-	{0x3279, 0xf5},
-	{0x327a, 0xb4},
+	{0x3276, 0xc5},
+	{0x3277, 0x4c},
+	{0x3278, 0x00},
+	{0x3279, 0x13},
+	{0x327a, 0x30},
 	{0x327b, 0x00},
-	{0x327c, 0x0d},
-	{0x327d, 0x8c},
+	{0x327c, 0x15},
+	{0x327d, 0x7b},
 	{0x327e, 0x0f},
-	{0x327f, 0xc9},
-	{0x3280, 0x4d},
+	{0x327f, 0x97},
+	{0x3280, 0x3f},
 	{0x3281, 0x00},
-	{0x3282, 0x1d},
-	{0x3283, 0x2d},
+	{0x3282, 0x3e},
+	{0x3283, 0x26},
 	{0x3284, 0x0f},
-	{0x3285, 0xea},
-	{0x3286, 0x5b},
+	{0x3285, 0xb3},
+	{0x3286, 0x02},
 	{0x3287, 0x00},
-	{0x3288, 0x04},
-	{0x3289, 0x76},
+	{0x3288, 0x37},
+	{0x3289, 0x73},
 	{0x328a, 0x00},
-	{0x328b, 0x10},
-	{0x328c, 0x2d},
+	{0x328b, 0x0f},
+	{0x328c, 0xd7},
 	{0x328d, 0x0f},
-	{0x328e, 0xe6},
-	{0x328f, 0xde},
+	{0x328e, 0xbf},
+	{0x328f, 0xdc},
 	{0x3290, 0x00},
-	{0x3291, 0x26},
-	{0x3292, 0x85},
+	{0x3291, 0x5a},
+	{0x3292, 0x9b},
 	{0x3293, 0x0f},
-	{0x3294, 0xcf},
-	{0x3295, 0x12},
+	{0x3294, 0xaf},
+	{0x3295, 0x68},
 	{0x3296, 0x00},
-	{0x3297, 0x14},
-	{0x3298, 0x0f},
-	{0x3299, 0x00},
-	{0x329a, 0x0b},
-	{0x329b, 0x36},
+	{0x3297, 0x4c},
+	{0x3298, 0xdb},
+	{0x3299, 0x0f},
+	{0x329a, 0xdc},
+	{0x329b, 0xb5},
 	{0x329c, 0x0f},
-	{0x329d, 0xe4},
-	{0x329e, 0xa4},
+	{0x329d, 0xca},
+	{0x329e, 0x69},
 	{0x329f, 0x00},
-	{0x32a0, 0x21},
-	{0x32a1, 0x1f},
+	{0x32a0, 0x68},
+	{0x32a1, 0x0a},
 	{0x32a2, 0x0f},
-	{0x32a3, 0xf3},
-	{0x32a4, 0x99},
+	{0x32a3, 0xc9},
+	{0x32a4, 0x6c},
 	{0x32a5, 0x00},
-	{0x32a6, 0x30},
-	{0x32a7, 0x8f},
+	{0x32a6, 0x37},
+	{0x32a7, 0x6e},
 	{0x32a8, 0x0f},
-	{0x32a9, 0xf9},
-	{0x32aa, 0x35},
+	{0x32a9, 0xe2},
+	{0x32aa, 0x22},
 	{0x32ab, 0x0f},
-	{0x32ac, 0xee},
-	{0x32ad, 0x6e},
+	{0x32ac, 0xfd},
+	{0x32ad, 0x8b},
 	{0x32ae, 0x00},
-	{0x32af, 0x09},
-	{0x32b0, 0x19},
+	{0x32af, 0x36},
+	{0x32b0, 0x33},
 	{0x32b1, 0x0f},
-	{0x32b2, 0xf0},
-	{0x32b3, 0x57},
+	{0x32b2, 0xa3},
+	{0x32b3, 0xf7},
 	{0x32b4, 0x00},
-	{0x32b5, 0x01},
-	{0x32b6, 0xcc},
-	{0x32b7, 0x0f},
-	{0x32b8, 0xf1},
-	{0x32b9, 0x0b},
+	{0x32b5, 0x1b},
+	{0x32b6, 0xd5},
+	{0x32b7, 0x00},
+	{0x32b8, 0x0a},
+	{0x32b9, 0x4f},
 	{0x32ba, 0x0f},
-	{0x32bb, 0xee},
-	{0x32bc, 0x99},
+	{0x32bb, 0xd6},
+	{0x32bc, 0x4d},
 	{0x32bd, 0x00},
-	{0x32be, 0x11},
-	{0x32bf, 0x3d},
-	{0x32c0, 0x00},
-	{0x32c1, 0x10},
-	{0x32c2, 0x64},
-	{0x32c3, 0x0f},
-	{0x32c4, 0xf6},
-	{0x32c5, 0xab},
+	{0x32be, 0x21},
+	{0x32bf, 0x85},
+	{0x32c0, 0x0f},
+	{0x32c1, 0xfc},
+	{0x32c2, 0x04},
+	{0x32c3, 0x00},
+	{0x32c4, 0x10},
+	{0x32c5, 0x8c},
 	{0x32c6, 0x00},
-	{0x32c7, 0x03},
-	{0x32c8, 0x19},
+	{0x32c7, 0x00},
+	{0x32c8, 0xf5},
 	{0x32c9, 0x0f},
-	{0x32ca, 0xf3},
-	{0x32cb, 0xc9},
+	{0x32ca, 0xd4},
+	{0x32cb, 0xf3},
 	{0x32cc, 0x00},
-	{0x32cd, 0x17},
-	{0x32ce, 0xb3},
+	{0x32cd, 0x3b},
+	{0x32ce, 0x31},
 	{0x32cf, 0x0f},
-	{0x32d0, 0xf2},
-	{0x32d1, 0x3d},
+	{0x32d0, 0xe0},
+	{0x32d1, 0xb3},
 	{0x32d2, 0x0f},
-	{0x32d3, 0xf4},
-	{0x32d4, 0x7e},
+	{0x32d3, 0xe4},
+	{0x32d4, 0xa1},
 	{0x32d5, 0x00},
-	{0x32d6, 0x09},
-	{0x32d7, 0x46},
+	{0x32d6, 0x22},
+	{0x32d7, 0x10},
 	{0x32d8, 0x00},
-	{0x32d9, 0x7c},
-	{0x32da, 0x79},
+	{0x32d9, 0xa7},
+	{0x32da, 0x91},
 	{0x32db, 0x0f},
-	{0x32dc, 0xde},
-	{0x32dd, 0x19},
+	{0x32dc, 0xc6},
+	{0x32dd, 0xd2},
 	{0x32de, 0x00},
-	{0x32df, 0x19},
-	{0x32e0, 0xe8},
+	{0x32df, 0x3a},
+	{0x32e0, 0x5e},
 	{0x32e1, 0x0f},
-	{0x32e2, 0xf3},
-	{0x32e3, 0x41},
+	{0x32e2, 0xd6},
+	{0x32e3, 0xe0},
 	{0x32e4, 0x00},
-	{0x32e5, 0x03},
-	{0x32e6, 0x4c},
+	{0x32e5, 0x0f},
+	{0x32e6, 0xa2},
 	{0x32e7, 0x00},
-	{0x32e8, 0x05},
-	{0x32e9, 0x73},
+	{0x32e8, 0x0b},
+	{0x32e9, 0x02},
 	{0x32ea, 0x0f},
-	{0x32eb, 0xd6},
-	{0x32ec, 0xa5},
+	{0x32eb, 0xb3},
+	{0x32ec, 0xdd},
 	{0x32ed, 0x00},
-	{0x32ee, 0x1f},
-	{0x32ef, 0x81},
+	{0x32ee, 0x2f},
+	{0x32ef, 0xa2},
 	{0x32f0, 0x0f},
-	{0x32f1, 0xdc},
-	{0x32f2, 0xe6},
+	{0x32f1, 0xbb},
+	{0x32f2, 0x1f},
 	{0x32f3, 0x00},
-	{0x32f4, 0x18},
-	{0x32f5, 0x65},
-	{0x32f6, 0x00},
-	{0x32f7, 0x00},
-	{0x32f8, 0x11},
+	{0x32f4, 0x38},
+	{0x32f5, 0x09},
+	{0x32f6, 0x0f},
+	{0x32f7, 0xfc},
+	{0x32f8, 0xc4},
 	{0x32f9, 0x0f},
-	{0x32fa, 0xed},
-	{0x32fb, 0x65},
+	{0x32fa, 0xde},
+	{0x32fb, 0x51},
 	{0x32fc, 0x00},
-	{0x32fd, 0x23},
-	{0x32fe, 0x12},
+	{0x32fd, 0x3c},
+	{0x32fe, 0xdb},
 	{0x32ff, 0x0f},
-	{0x3300, 0xcf},
-	{0x3301, 0x28},
+	{0x3300, 0xc3},
+	{0x3301, 0x2e},
 	{0x3302, 0x00},
-	{0x3303, 0x2b},
-	{0x3304, 0xda},
+	{0x3303, 0x4a},
+	{0x3304, 0x96},
 	{0x3305, 0x0f},
-	{0x3306, 0xef},
-	{0x3307, 0xae},
+	{0x3306, 0xd7},
+	{0x3307, 0x20},
 	{0x3308, 0x0f},
-	{0x3309, 0xeb},
-	{0x330a, 0x13},
+	{0x3309, 0xe3},
+	{0x330a, 0x64},
 	{0x330b, 0x00},
-	{0x330c, 0x27},
-	{0x330d, 0xb8},
+	{0x330c, 0x3b},
+	{0x330d, 0xde},
 	{0x330e, 0x0f},
-	{0x330f, 0xec},
-	{0x3310, 0x69},
+	{0x330f, 0xe2},
+	{0x3310, 0xb6},
 	{0x3311, 0x00},
-	{0x3312, 0x2f},
-	{0x3313, 0x5f},
+	{0x3312, 0x29},
+	{0x3313, 0xfd},
 	{0x3314, 0x0f},
-	{0x3315, 0xdf},
-	{0x3316, 0x4f},
+	{0x3315, 0xd3},
+	{0x3316, 0xee},
 	{0x3317, 0x00},
-	{0x3318, 0x05},
-	{0x3319, 0x70},
+	{0x3318, 0x0c},
+	{0x3319, 0x40},
 	{0x331a, 0x00},
-	{0x331b, 0x0f},
-	{0x331c, 0xd2},
+	{0x331b, 0x1d},
+	{0x331c, 0x96},
 	{0x331d, 0x0f},
-	{0x331e, 0xe1},
-	{0x331f, 0xd8},
+	{0x331e, 0xd4},
+	{0x331f, 0xd9},
 	{0x3320, 0x00},
-	{0x3321, 0x09},
-	{0x3322, 0xcf},
-	{0x3323, 0x0f},
-	{0x3324, 0xf2},
-	{0x3325, 0x6e},
+	{0x3321, 0x0e},
+	{0x3322, 0xa8},
+	{0x3323, 0x00},
+	{0x3324, 0x02},
+	{0x3325, 0xc6},
 	{0x3326, 0x0f},
-	{0x3327, 0xf6},
-	{0x3328, 0xb4},
+	{0x3327, 0xf3},
+	{0x3328, 0xc1},
 	{0x3329, 0x00},
-	{0x332a, 0x0d},
-	{0x332b, 0x87},
+	{0x332a, 0x0f},
+	{0x332b, 0xe2},
 	{0x332c, 0x00},
-	{0x332d, 0x08},
-	{0x332e, 0x1e},
+	{0x332d, 0x03},
+	{0x332e, 0x56},
 	{0x332f, 0x0f},
-	{0x3330, 0xfa},
-	{0x3331, 0x6e},
+	{0x3330, 0xf4},
+	{0x3331, 0xc0},
 	{0x3332, 0x0f},
-	{0x3333, 0xff},
-	{0x3334, 0xaa},
+	{0x3333, 0xfe},
+	{0x3334, 0xc5},
 	{0x3335, 0x0f},
-	{0x3336, 0xf2},
-	{0x3337, 0xc0},
+	{0x3336, 0xe8},
+	{0x3337, 0xb8},
 	{0x3338, 0x00},
-	{0x3339, 0x1d},
-	{0x333a, 0x18},
+	{0x3339, 0x1e},
+	{0x333a, 0xb0},
 	{0x333b, 0x0f},
-	{0x333c, 0xef},
-	{0x333d, 0xed},
+	{0x333c, 0xf2},
+	{0x333d, 0x01},
 	{0x333e, 0x0f},
-	{0x333f, 0xec},
-	{0x3340, 0xf6},
+	{0x333f, 0xe4},
+	{0x3340, 0x68},
 	{0x3341, 0x00},
-	{0x3342, 0x16},
-	{0x3343, 0x8e},
+	{0x3342, 0x27},
+	{0x3343, 0x00},
 	{0x3344, 0x00},
-	{0x3345, 0x9c},
-	{0x3346, 0x52},
+	{0x3345, 0xc0},
+	{0x3346, 0x46},
 	{0x3347, 0x0f},
-	{0x3348, 0xcf},
-	{0x3349, 0xb9},
+	{0x3348, 0xbb},
+	{0x3349, 0x8b},
 	{0x334a, 0x00},
-	{0x334b, 0x29},
-	{0x334c, 0xe9},
+	{0x334b, 0x46},
+	{0x334c, 0xea},
 	{0x334d, 0x0f},
-	{0x334e, 0xe2},
-	{0x334f, 0x83},
+	{0x334e, 0xcc},
+	{0x334f, 0xb7},
 	{0x3350, 0x00},
-	{0x3351, 0x11},
-	{0x3352, 0xcc},
-	{0x3353, 0x0f},
-	{0x3354, 0xff},
-	{0x3355, 0xf4},
+	{0x3351, 0x10},
+	{0x3352, 0x01},
+	{0x3353, 0x00},
+	{0x3354, 0x13},
+	{0x3355, 0xe1},
 	{0x3356, 0x0f},
-	{0x3357, 0xc1},
-	{0x3358, 0xa4},
+	{0x3357, 0x9f},
+	{0x3358, 0xff},
 	{0x3359, 0x00},
-	{0x335a, 0x2f},
-	{0x335b, 0xce},
+	{0x335a, 0x3d},
+	{0x335b, 0x6c},
 	{0x335c, 0x0f},
-	{0x335d, 0xc5},
-	{0x335e, 0xbb},
+	{0x335d, 0xa7},
+	{0x335e, 0x7b},
 	{0x335f, 0x00},
-	{0x3360, 0x35},
-	{0x3361, 0x2a},
+	{0x3360, 0x4b},
+	{0x3361, 0x91},
 	{0x3362, 0x0f},
-	{0x3363, 0xe6},
-	{0x3364, 0x2a},
+	{0x3363, 0xfb},
+	{0x3364, 0x99},
 	{0x3365, 0x0f},
-	{0x3366, 0xf7},
-	{0x3367, 0x44},
+	{0x3366, 0xcc},
+	{0x3367, 0x52},
 	{0x3368, 0x00},
-	{0x3369, 0x31},
-	{0x336a, 0xfe},
+	{0x3369, 0x53},
+	{0x336a, 0x00},
 	{0x336b, 0x0f},
-	{0x336c, 0xb6},
-	{0x336d, 0x84},
+	{0x336c, 0xaa},
+	{0x336d, 0xa2},
 	{0x336e, 0x00},
-	{0x336f, 0x3c},
-	{0x3370, 0x71},
+	{0x336f, 0x64},
+	{0x3370, 0xa2},
 	{0x3371, 0x0f},
-	{0x3372, 0xe5},
-	{0x3373, 0xfe},
+	{0x3372, 0xbe},
+	{0x3373, 0xc4},
 	{0x3374, 0x0f},
-	{0x3375, 0xf2},
-	{0x3376, 0x87},
+	{0x3375, 0xe4},
+	{0x3376, 0xbb},
 	{0x3377, 0x00},
-	{0x3378, 0x29},
-	{0x3379, 0x2b},
+	{0x3378, 0x56},
+	{0x3379, 0xd8},
 	{0x337a, 0x0f},
-	{0x337b, 0xe5},
-	{0x337c, 0x3f},
+	{0x337b, 0xc8},
+	{0x337c, 0xdc},
 	{0x337d, 0x00},
-	{0x337e, 0x45},
-	{0x337f, 0xc6},
+	{0x337e, 0x44},
+	{0x337f, 0xa7},
 	{0x3380, 0x0f},
-	{0x3381, 0xdf},
-	{0x3382, 0xe6},
-	{0x3383, 0x0f},
-	{0x3384, 0xfb},
-	{0x3385, 0x0f},
+	{0x3381, 0xbd},
+	{0x3382, 0xca},
+	{0x3383, 0x00},
+	{0x3384, 0x29},
+	{0x3385, 0xf7},
 	{0x3386, 0x00},
-	{0x3387, 0x0f},
-	{0x3388, 0xf4},
+	{0x3387, 0x08},
+	{0x3388, 0xf2},
 	{0x3389, 0x0f},
-	{0x338a, 0xdf},
-	{0x338b, 0x72},
+	{0x338a, 0xc6},
+	{0x338b, 0x1c},
 	{0x338c, 0x00},
-	{0x338d, 0x0e},
-	{0x338e, 0xaf},
+	{0x338d, 0x28},
+	{0x338e, 0x3b},
 	{0x338f, 0x0f},
-	{0x3390, 0xed},
-	{0x3391, 0x7a},
+	{0x3390, 0xfc},
+	{0x3391, 0x30},
 	{0x3392, 0x0f},
-	{0x3393, 0xe5},
-	{0x3394, 0xab},
+	{0x3393, 0xee},
+	{0x3394, 0x3e},
 	{0x3395, 0x00},
-	{0x3396, 0x18},
-	{0x3397, 0x43},
+	{0x3396, 0x02},
+	{0x3397, 0x32},
 	{0x3398, 0x00},
-	{0x3399, 0x1b},
-	{0x339a, 0x41},
+	{0x3399, 0x25},
+	{0x339a, 0xb6},
 	{0x339b, 0x0f},
-	{0x339c, 0xea},
-	{0x339d, 0x84},
+	{0x339c, 0xe9},
+	{0x339d, 0xd5},
 	{0x339e, 0x0f},
-	{0x339f, 0xfd},
-	{0x33a0, 0xdb},
+	{0x339f, 0xf3},
+	{0x33a0, 0x80},
 	{0x33a1, 0x0f},
-	{0x33a2, 0xe9},
-	{0x33a3, 0xbd},
+	{0x33a2, 0xda},
+	{0x33a3, 0x56},
 	{0x33a4, 0x00},
-	{0x33a5, 0x30},
-	{0x33a6, 0x77},
+	{0x33a5, 0x3c},
+	{0x33a6, 0x4a},
 	{0x33a7, 0x0f},
-	{0x33a8, 0xe9},
-	{0x33a9, 0x93},
+	{0x33a8, 0xe0},
+	{0x33a9, 0x9d},
 	{0x33aa, 0x0f},
-	{0x33ab, 0xd7},
-	{0x33ac, 0xde},
+	{0x33ab, 0xd9},
+	{0x33ac, 0x7d},
 	{0x33ad, 0x00},
-	{0x33ae, 0x2a},
-	{0x33af, 0x14},
+	{0x33ae, 0x34},
+	{0x33af, 0x54},
 	{0x309D, 0x62},
 	{0x309d, 0x22},
-
-/* LC setting End */
-	 },
+	{0x309e, 0x52},
+	{0x309f, 0x3e},
+	{0x30a0, 0x03},
+	{0x30a1, 0x1f},
+	{0x30a2, 0x04},
+	{0x30a3, 0x21},
+	{0x30a4, 0x04},
+	{0x30a5, 0x00},
+	{0x30a6, 0x0c},
+	{0x30a7, 0x7c},
+	{0x30a8, 0x04},
+	{0x30a9, 0x00},
+	{0x30aa, 0x10},
+	{0x30ab, 0x84},
+};
+struct s5k3e2fx_i2c_reg_conf lc_setting_evt5[] = {
 /*EVT5 */
-	{
 /* LC setting Start */
-	 {0x3200, 0x00}, /* 100108 Modify LC setting DNP light source t75-r73*/
+	 {0x3200, 0x00}, /* 100304 Modify LC setting DNP light source t75-r70 to improve reddish issue*/
 	 {0x3201, 0x99},
 	 {0x3202, 0xc1},
 	 {0x3203, 0x0f},
@@ -1289,7 +1253,6 @@ struct s5k3e2fx_i2c_reg_conf lc_setting[2][NUM_LC_REG] = {
 	 {0x309D, 0x62},
 	 {0x309d, 0x22}, /* shading enable */
 	 /*LC setting End */
-	 }
 }; /* lc_setting} */
 
 static struct wake_lock s5k3e2fx_wake_lock;
@@ -1385,7 +1348,7 @@ struct reg_struct {
 	uint8_t reg_30bd_reserved;	/* 0x30BD */
 	uint8_t reg_30c2_reserved;	/* 0x30C2 */
 	uint8_t shade_clk_enable;	/* 0x30AC */
-	uint8_t reg_3051_reserved;	/* 0x3051 */
+	uint8_t reg_3151_reserved;	/* 0x3151 */ /* 100202 the right address is 0x3151 */
 	uint8_t reg_3029_reserved;	/* 0x3029 */
 	uint8_t reg_30bf_reserved;	/* 0x30BF */
 	uint8_t reg_3022_reserved;	/* 0x3022 */
@@ -1402,7 +1365,8 @@ struct reg_struct {
 	uint8_t analogue_gain_code_global_msb;	/* 0x0204 */
 	uint8_t analogue_gain_code_global_lsb;	/* 0x0205 */
 	uint8_t fine_integration_time;	/* 0x0200 */
-	uint8_t coarse_integration_time;	/* 0x0202 */
+	uint8_t coarse_integration_time_msb;	/* 0x0202 */
+	uint8_t coarse_integration_time_lsb;	/* 0x0203 */  /* 100202 Add coarse_integration_time_lsb */
 /* LC Preview/Snapshot difference register */
 /* Preview LC Setting */
 	uint8_t sh4ch_blk_width_r;	/* 0x309E */
@@ -1447,13 +1411,13 @@ struct reg_struct s5k3e2fx_reg_pat[2] = {
 	 0xcc,			/* y_output_size_lsb     REG=0x034F */
 /* X-Y addr setting position. Start */
 	 0x00,			/* x_addr_start_MSB              REG=0x0344 */
-	 0x08,			/* x_addr_start_LSB              REG=0x0345 */
+	 0x00,			/* x_addr_start_LSB              REG=0x0345 */  /* 100202 Change to 00 to the same as DesireC */
 	 0x00,			/* y_addr_start_MSB              REG=0x0346 */
-	 0x08,			/* y_addr_start_LSB              REG=0x0347 */
+	 0x00,			/* y_addr_start_LSB              REG=0x0347 */  /* 100202 Change to 00 to the same as DesireC */
 	 0x0a,			/* x_addr_end_MSB                REG=0x0348 */
-	 0x27,			/* x_addr_end_LSB                REG=0x0349 */
+	 0x2F,			/* x_addr_end_LSB                REG=0x0349 */  /* 100202 Change to 2F to the same as DesireC */
 	 0x07,			/* y_addr_end_MSB                REG=0x034A */
-	 0x9f,			/* y_addr_end_LSB                REG=0x034B */
+	 0xA7,			/* y_addr_end_LSB                REG=0x034B */  /* 100202 Change to A7 to the same as DesireC */
 /* change the setting position */
 /* Frame format */
 	 0x03,			/* frame_length_lines_msb        REG=0x0340 */
@@ -1499,7 +1463,7 @@ struct reg_struct s5k3e2fx_reg_pat[2] = {
 	 0x06,			/* reg_30bd_reserved             REG=0x30BD */
 	 0x0b,			/* reg_30c2_reserved             REG=0x30C2 */
 	 0x81,			/* shade_clk_enable              REG=0x30AC */
-	 0xe6,			/* reg_3051_reserved             REG=0x3051 */
+	 0xe6,			/* reg_3151_reserved             REG=0x3151 */ /* 100202 the right address is 0x3151 */
 	 0x02,			/* reg_3029_reserved             REG=0x3029 */
 	 0x00,			/* reg_30bf_reserved             REG=0x30BF */
 	 0x87,			/* reg_3022_reserved             REG=0x3022 */
@@ -1523,7 +1487,8 @@ struct reg_struct s5k3e2fx_reg_pat[2] = {
 	 REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB_VALUE,
 				/* analogue_gain_code_global_lsb REG=0x0205 */
 	 0x02,			/* fine_integration_time         REG=0x0200 */
-	 0x03,			/* coarse_integration_time       REG=0x0202 */
+	 0x03,			/* coarse_integration_time_msb       REG=0x0202 */
+	 0x00,			/* coarse_integration_time_lsb       REG=0x0203 */  /* 100202 Add coarse_integration_time_lsb */
 /* LC Preview/Snapshot difference register. */
 /* Preview LC config Setting */
 	 0x52,			/* sh4ch_blk_width_r             REG=0x309E */
@@ -1617,7 +1582,7 @@ struct reg_struct s5k3e2fx_reg_pat[2] = {
 	 0x06,			/* reg_30bd_reserved             REG=0x30BD */
 	 0x0b,			/* reg_30c2_reserved             REG=0x30C2 */
 	 0x81,			/* shade_clk_enable              REG=0x30AC */
-	 0xe6,			/* reg_3051_reserved             REG=0x3051 */
+	 0xe6,			/* reg_3151_reserved             REG=0x3151 */ /* 100202 the right address is 0x3151 */
 	 0x02,			/* reg_3029_reserved             REG=0x3029 */
 	 0x00,			/* reg_30bf_reserved             REG=0x30BF */
 	 0x87,			/* reg_3022_reserved             REG=0x3022 */
@@ -1642,7 +1607,8 @@ struct reg_struct s5k3e2fx_reg_pat[2] = {
 	 REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB_VALUE,
 				/* analogue_gain_code_global_lsb REG=0x0205 */
 	 0x02,			/* fine_integration_time         REG=0x0200 */
-	 0x03,			/* coarse_integration_time       REG=0x0202 */
+	 0x03,			/* coarse_integration_time_msb       REG=0x0202 */
+	 0x00,			/* coarse_integration_time_lsb       REG=0x0203 */  /* 100202 Add coarse_integration_time_lsb */
 /* Add LC Preview/Snapshot diff register. */
 /* Snapshot LC config Setting */
 	 0x52,			/* sh4ch_blk_width_r             REG=0x309E */
@@ -1691,7 +1657,17 @@ struct s5k3e2fx_ctrl {
 };
 
 static struct s5k3e2fx_ctrl *s5k3e2fx_ctrl;
+static struct platform_device *s5k3e2fx_pdev;
+
+struct s5k3e2fx_waitevent{
+	uint32_t waked_up;
+	wait_queue_head_t event_wait;
+};
+static struct s5k3e2fx_waitevent s5k3e2fx_event;
+
+
 static DECLARE_WAIT_QUEUE_HEAD(s5k3e2fx_wait_queue);
+DEFINE_SEMAPHORE(s5k3e2fx_sem);
 
 #define MAX_I2C_RETRIES 20
 static int i2c_transfer_retry(struct i2c_adapter *adap,
@@ -1947,9 +1923,20 @@ probe_failure:
 	return rc;
 }
 
+static int __exit s5k3e2fx_i2c_remove(struct i2c_client *client)
+{
+	struct s5k3e2fx_work_t *sensorw = i2c_get_clientdata(client);
+	free_irq(client->irq, sensorw);
+	deinit_suspend();
+	s5k3e2fx_client = NULL;
+	kfree(sensorw);
+	return 0;
+}
+
 static struct i2c_driver s5k3e2fx_i2c_driver = {
 	.id_table = s5k3e2fx_i2c_id,
 	.probe = s5k3e2fx_i2c_probe,
+	.remove = __exit_p(s5k3e2fx_i2c_remove),
 	.driver = {
 		.name = "s5k3e2fx",
 	},
@@ -1969,159 +1956,422 @@ static int s5k3e2fx_test(enum msm_s_test_mode mo)
 	return rc;
 }
 #endif
-static int s5k3e2fx_setting(enum msm_s_reg_update rupdate,
-				enum msm_s_setting rt)
+
+static int s5k3e2fx_setting_INIT_EVT4(void)
 {
 	int rc = 0;
-	uint16_t num_lperf;
+	struct s5k3e2fx_i2c_reg_conf EVT4_INIT[] = {
+		/*pclk setting*/
+		{0x0305, 0x06},
+		{0x0306, 0x00},
+		{0x0307, 0x83},
+		{0x0301, 0x08},
+		{0x0303, 0x01},
+		{0x0309, 0x08},
+		{0x030b, 0x01},
+		/*output size*/
+		{0x034c, 0x05},
+		{0x034d, 0x10},
+		{0x034e, 0x03},
+		{0x034f, 0xcc},
+		/*frame format (min blanking)*/
+		{0x0340, 0x03},
+		{0x0341, 0xe2},
+		{0x0342, 0x0a},
+		{0x0343, 0xac},
+		/*Binning */
+		{0x0381, 0x01},
+		{0x0383, 0x01},
+		{0x0385, 0x01},
+		{0x0387, 0x03},
+		{0x3014, 0x06},
+		/*MSR setting*/
+		{0x30c4, 0x01},
+		{0x3000, 0x03},
+		{0x3001, 0x94},
+		{0x3002, 0x02},
+		{0x3003, 0x95},
+		{0x3004, 0x0f},
+		{0x3005, 0x05},
+		{0x3006, 0x3c},
+		{0x3007, 0x8c},
+		{0x3008, 0x93},
+		{0x3009, 0x05},
+		{0x300a, 0x3a},
+		{0x300c, 0x02},
+		{0x300d, 0x3e},
+		{0x300f, 0x0e},
+		{0x3010, 0x46},
+		{0x3011, 0x64},
+		{0x3012, 0x1e},
+		{0x301d, 0x3f},
+		{0x3024, 0x04},
+		{0x3028, 0x40},
+		{0x3070, 0xdf},
+		{0x301b, 0x73},
+		{0x307e, 0x02},
+		{0x30bd, 0x06},
+		{0x30c2, 0x0b},
+		{0x30ac, 0x81},
+		{0x3151, 0xe6},
+		{0x3029, 0x02},
+		{0x30bf, 0x00},
+		{0x3022, 0x87},
+		/*tune ADC to got batter yield rate in EDS*/
+		{0x3019, 0x60},
+		/*AF driving strength*/
+		{0x3146, 0x3c},
+		{0x3152, 0x08},
+		/*data pclk driving strength*/
+		{0x315a, 0x7f},
+		/*h sync v sync driving strength*/
+		{0x3159, 0x0f},
+		{0x3157, 0x03},
+		{0x0204, 0x00},
+		{0x0205, 0x80},
+		{0x0202, 0x03},
+		{0x0203, 0xd9},
+		{0x0200, 0x02},
+		{0x3130, 0x03},
+		{0x0100, 0x01},
+	};
 
-	switch (rupdate) {
-	case S_UPDATE_PERIODIC:{
-			if (rt == S_RES_PREVIEW || rt == S_RES_CAPTURE) {
-				struct s5k3e2fx_i2c_reg_conf tbl_1[] = {
-					{REG_X_OUTPUT_SIZE_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 x_output_size_msb},
-					{REG_X_OUTPUT_SIZE_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 x_output_size_lsb},
-					{REG_Y_OUTPUT_SIZE_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 y_output_size_msb},
-					{REG_Y_OUTPUT_SIZE_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 y_output_size_lsb},
-					/* Start-End address */
-					{REG_X_ADDR_START_MSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_start_MSB},
-					{REG_X_ADDR_START_LSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_start_LSB},
-					{REG_Y_ADDR_START_MSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_start_MSB},
-					{REG_Y_ADDR_START_LSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_start_LSB},
-					{REG_X_ADDR_END_MSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_end_MSB},
-					{REG_X_ADDR_END_LSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_end_LSB},
-					{REG_Y_ADDR_END_MSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_end_MSB},
-					{REG_Y_ADDR_END_LSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_end_LSB},
-					/* Binning */
-					{REG_X_EVEN_INC,
-					 s5k3e2fx_reg_pat[rt].x_even_inc},
-					{REG_X_ODD_INC,
-					 s5k3e2fx_reg_pat[rt].x_odd_inc},
-					{REG_Y_EVEN_INC,
-					 s5k3e2fx_reg_pat[rt].y_even_inc},
-					{REG_Y_ODD_INC,
-					 s5k3e2fx_reg_pat[rt].y_odd_inc},
-					{REG_BINNING_ENABLE,
-					 s5k3e2fx_reg_pat[rt].binning_enable},
-				};
-				struct s5k3e2fx_i2c_reg_conf tbl_2[] = {
-					{REG_FRAME_LENGTH_LINES_MSB, 0},
-					{REG_FRAME_LENGTH_LINES_LSB, 0},
-					{REG_LINE_LENGTH_PCK_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 line_length_pck_msb},
-					{REG_LINE_LENGTH_PCK_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 line_length_pck_lsb},
-					{REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 analogue_gain_code_global_msb},
-					{REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 analogue_gain_code_global_lsb},
-					{REG_FINE_INTEGRATION_TIME,
-					 s5k3e2fx_reg_pat[rt].
-					 fine_integration_time},
-					{REG_COARSE_INTEGRATION_TIME,
-					 s5k3e2fx_reg_pat[rt].
-					 coarse_integration_time},
-					/* LC Preview/Snapshot difference
-					 * register
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0100, 0x00);
+	msleep(30);
+	/* write REG_INIT registers */
+	rc = s5k3e2fx_i2c_write_table(&EVT4_INIT[0],
+		ARRAY_SIZE(EVT4_INIT));
+	return rc;
+}
+
+static int s5k3e2fx_setting_INIT_EVT5(enum msm_s_setting rt)
+{
+	int rc = 0;
+	struct s5k3e2fx_i2c_reg_conf EVT5_INIT[] = {
+		{S5K3E2FX_REG_MODE_SELECT,
+			S5K3E2FX_MODE_SELECT_SW_STANDBY},
+		/*Output Size */
+		{REG_X_OUTPUT_SIZE_MSB,
+			s5k3e2fx_reg_pat[rt].x_output_size_msb},
+		{REG_X_OUTPUT_SIZE_LSB,
+			s5k3e2fx_reg_pat[rt].x_output_size_lsb},
+		{REG_Y_OUTPUT_SIZE_MSB,
+			s5k3e2fx_reg_pat[rt].y_output_size_msb},
+		{REG_Y_OUTPUT_SIZE_LSB,
+			s5k3e2fx_reg_pat[rt].y_output_size_lsb},
+		/* Start-End address */
+/* 100202 Modify X_ADDR and Y_ADDR Start-end is the same between preview and snapshot like DesireC
+		{REG_X_ADDR_START_MSB,
+			s5k3e2fx_reg_pat[rt].x_addr_start_MSB},
+		{REG_X_ADDR_START_LSB,
+			s5k3e2fx_reg_pat[rt].x_addr_start_LSB},
+		{REG_Y_ADDR_START_MSB,
+			s5k3e2fx_reg_pat[rt].y_addr_start_MSB},
+		{REG_Y_ADDR_START_LSB,
+			s5k3e2fx_reg_pat[rt].y_addr_start_LSB},
+		{REG_X_ADDR_END_MSB,
+			s5k3e2fx_reg_pat[rt].x_addr_end_MSB},
+		{REG_X_ADDR_END_LSB,
+			s5k3e2fx_reg_pat[rt].x_addr_end_LSB},
+		{REG_Y_ADDR_END_MSB,
+			s5k3e2fx_reg_pat[rt].y_addr_end_MSB},
+		{REG_Y_ADDR_END_LSB,
+			s5k3e2fx_reg_pat[rt].y_addr_end_LSB},
+*/
+		/* Binning */
+		{REG_X_EVEN_INC,
+			s5k3e2fx_reg_pat[rt].x_even_inc},
+		{REG_X_ODD_INC,
+			s5k3e2fx_reg_pat[rt].x_odd_inc},
+		{REG_Y_EVEN_INC,
+			s5k3e2fx_reg_pat[rt].y_even_inc},
+		{REG_Y_ODD_INC,
+			s5k3e2fx_reg_pat[rt].y_odd_inc},
+		{REG_BINNING_ENABLE,
+			s5k3e2fx_reg_pat[rt].binning_enable},
+		/* Frame format */
+		{REG_FRAME_LENGTH_LINES_MSB,
+			s5k3e2fx_reg_pat[rt].frame_length_lines_msb},
+		{REG_FRAME_LENGTH_LINES_LSB,
+			s5k3e2fx_reg_pat[rt].frame_length_lines_lsb},
+/* 100202 Remove the AEC setting in EVT5_INIT
+		{REG_LINE_LENGTH_PCK_MSB,
+			s5k3e2fx_reg_pat[rt].line_length_pck_msb},
+		{REG_LINE_LENGTH_PCK_LSB,
+			s5k3e2fx_reg_pat[rt].line_length_pck_lsb},
+*/
+		/* MSR setting */
+/* 100202 Remove the AEC and the same value setting in EVT5_INIT
+		{REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB,
+			s5k3e2fx_reg_pat[rt].analogue_gain_code_global_msb},
+		{REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB,
+			s5k3e2fx_reg_pat[rt].analogue_gain_code_global_lsb},
+		{REG_FINE_INTEGRATION_TIME,
+			s5k3e2fx_reg_pat[rt].fine_integration_time},
+		{REG_COARSE_INTEGRATION_TIME,
+			s5k3e2fx_reg_pat[rt].coarse_integration_time_msb},
+		{REG_COARSE_INTEGRATION_TIME_LSB,
+			s5k3e2fx_reg_pat[rt].coarse_integration_time_lsb},
+*/
+		{S5K3E2FX_REG_MODE_SELECT,
+			S5K3E2FX_MODE_SELECT_STREAM},
+	};
+	/*write table*/
+	rc = s5k3e2fx_i2c_write_table(&EVT5_INIT[0], ARRAY_SIZE(EVT5_INIT));
+	if (rc < 0) {
+		pr_err("REG_INIT failed, rc=%d\n", rc);
+		return rc;
+	}
+	return rc;
+}
+
+
+static int s5k3e2fx_setting_PREIODIC_EVT4(enum msm_s_setting rt)
+{
+	int rc = 0;
+	struct s5k3e2fx_i2c_reg_conf EVT4_1[] = {
+		/*output size*/
+		{0x034c, 0x05},
+		{0x034d, 0x10},
+		{0x034e, 0x03},
+		{0x034f, 0xcc},
+		/*frame format (min blanking)*/
+		{0x0340, 0x03},
+		{0x0341, 0xe2},
+		{0x0342, 0x0a},
+		{0x0343, 0xac},
+		/*Binning*/
+		{0x0381, 0x01},
+		{0x0383, 0x01},
+		{0x0385, 0x01},
+		{0x0387, 0x03},
+		{0x3014, 0x06},
+		{0x30bf, 0x00},
+		{0x3022, 0x87},
+		/*tune ADC to got batter yield rate in EDS*/
+		{0x3019, 0x60},
+		/*AF driving strength*/
+		{0x3146, 0x3c},
+		{0x3152, 0x08},
+		/*data pclk driving strength*/
+		{0x315a, 0x7f},
+		{0x3159, 0x0f},
+		/*h sync v sync driving strength*/
+		{0x3157, 0x03},
+		{0x0204, 0x00},
+		{0x0205, 0x80},
+		{0x0202, 0x03},
+		{0x0203, 0xd9},
+		{0x0200, 0x02},
+		{0x3130, 0x03},
+		/*lens shading setting for preview*/
+		{0x309e, 0x52},
+		{0x309f, 0x3e},
+		{0x30a0, 0x03},
+		{0x30a1, 0x1f},
+		{0x30a2, 0x04},
+		{0x30a3, 0x21},
+		{0x30a4, 0x04},
+		{0x30a5, 0x00},
+		{0x30a6, 0x0c},
+		{0x30a7, 0x7c},
+		{0x30a8, 0x04},
+		{0x30a9, 0x00},
+		{0x30aa, 0x10},
+		{0x30ab, 0x84},
+		/*streaimg on*/
+		{0x0100, 0x01},
+	};
+	struct s5k3e2fx_i2c_reg_conf EVT4_2[] = {
+		/*output size*/
+		{0x034c, 0x0a},
+		{0x034d, 0x30},
+		{0x034e, 0x07},
+		{0x034f, 0xa8},
+		/*frame format (min blanking)*/
+		{0x0340, 0x07},
+		{0x0341, 0xb6},
+		{0x0342, 0x0a},
+		{0x0343, 0xac},
+		/*Binning*/
+		{0x0381, 0x01},
+		{0x0383, 0x01},
+		{0x0385, 0x01},
+		{0x0387, 0x01},
+		{0x3014, 0x00},
+		{0x30bf, 0x00},
+		{0x3022, 0x87},
+		/*tune ADC to got batter yield rate in EDS*/
+		{0x3019, 0x60},
+		/*AF driving strength*/
+		{0x3146, 0x3c},
+		{0x3152, 0x08},
+		/*data pclk driving strength*/
+		{0x315a, 0x7f},
+		/*h sync v sync driving strength*/
+		{0x3159, 0x0f},
+		{0x3157, 0x03},
+		{0x0204, 0x00},
+		{0x0205, 0x80},
+		{0x0202, 0x03},
+		{0x0203, 0xd9},
+		{0x0200, 0x02},
+		{0x3130, 0x03},
+		/*lens shading setting for snapshot*/
+		{0x309e, 0x52},
+		{0x309f, 0x7b},
+		{0x30a0, 0x03},
+		{0x30a1, 0x1f},
+		{0x30a2, 0x02},
+		{0x30a3, 0x15},
+		{0x30a4, 0x00},
+		{0x30a5, 0x00},
+		{0x30a6, 0x00},
+		{0x30a7, 0x00},
+		{0x30a8, 0x00},
+		{0x30a9, 0x00},
+		{0x30aa, 0x00},
+		{0x30ab, 0x00},
+		/*streaming on*/
+		{0x0100, 0x01},
+	};
+	struct s5k3e2fx_i2c_reg_conf EVT4_PCLK[] = {
+		/*pclk setting*/
+		{0x0305, 0x06},
+		{0x0306, 0x00},
+		{0x0307, 0x83},
+		{0x0301, 0x08},
+		{0x0303, 0x01},
+		{0x0309, 0x08},
+		{0x030b, 0x01},
+	};
+	/*streaming off*/
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0100, 0x00);
+	msleep(30);
+	/*pclk setting*/
+	rc = s5k3e2fx_i2c_write_table(&EVT4_PCLK[0], ARRAY_SIZE(EVT4_PCLK));
+	/*write table*/
+	if (rt == 0)
+		rc = s5k3e2fx_i2c_write_table(&EVT4_1[0], ARRAY_SIZE(EVT4_1));
+	else
+		rc = s5k3e2fx_i2c_write_table(&EVT4_2[0], ARRAY_SIZE(EVT4_2));
+	return rc;
+}
+
+
+static int s5k3e2fc_setting_PREIODIC_EVT5(enum msm_s_setting rt)
+{
+	int rc = 0;
+	uint16_t num_lperf;
+	struct s5k3e2fx_i2c_reg_conf tbl_1[] = {
+					/* skip doing streaming off
+					{S5K3E2FX_REG_MODE_SELECT,
+					S5K3E2FX_MODE_SELECT_SW_STANDBY},
 					 */
-					{REG_SH4CH_BLK_WIDTH_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_blk_width_r},
-					{REG_SH4CH_BLK_HEIGHT_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_blk_height_r},
-					{REG_SH4CH_STEP_X_R_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_step_x_r_MSB},
-					{REG_SH4CH_STEP_X_R_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_step_x_r_LSB},
-					{REG_SH4CH_STEP_Y_R_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_step_y_r_MSB},
-					{REG_SH4CH_STEP_Y_R_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_step_y_r_LSB},
-					{REG_SH4CH_START_BLK_CNT_X_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_blk_cnt_x_r},
-					{REG_SH4CH_START_BLK_INT_X_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_blk_int_x_r},
-					{REG_SH4CH_START_FRAC_X_R_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_frac_x_r_MSB},
-					{REG_SH4CH_START_FRAC_X_R_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_frac_x_r_LSB},
-					{REG_SH4CH_START_BLK_CNT_Y_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_blk_cnt_y_r},
-					{REG_SH4CH_START_BLK_INT_Y_R,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_blk_int_y_r},
-					{REG_SH4CH_START_FRAC_Y_R_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_frac_y_r_MSB},
-					{REG_SH4CH_START_FRAC_Y_R_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 sh4ch_start_frac_y_r_LSB},
-				};
-
-/* add EVT5 sensor Samsung difference MSR setting between Preview and Capture */
-
-				struct s5k3e2fx_i2c_reg_conf
-				    tbl_only_for_EVT5[2][2] = {
-					{	/* S_RES_PREVIEW */
-					 {0x3062, 0x00},
-					 {0x3063, 0xD6},
-					 },
-					{	/* S_RES_CAPTURE */
-					 {0x3062, 0x01},
-					 {0x3063, 0x16},
-					 }
-				};
-
-				/* Most registers are directly applied at next frame after
-				   writing except shutter and analog gain. Shutter and gain are
-				   applied at 2nd or 1st frame later depending on register
-				   writing time. When the camera is switched from preview to
-				   snapshot, the first frame may have wrong shutter/gain and
-				   should be discarded. The register REG_MASK_CORRUPTED_FRAMES
-				   can discard the frame that has wrong shutter/gain. But in
-				   preview mode, the frames should not be dropped. Otherwise
-				   the preview will not be smooth. */
-				if (rt == S_RES_PREVIEW) {
-					/* Frames will be not discarded after exposure and gain are
-					   written. */
-					s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-						REG_MASK_CORRUPTED_FRAMES, NO_MASK);
-				} else {
-					/* Solve greenish in lowlight. Prevent corrupted frame */
-					s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-						REG_MASK_CORRUPTED_FRAMES, MASK);
-				}
+		{REG_X_OUTPUT_SIZE_MSB,
+			s5k3e2fx_reg_pat[rt].x_output_size_msb},
+		{REG_X_OUTPUT_SIZE_LSB,
+			s5k3e2fx_reg_pat[rt].x_output_size_lsb},
+		{REG_Y_OUTPUT_SIZE_MSB,
+			s5k3e2fx_reg_pat[rt].y_output_size_msb},
+		{REG_Y_OUTPUT_SIZE_LSB,
+			s5k3e2fx_reg_pat[rt].y_output_size_lsb},
+		/* Start-End address */
+/* 100202 Modify X_ADDR and Y_ADDR Start-end is the same between preview and snapshot like DesireC
+		{REG_X_ADDR_START_MSB,
+			s5k3e2fx_reg_pat[rt].x_addr_start_MSB},
+		{REG_X_ADDR_START_LSB,
+			s5k3e2fx_reg_pat[rt].x_addr_start_LSB},
+		{REG_Y_ADDR_START_MSB,
+			s5k3e2fx_reg_pat[rt].y_addr_start_MSB},
+		{REG_Y_ADDR_START_LSB,
+			s5k3e2fx_reg_pat[rt].y_addr_start_LSB},
+		{REG_X_ADDR_END_MSB,
+			s5k3e2fx_reg_pat[rt].x_addr_end_MSB},
+		{REG_X_ADDR_END_LSB,
+			s5k3e2fx_reg_pat[rt].x_addr_end_LSB},
+		{REG_Y_ADDR_END_MSB,
+			s5k3e2fx_reg_pat[rt].y_addr_end_MSB},
+		{REG_Y_ADDR_END_LSB,
+			s5k3e2fx_reg_pat[rt].y_addr_end_LSB},
+*/
+		/* Binning */
+		{REG_X_EVEN_INC,
+			s5k3e2fx_reg_pat[rt].x_even_inc},
+		{REG_X_ODD_INC,
+			s5k3e2fx_reg_pat[rt].x_odd_inc},
+		{REG_Y_EVEN_INC,
+			s5k3e2fx_reg_pat[rt].y_even_inc},
+		{REG_Y_ODD_INC,
+			s5k3e2fx_reg_pat[rt].y_odd_inc},
+		{REG_BINNING_ENABLE,
+			s5k3e2fx_reg_pat[rt].binning_enable},
+	};
+	struct s5k3e2fx_i2c_reg_conf tbl_2[] = {
+		{REG_FRAME_LENGTH_LINES_MSB, 0},
+		{REG_FRAME_LENGTH_LINES_LSB, 0},
+/*  100202 Remove the AEC setting in s5k3e2fc_setting_PREIODIC_EVT5
+		{REG_LINE_LENGTH_PCK_MSB,
+			s5k3e2fx_reg_pat[rt].line_length_pck_msb},
+		{REG_LINE_LENGTH_PCK_LSB,
+			s5k3e2fx_reg_pat[rt].line_length_pck_lsb},
+		{REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB,
+			s5k3e2fx_reg_pat[rt].analogue_gain_code_global_msb},
+		{REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB,
+			s5k3e2fx_reg_pat[rt].analogue_gain_code_global_lsb},
+		{REG_FINE_INTEGRATION_TIME,
+			s5k3e2fx_reg_pat[rt].fine_integration_time},
+		{REG_COARSE_INTEGRATION_TIME,
+			s5k3e2fx_reg_pat[rt].coarse_integration_time_msb},
+		{REG_COARSE_INTEGRATION_TIME_LSB,
+			s5k3e2fx_reg_pat[rt].coarse_integration_time_lsb},
+*/
+		/* LC Preview/Snapshot difference register*/
+		{REG_SH4CH_BLK_WIDTH_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_blk_width_r},
+		{REG_SH4CH_BLK_HEIGHT_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_blk_height_r},
+		{REG_SH4CH_STEP_X_R_MSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_step_x_r_MSB},
+		{REG_SH4CH_STEP_X_R_LSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_step_x_r_LSB},
+		{REG_SH4CH_STEP_Y_R_MSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_step_y_r_MSB},
+		{REG_SH4CH_STEP_Y_R_LSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_step_y_r_LSB},
+		{REG_SH4CH_START_BLK_CNT_X_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_blk_cnt_x_r},
+		{REG_SH4CH_START_BLK_INT_X_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_blk_int_x_r},
+		{REG_SH4CH_START_FRAC_X_R_MSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_frac_x_r_MSB},
+		{REG_SH4CH_START_FRAC_X_R_LSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_frac_x_r_LSB},
+		{REG_SH4CH_START_BLK_CNT_Y_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_blk_cnt_y_r},
+		{REG_SH4CH_START_BLK_INT_Y_R,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_blk_int_y_r},
+		{REG_SH4CH_START_FRAC_Y_R_MSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_frac_y_r_MSB},
+		{REG_SH4CH_START_FRAC_Y_R_LSB,
+			s5k3e2fx_reg_pat[rt].sh4ch_start_frac_y_r_LSB},
+	};
 
+	/* add EVT5 sensor Samsung difference
+	* MSR setting between Preview and Capture
+	*/
+
+	struct s5k3e2fx_i2c_reg_conf
+		tbl_only_for_EVT5[2][2] = {
+		{	/* S_RES_PREVIEW */
+			{0x3062, 0x00},
+			{0x3063, 0xD6},
+		},
+		{	/* S_RES_CAPTURE */
+			{0x3062, 0x01},
+			{0x3063, 0x16},
+		}
+	};
 /* solve greenish: hold for both */
 				rc = s5k3e2fx_i2c_write_b(
 					s5k3e2fx_client->addr,
@@ -2130,183 +2380,102 @@ static int s5k3e2fx_setting(enum msm_s_reg_update rupdate,
 				if (rc < 0)
 					return rc;
 
-				CDBG("Binning_enable = 0x %2x"
-				     "[s5k3e2fx.c s5k3e2fx_setting]\r\n",
-				     s5k3e2fx_reg_pat[rt].binning_enable);
+	CDBG("Binning_enable = 0x %2x"
+			"[s5k3e2fx.c s5k3e2fx_setting]\r\n",
+			s5k3e2fx_reg_pat[rt].binning_enable);
+	rc = s5k3e2fx_i2c_write_table(&tbl_1[0], ARRAY_SIZE(tbl_1));
+	if (rc < 0) {
+		pr_err("UPDATE_PERIODIC, tb1_1 failed");
+		return rc;
+	}
 
-				rc = s5k3e2fx_i2c_write_table(&tbl_1[0],
-							ARRAY_SIZE
-							(tbl_1));
-				if (rc < 0) {
-					pr_err("UPDATE_PERIODIC, tb1_1 failed");
-					return rc;
-				}
-
-				num_lperf =
-				    (uint16_t) ((s5k3e2fx_reg_pat[rt].
-						 frame_length_lines_msb
-						 << 8) & 0xFF00) +
-				    s5k3e2fx_reg_pat[rt].
-				    frame_length_lines_lsb;
-
-				num_lperf =
-				    num_lperf *
-				    s5k3e2fx_ctrl->fps_divider / 0x0400;
-
-				tbl_2[0] =
-				    (struct s5k3e2fx_i2c_reg_conf) {
-					REG_FRAME_LENGTH_LINES_MSB,
-					    (num_lperf & 0xFF00) >> 8};
-				tbl_2[1] =
-				    (struct s5k3e2fx_i2c_reg_conf) {
-					REG_FRAME_LENGTH_LINES_LSB,
-					    (num_lperf & 0x00FF)};
-
-				rc = s5k3e2fx_i2c_write_table(&tbl_2[0],
-							ARRAY_SIZE
-							(tbl_2));
-				if (rc < 0) {
-					pr_err("UPDATE_PERIODIC, tb1_2 failed");
-					return rc;
-				}
-
-				/* only for evt5 */
-				if (g_usModuleVersion == 1) {
-					rc = s5k3e2fx_i2c_write_table
-					    (&tbl_only_for_EVT5[rt][0],
-					     2);
-					if (rc < 0)
-						return rc;
-				}
-
-				/* solve greenish: only release for preview */
-				if (s5k3e2fx_ctrl->sensormode == SENSOR_PREVIEW_MODE)
-				{
-					rc = s5k3e2fx_i2c_write_b(
-						s5k3e2fx_client->addr,
-						REG_GROUPED_PARAMETER_HOLD,
-						GROUPED_PARAMETER_UPDATE);
-					if (rc < 0)
-						return rc;
-				}
-
-				rc = s5k3e2fx_i2c_write_b
-					(s5k3e2fx_client->addr,
-					S5K3E2FX_REG_MODE_SELECT,
-					S5K3E2FX_MODE_SELECT_STREAM);
-				if (rc < 0)
-					return rc;
-			}
-		break; /* UPDATE_PERIODIC */
+	/* only for evt5 */
+	if (g_usModuleVersion == 1) {
+		rc = s5k3e2fx_i2c_write_table(&tbl_only_for_EVT5[rt][0], 2);
+		if (rc < 0)
+			return rc;
+	}
+
+	num_lperf = (uint16_t) ((s5k3e2fx_reg_pat[rt].frame_length_lines_msb
+		<< 8) & 0xFF00) + s5k3e2fx_reg_pat[rt].frame_length_lines_lsb;
+
+	num_lperf = num_lperf * s5k3e2fx_ctrl->fps_divider / 0x0400;
+
+	tbl_2[0] = (struct s5k3e2fx_i2c_reg_conf) {REG_FRAME_LENGTH_LINES_MSB,
+			(num_lperf & 0xFF00) >> 8};
+	tbl_2[1] = (struct s5k3e2fx_i2c_reg_conf) {REG_FRAME_LENGTH_LINES_LSB,
+			(num_lperf & 0x00FF)};
+
+	rc = s5k3e2fx_i2c_write_table(&tbl_2[0], ARRAY_SIZE(tbl_2));
+	if (rc < 0) {
+		pr_err("UPDATE_PERIODIC, tb1_2 failed");
+		return rc;
+	}
+
+/* solve greenish: only release for preview */
+	if (s5k3e2fx_ctrl->sensormode == SENSOR_PREVIEW_MODE)
+	{
+		rc = s5k3e2fx_i2c_write_b(
+			s5k3e2fx_client->addr,
+			REG_GROUPED_PARAMETER_HOLD,
+			GROUPED_PARAMETER_UPDATE);
+		if (rc < 0)
+			return rc;
+	}
+
+
+	rc = s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+			S5K3E2FX_REG_MODE_SELECT,
+			S5K3E2FX_MODE_SELECT_STREAM);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+
+static int s5k3e2fx_setting(enum msm_s_reg_update rupdate,
+				enum msm_s_setting rt)
+{
+	int rc = 0;
+	pr_info("s5k3e2fx_setting rupdate:%d g_usModuleVersion:%d\n",
+		rupdate, g_usModuleVersion);
+	switch (rupdate) {
+	case S_UPDATE_PERIODIC:{
+		if (g_usModuleVersion == 1)
+			rc = s5k3e2fc_setting_PREIODIC_EVT5(rt);
+		else
+			rc = s5k3e2fx_setting_PREIODIC_EVT4(rt);
 		}
+		break; /* UPDATE_PERIODIC */
+
 	case S_REG_INIT:{
+		if (g_usModuleVersion == 1) {
+			/*EVT5*/
 			if (rt == S_RES_PREVIEW || rt == S_RES_CAPTURE) {
-				struct s5k3e2fx_i2c_reg_conf tbl_3[] = {
-/* {S5K3E2FX_REG_SOFTWARE_RESET, S5K3E2FX_SOFTWARE_RESET},*/
-					{S5K3E2FX_REG_MODE_SELECT,
-					 S5K3E2FX_MODE_SELECT_SW_STANDBY},
-					/*Output Size */
-					{REG_X_OUTPUT_SIZE_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 x_output_size_msb},
-					{REG_X_OUTPUT_SIZE_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 x_output_size_lsb},
-					{REG_Y_OUTPUT_SIZE_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 y_output_size_msb},
-					{REG_Y_OUTPUT_SIZE_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 y_output_size_lsb},
-					/* Start-End address */
-					{REG_X_ADDR_START_MSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_start_MSB},
-					{REG_X_ADDR_START_LSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_start_LSB},
-					{REG_Y_ADDR_START_MSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_start_MSB},
-					{REG_Y_ADDR_START_LSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_start_LSB},
-					{REG_X_ADDR_END_MSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_end_MSB},
-					{REG_X_ADDR_END_LSB,
-					 s5k3e2fx_reg_pat[rt].x_addr_end_LSB},
-					{REG_Y_ADDR_END_MSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_end_MSB},
-					{REG_Y_ADDR_END_LSB,
-					 s5k3e2fx_reg_pat[rt].y_addr_end_LSB},
-					/* Binning */
-					{REG_X_EVEN_INC,
-					 s5k3e2fx_reg_pat[rt].x_even_inc},
-					{REG_X_ODD_INC,
-					 s5k3e2fx_reg_pat[rt].x_odd_inc},
-					{REG_Y_EVEN_INC,
-					 s5k3e2fx_reg_pat[rt].y_even_inc},
-					{REG_Y_ODD_INC,
-					 s5k3e2fx_reg_pat[rt].y_odd_inc},
-					{REG_BINNING_ENABLE,
-					 s5k3e2fx_reg_pat[rt].binning_enable},
-					/* Frame format */
-					{REG_FRAME_LENGTH_LINES_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 frame_length_lines_msb},
-					{REG_FRAME_LENGTH_LINES_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 frame_length_lines_lsb},
-					{REG_LINE_LENGTH_PCK_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 line_length_pck_msb},
-					{REG_LINE_LENGTH_PCK_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 line_length_pck_lsb},
-					/* MSR setting */
-					{REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB,
-					 s5k3e2fx_reg_pat[rt].
-					 analogue_gain_code_global_msb},
-					{REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB,
-					 s5k3e2fx_reg_pat[rt].
-					 analogue_gain_code_global_lsb},
-					{REG_FINE_INTEGRATION_TIME,
-					 s5k3e2fx_reg_pat[rt].
-					 fine_integration_time},
-					{REG_COARSE_INTEGRATION_TIME,
-					 s5k3e2fx_reg_pat[rt].
-					 coarse_integration_time},
-					{S5K3E2FX_REG_MODE_SELECT,
-					 S5K3E2FX_MODE_SELECT_STREAM},
-				};
 				unsigned short rData = 0;
 				mdelay(1);
-				s5k3e2fx_i2c_read_b(s5k3e2fx_client->
-						    addr,
-						    REG_3150_RESERVED,
-						    &rData);
-				s5k3e2fx_i2c_write_b(s5k3e2fx_client->
-						     addr,
-						     REG_3150_RESERVED,
-						     (rData & 0xFFFE));
+				s5k3e2fx_i2c_read_b(s5k3e2fx_client->addr,
+					REG_3150_RESERVED, &rData);
+				s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+					REG_3150_RESERVED, (rData & 0xFFFE));
 				mdelay(1);
-				s5k3e2fx_i2c_read_b(s5k3e2fx_client->
-						    addr,
-						    REG_TYPE1_AF_ENABLE,
-						    &rData);
-				s5k3e2fx_i2c_write_b(s5k3e2fx_client->
-						addr,
-						REG_TYPE1_AF_ENABLE,
-						(rData | 0x0001));
+				s5k3e2fx_i2c_read_b(s5k3e2fx_client->addr,
+					REG_TYPE1_AF_ENABLE, &rData);
+				s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+					REG_TYPE1_AF_ENABLE, (rData | 0x0001));
 				mdelay(1);
-
 				/* reset fps_divider */
 				s5k3e2fx_ctrl->fps_divider = 1 * 0x0400;
 				/* write REG_INIT registers */
-				rc = s5k3e2fx_i2c_write_table(&tbl_3[0],
-							ARRAY_SIZE
-							(tbl_3));
-				if (rc < 0) {
-					pr_err("REG_INIT failed, rc=%d\n", rc);
-					return rc;
-				}
+				s5k3e2fx_setting_INIT_EVT5(rt);
 			}
+		} else{
+			/*EVT4*/
+			s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+					REG_3150_RESERVED, 0x50);
+			s5k3e2fx_setting_INIT_EVT4();
+		}
 		}
 		break; /* REG_INIT */
 
@@ -2318,10 +2487,127 @@ static int s5k3e2fx_setting(enum msm_s_reg_update rupdate,
 	return rc;
 }
 
-static int s5k3e2fx_sensor_open_init(const struct msm_camera_sensor_info *data)
+#define MAX_LAYER_NUM 5
+#define FIRST_LAYER 9
+#define FUSE_ID_FIRST_ADDR 14
+
+static int s5k3e2fx_i2c_read_fuseid(struct sensor_cfg_data *cdata)
 {
-	int rc;
 
+	uint32_t otp_vendorid_index = 0;
+	uint32_t otp_fuseid_index = 0;
+	unsigned short otp_vendorid1[MAX_LAYER_NUM];
+	unsigned short otp_vendorid2[MAX_LAYER_NUM];
+	unsigned short otp_vendorid3[MAX_LAYER_NUM];
+	unsigned short otp_fuseid1[MAX_LAYER_NUM];
+	unsigned short otp_fuseid2[MAX_LAYER_NUM];
+	unsigned short otp_fuseid3[MAX_LAYER_NUM];
+	for (otp_vendorid_index = 0;
+		otp_vendorid_index < MAX_LAYER_NUM;
+		otp_vendorid_index++) {
+
+		s5k3e2fx_i2c_write_b(
+			s5k3e2fx_client->addr,
+			0x311A, FIRST_LAYER+otp_vendorid_index);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311B, &otp_vendorid1[otp_vendorid_index]);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311C, &otp_vendorid2[otp_vendorid_index]);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311D, &otp_vendorid3[otp_vendorid_index]);
+		pr_info("s5k3e2fx: otp_vendorid1[%d]:0x%4x\n",
+			otp_vendorid_index, otp_vendorid1[otp_vendorid_index]);
+		pr_info("s5k3e2fx: otp_vendorid2[%d]:0x%4x\n",
+			otp_vendorid_index, otp_vendorid2[otp_vendorid_index]);
+		pr_info("s5k3e2fx: otp_vendorid3[%d]:0x%4x\n",
+			otp_vendorid_index, otp_vendorid3[otp_vendorid_index]);
+		if ((otp_vendorid1[otp_vendorid_index] == 0) &&
+			(otp_vendorid2[otp_vendorid_index] == 0) &&
+			(otp_vendorid3[otp_vendorid_index] == 0) &&
+			(otp_vendorid_index != 0)) {
+			break;
+		}
+	}
+	otp_vendorid_index = otp_vendorid_index-1;
+	/*read fuse id from layer14~layer18.
+	*The last non-all-zero layer contains
+	*correct fuse id */
+
+	for (otp_fuseid_index = 0;
+		otp_fuseid_index < MAX_LAYER_NUM;
+		otp_fuseid_index++) {
+		/*give OTP the address you want to read*/
+		s5k3e2fx_i2c_write_b(
+			s5k3e2fx_client->addr,
+			0x311A, FUSE_ID_FIRST_ADDR+otp_fuseid_index);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311B, &otp_fuseid1[otp_fuseid_index]);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311C, &otp_fuseid2[otp_fuseid_index]);
+		s5k3e2fx_i2c_read_b(
+			s5k3e2fx_client->addr,
+			0x311D, &otp_fuseid3[otp_fuseid_index]);
+		pr_info("s5k3e2fx: otp_fuseid1[%d]:0x%4x\n",
+			otp_fuseid_index, otp_fuseid1[otp_fuseid_index]);
+		pr_info("s5k3e2fx: otp_fuseid2[%d]:0x%4x\n",
+			otp_fuseid_index, otp_fuseid2[otp_fuseid_index]);
+		pr_info("s5k3e2fx: otp_fuseid3[%d]:0x%4x\n",
+			otp_fuseid_index, otp_fuseid3[otp_fuseid_index]);
+		if ((otp_fuseid1[otp_fuseid_index] == 0) &&
+			(otp_fuseid2[otp_fuseid_index] == 0) &&
+			(otp_fuseid3[otp_fuseid_index] == 0) &&
+			(otp_fuseid_index != 0)) {
+				break;
+			}
+	}
+	otp_fuseid_index = otp_fuseid_index-1;
+	cdata->cfg.fuse.fuse_id_word1 = otp_vendorid_index;
+	cdata->cfg.fuse.fuse_id_word2 = otp_fuseid_index;
+	cdata->cfg.fuse.fuse_id_word3 =
+		(((uint32_t)otp_vendorid1[otp_vendorid_index])<<16) |
+		(((uint32_t)otp_vendorid2[otp_vendorid_index])<<8) |
+		((uint32_t)otp_vendorid3[otp_vendorid_index]);
+	cdata->cfg.fuse.fuse_id_word4 =
+		(((uint32_t)otp_fuseid1[otp_fuseid_index])<<16) |
+		(((uint32_t)otp_fuseid2[otp_fuseid_index])<<8) |
+		((uint32_t)otp_fuseid3[otp_fuseid_index]);
+	pr_info("s5k3e2fx: fuse->fuse_id_word1:%d\n",
+		cdata->cfg.fuse.fuse_id_word1);
+	pr_info("s5k3e2fx: fuse->fuse_id_word2:%d\n",
+		cdata->cfg.fuse.fuse_id_word2);
+	pr_info("s5k3e2fx: fuse->fuse_id_word3:0x%08x\n",
+		cdata->cfg.fuse.fuse_id_word3);
+	pr_info("s5k3e2fx: fuse->fuse_id_word4:0x%08x\n",
+		cdata->cfg.fuse.fuse_id_word4);
+	return 0;
+}
+
+static int s5k3e2fx_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+	int rc = 0;
+	int timeout;
+
+	down(&s5k3e2fx_sem);
+
+	/*check whether resume done*/
+	timeout = wait_event_interruptible_timeout(
+		s5k3e2fx_event.event_wait,
+		s5k3e2fx_event.waked_up,
+		30*HZ);
+
+	pr_info("wait event : %d timeout:%d\n",
+		s5k3e2fx_event.waked_up, timeout);
+	if (timeout == 0) {
+		up(&s5k3e2fx_sem);
+		return rc;
+	}
+
+	msm_camio_probe_on(s5k3e2fx_pdev);
 	CDBG("%s %s:%d\n", __FILE__, __func__, __LINE__);
 	s5k3e2fx_ctrl = kzalloc(sizeof(struct s5k3e2fx_ctrl), GFP_KERNEL);
 	if (!s5k3e2fx_ctrl) {
@@ -2350,6 +2636,7 @@ static int s5k3e2fx_sensor_open_init(const struct msm_camera_sensor_info *data)
 	if (rc < 0)
 		goto init_fail1;
 
+	pr_info("s5k3e2fx_ctrl->prev_res:%d\n",s5k3e2fx_ctrl->prev_res);
 	if (s5k3e2fx_ctrl->prev_res == S_QTR_SIZE)
 		rc = s5k3e2fx_setting(S_REG_INIT, S_RES_PREVIEW);
 	else
@@ -2368,14 +2655,19 @@ static int s5k3e2fx_sensor_open_init(const struct msm_camera_sensor_info *data)
 	goto init_done;
 
 init_fail1:
-	kfree(s5k3e2fx_ctrl);
+	if (s5k3e2fx_ctrl) {
+		kfree(s5k3e2fx_ctrl);
+		s5k3e2fx_ctrl = NULL;
+	}
 init_done:
+	up(&s5k3e2fx_sem);
 	return rc;
 }
 
 static void s5k3e2fx_suspend_sensor(void)
 {
 	unsigned short rData = 0;
+
 	 /*AF*/
 	s5k3e2fx_i2c_read_b(s5k3e2fx_client->addr,
 			REG_TYPE1_AF_ENABLE, &rData);
@@ -2388,10 +2680,13 @@ static void s5k3e2fx_suspend_sensor(void)
 	msleep(210);		/*for 5FPS */
 	/* hi z */
 	s5k3e2fx_i2c_read_b(s5k3e2fx_client->addr, REG_3150_RESERVED, &rData);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+	if (g_usModuleVersion == 1)
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
 			REG_3150_RESERVED, (rData | 0x0001));
+	else
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+			REG_3150_RESERVED, 0x51);
 	mdelay(1);
-
 }
 
 static int s5k3e2fx_power_down(void)
@@ -2407,8 +2702,11 @@ static int s5k3e2fx_sensor_release(void)
 
 	s5k3e2fx_suspend_sensor();
 
-	kfree(s5k3e2fx_ctrl);
-	s5k3e2fx_ctrl = NULL;
+	msm_camio_probe_off(s5k3e2fx_pdev);
+	if (s5k3e2fx_ctrl) {
+		kfree(s5k3e2fx_ctrl);
+		s5k3e2fx_ctrl = NULL;
+	}
 
 	allow_suspend();
 
@@ -2421,7 +2719,6 @@ static int s5k3e2fx_probe_init_lens_correction(
 		const struct msm_camera_sensor_info *data)
 {
 	int rc = 0;
-
 	/* LC setting */
 	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
 			     S5K3E2FX_REG_SOFTWARE_RESET,
@@ -2430,19 +2727,46 @@ static int s5k3e2fx_probe_init_lens_correction(
 	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
 			     S5K3E2FX_REG_MODE_SELECT,
 			     S5K3E2FX_MODE_SELECT_SW_STANDBY);
+
 	/*20090811  separates the EVT4/EVT5 sensor init and LC setting start */
-	s5k3e2fx_i2c_write_table(&Init_setting[g_usModuleVersion][0],
-				 NUM_INIT_REG);
+	if (g_usModuleVersion == 0)
+		s5k3e2fx_i2c_write_table(
+			&Init_setting_evt4[0],
+			ARRAY_SIZE(Init_setting_evt4));
+	else
+		s5k3e2fx_i2c_write_table(
+			&Init_setting_evt5[0],
+			ARRAY_SIZE(Init_setting_evt5));
+
+	if (g_usModuleVersion == 1) {
+		/*Only for EVT5*/
+		/* 090911  Add for Samsung VCM calibration current Start */
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x0A);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x09);
+		mdelay(5);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3145, 0x04);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3146, 0x80);
+		/* 090911 Add for Samsung VCM calibration current End */
+	} else{
+		/*for AWB auto calibration*/
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3110, 0x03);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x0A);
+		msleep(5);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3110, 0x03);
+		s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x09);
+	}
 
-	/* 090911  Add for Samsung VCM calibration current Start */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x0A);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3112, 0x09);
-	mdelay(5);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3145, 0x04);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3146, 0x80);
-	/* 090911 Add for Samsung VCM calibration current End */
+	if (g_usModuleVersion == 0)
+		s5k3e2fx_i2c_write_table(
+			&lc_setting_evt4[0],
+			ARRAY_SIZE(lc_setting_evt4));
+	else
+		s5k3e2fx_i2c_write_table(
+			&lc_setting_evt5[0],
+			ARRAY_SIZE(lc_setting_evt5));
 
-	s5k3e2fx_i2c_write_table(&lc_setting[g_usModuleVersion][0], NUM_LC_REG);
+    /* Solve EVT5 greenish in lowlight, prevent corrupted frame*/
+    s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0105,0x1);
 
 	/*20090811  separates the EVT4/EVT5 sensor init and LC setting end */
 	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
@@ -2505,8 +2829,12 @@ static uint32_t s5k3e2fx_get_pict_max_exp_lc(void)
 		snapshot_lines_per_frame =
 		    s5k3e2fx_reg_pat[S_RES_PREVIEW].size_h +
 		    s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_l;
-	else
-		snapshot_lines_per_frame = 3961 * 3;
+	else {
+		/* snapshot max linecount
+		(should be larger than transmitted preview max linecount of
+		preview ISO and chromatix gain-line table) */
+		snapshot_lines_per_frame = 3000; //3961 * 3;
+	}
 
 	return snapshot_lines_per_frame;
 }
@@ -2520,7 +2848,7 @@ static int s5k3e2fx_set_fps(struct fps_cfg *fps)
 
 	CDBG("s5k3e2fx_ctrl->fps_divider = %d\n",
 		s5k3e2fx_ctrl->fps_divider);
-
+#if 0
 	rc = s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
 				  REG_FRAME_LENGTH_LINES_MSB,
 				  (((s5k3e2fx_reg_pat[S_RES_PREVIEW].size_h +
@@ -2536,9 +2864,9 @@ static int s5k3e2fx_set_fps(struct fps_cfg *fps)
 				     s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_l) *
 				    s5k3e2fx_ctrl->fps_divider /
 				    0x400) & 0xFF00));
-
 set_fps_done:
 	return rc;
+#endif
 }
 
 static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
@@ -2546,7 +2874,7 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	int rc = 0;
 
 	uint16_t max_legal_gain = 0x0200;
-	uint32_t ll_ratio;	/* Q10 */
+	//uint32_t ll_ratio;	/* Q10 */
 	uint32_t ll_pck, fl_lines;
 	uint16_t offset = 4;
 	uint32_t gain_msb, gain_lsb;
@@ -2555,8 +2883,10 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 
 	struct s5k3e2fx_i2c_reg_conf tbl[2];
 
-	CDBG("Line:%d s5k3e2fx_write_exp_gain gain %d line %d\n",
-		__LINE__, gain, line);
+	CDBG("Line:%d s5k3e2fx_write_exp_gain \n", __LINE__);
+//printk("Steven Enter write_exp_gain User Space Gain and Line:gain = %4d, line = %6d \n", gain, line);
+//	if ((gain == 0) || (line == 0))  /* 100223 Mask this for Bright Flash In Beginning */
+//		return rc;
 
 	if (s5k3e2fx_ctrl->sensormode == SENSOR_PREVIEW_MODE) {
 
@@ -2564,23 +2894,24 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 		s5k3e2fx_ctrl->my_reg_line_count = (uint16_t) line;
 
 		fl_lines = s5k3e2fx_reg_pat[S_RES_PREVIEW].size_h +
-		    s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_l;
+		    s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_l;  /* 972 + 18 = 990 */
 
 		ll_pck = s5k3e2fx_reg_pat[S_RES_PREVIEW].size_w +
-		    s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_p;
+		    s5k3e2fx_reg_pat[S_RES_PREVIEW].blk_p;  /* 1296 + 1436 = 2732 */
 
 	} else {
 
 		fl_lines = s5k3e2fx_reg_pat[S_RES_CAPTURE].size_h +
-		    s5k3e2fx_reg_pat[S_RES_CAPTURE].blk_l;
+		    s5k3e2fx_reg_pat[S_RES_CAPTURE].blk_l;  /* 1960 + 14 = 1974 */
 
 		ll_pck = s5k3e2fx_reg_pat[S_RES_CAPTURE].size_w +
-		    s5k3e2fx_reg_pat[S_RES_CAPTURE].blk_p;
+		    s5k3e2fx_reg_pat[S_RES_CAPTURE].blk_p;  /* 2608 + 124 = 2732 */
 	}
 
 	if (gain > max_legal_gain)
 		gain = max_legal_gain;
 
+#if 0
 	/* in Q10 */
 	line = (line * s5k3e2fx_ctrl->fps_divider);
 
@@ -2589,6 +2920,29 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	else
 		ll_ratio = 0x400;
 
+	ll_pck = ll_pck * ll_ratio / 0x400;
+	line = line / ll_ratio;
+#else
+	// solving accuracy lossing by calculating separately
+	if (fl_lines < (line * s5k3e2fx_ctrl->fps_divider / 0x400)){
+		/* ll_ratio =
+			(line * s5k3e2fx_ctrl->fps_divider / (fl_lines - offset)); */
+
+		ll_pck = ll_pck *
+			(line * s5k3e2fx_ctrl->fps_divider / (fl_lines - offset)) /
+			0x400;
+
+		/* line = line * s5k3e2fx_ctrl->fps_divider /
+			(line * s5k3e2fx_ctrl->fps_divider / (fl_lines - offset)); */
+		line = fl_lines - offset;
+	}
+	else{
+		/* ll_ratio = 0x400; */
+		/* ll_pck = ll_pck * 0x400 / 0x400; */
+		line = line * s5k3e2fx_ctrl->fps_divider / 0x400;
+	}
+#endif
+
 /* solve greenish: only release for preview */
 	if (s5k3e2fx_ctrl->sensormode == SENSOR_PREVIEW_MODE) {
 		rc = s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
@@ -2612,9 +2966,8 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	if (rc < 0)
 		goto write_gain_done;
 #if 1 /* Solve EVT5 greenish in lowlight*/
-	ll_pck = ll_pck * ll_ratio;
-	ll_pck_msb = ((ll_pck / 0x400) & 0xFF00) >> 8;
-	ll_pck_lsb = (ll_pck / 0x400) & 0x00FF;
+	ll_pck_msb = (ll_pck & 0xFF00) >> 8;
+	ll_pck_lsb = ll_pck & 0x00FF;
 	tbl[0].waddr = REG_LINE_LENGTH_PCK_MSB;
 	tbl[0].bdata = ll_pck_msb;
 	tbl[1].waddr = REG_LINE_LENGTH_PCK_LSB;
@@ -2623,6 +2976,7 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	rc = s5k3e2fx_i2c_write_table(&tbl[0], ARRAY_SIZE(tbl));
 	if (rc < 0)
 		goto write_gain_done;
+
 #else
 	if (line / 0x400 + offset > fl_lines)
 		ll_pck = line / 0x400 + offset;
@@ -2640,8 +2994,7 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	if (rc < 0)
 		goto write_gain_done;
 #endif
-
-	line = line / 0x400;
+	CDBG("line %d, fl_lines %d\n", line, fl_lines);
 	intg_t_msb = (line & 0xFF00) >> 8;
 	intg_t_lsb = (line & 0x00FF);
 	tbl[0].waddr = REG_COARSE_INTEGRATION_TIME;
@@ -2651,15 +3004,13 @@ static int s5k3e2fx_write_exp_gain(uint16_t gain, uint32_t line)
 	rc = s5k3e2fx_i2c_write_table(&tbl[0], ARRAY_SIZE(tbl));
 
 /* solve greenish: release for both */
-		rc = s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-					  REG_GROUPED_PARAMETER_HOLD,
-					  GROUPED_PARAMETER_UPDATE);
-		if (rc < 0) {
-			pr_err("s5k3e2fx_i2c_write_b failed on line %d\n",
-				__LINE__);
-			return rc;
-		}
-
+	rc = s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+				  REG_GROUPED_PARAMETER_HOLD,
+				  GROUPED_PARAMETER_UPDATE);
+	if (rc < 0) {
+		pr_err("s5k3e2fx_i2c_write_b failed on line %d\n", __LINE__);
+		return rc;
+	}
 write_gain_done:
 	return rc;
 }
@@ -2675,19 +3026,23 @@ static int s5k3e2fx_set_pict_exp_gain(uint16_t gain, uint32_t line)
 static int s5k3e2fx_video_config(int mode, int res)
 {
 	int rc;
+	struct msm_camera_sensor_info *sinfo = s5k3e2fx_pdev->dev.platform_data;
+	CDBG("s5k3e2fx_video_config res:%d\n", res);
+/* 100202 Move these setting from down	*/
+	s5k3e2fx_ctrl->prev_res = res;
+	s5k3e2fx_ctrl->curr_res = res;
+	s5k3e2fx_ctrl->sensormode = mode;
 
 	switch (res) {
 	case S_QTR_SIZE:
-		pr_info("start sensor S_RES_PREVIEW config: %d\n", __LINE__);
 		rc = s5k3e2fx_setting(S_UPDATE_PERIODIC, S_RES_PREVIEW);
 		if (rc < 0)
 			return rc;
-		/* only apply my_reg for returning preview*/
-		rc = s5k3e2fx_write_exp_gain(s5k3e2fx_ctrl->my_reg_gain,
-				     s5k3e2fx_ctrl->my_reg_line_count);
 		break;
 
 	case S_FULL_SIZE:
+		pr_info("KPI PA: start sensor snapshot config: %d\n", __LINE__);
+		sinfo->kpi_sensor_start = ktime_to_ns(ktime_get());
 		rc = s5k3e2fx_setting(S_UPDATE_PERIODIC, S_RES_CAPTURE);
 		if (rc < 0)
 			return rc;
@@ -2696,10 +3051,14 @@ static int s5k3e2fx_video_config(int mode, int res)
 	default:
 		return 0;
 	}
-
+/* 100202 Move these setting up
 	s5k3e2fx_ctrl->prev_res = res;
 	s5k3e2fx_ctrl->curr_res = res;
 	s5k3e2fx_ctrl->sensormode = mode;
+*/
+
+	rc = s5k3e2fx_write_exp_gain(s5k3e2fx_ctrl->my_reg_gain,
+				     s5k3e2fx_ctrl->my_reg_line_count);
 
 	return rc;
 }
@@ -2721,7 +3080,9 @@ static int s5k3e2fx_set_default_focus(void)
 	return rc;
 }
 
-static int s5k3e2fx_move_focus(int direction, int num_steps)
+static int s5k3e2fx_move_focus(
+	int direction, int num_steps,int coarse_delay,int fine_delay,
+	int step_dir, int init_code_offset_max)
 {
 	int rc = 0;
 	int i;
@@ -2732,11 +3093,30 @@ static int s5k3e2fx_move_focus(int direction, int num_steps)
 	uint8_t next_pos_msb, next_pos_lsb;
 	int16_t s_move[5];
 	uint32_t gain;		/* Q10 format */
+	int16_t step_direction_pre_define;
+	int16_t init_code_offset_pre_define;
+	int16_t coarse_search_delay;
+	int16_t fine_search_delay;
+
+	if (g_usModuleVersion == 1) { /* EVT5 */
+		step_direction_pre_define = step_dir;
+		init_code_offset_pre_define = init_code_offset_max;
+		/*fine search delay time is turnable*/
+		coarse_search_delay = coarse_delay;
+		fine_search_delay = fine_delay;
+	} else {
+		step_direction_pre_define = 20;
+		init_code_offset_pre_define = 738;
+		coarse_search_delay = 6;
+		fine_search_delay = 4;
+	}
+
+pr_info("%s step_direction_pre_define %d\n", __func__, step_direction_pre_define);
 
 	if (direction == MOVE_NEAR)
-		step_direction = 20;
+		step_direction = step_direction_pre_define;
 	else if (direction == MOVE_FAR)
-		step_direction = -20;
+		step_direction = 0 - step_direction_pre_define;
 	else {
 		pr_err("s5k3e2fx_move_focus failed at line %d ...\n", __LINE__);
 		return -EINVAL;
@@ -2761,8 +3141,8 @@ static int s5k3e2fx_move_focus(int direction, int num_steps)
 	for (i = 0; i <= 4; i++) {
 		next_pos = (int16_t) (pos_offset + s_move[i]);
 
-		if (next_pos > (738 + init_code))
-			next_pos = 738 + init_code;
+		if (next_pos > (init_code_offset_max + init_code))
+			next_pos = init_code_offset_pre_define + init_code;
 		else if (next_pos < 0)
 			next_pos = 0;
 
@@ -2786,15 +3166,222 @@ static int s5k3e2fx_move_focus(int direction, int num_steps)
 
 		pos_offset = next_pos;
 		s5k3e2fx_ctrl->curr_lens_pos = pos_offset - init_code;
-		if (num_steps > 1)
-			mdelay(6);
+
+		if(num_steps > 1)
+			mdelay(coarse_search_delay);
 		else
-			mdelay(4);
+			mdelay(fine_search_delay);
 	}
 
 	return rc;
 }
 
+
+static int s5k3e2fx_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int rc;
+	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+
+	if (!sinfo->need_suspend)
+		return 0;
+	s5k3e2fx_event.waked_up = 0;
+
+
+	pr_info("s5k3e2fx: camera suspend\n");
+	rc = gpio_request(sinfo->sensor_reset, "s5k3e2fx");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_reset, 0);
+	else {
+		pr_err("s5k3e2fx: request GPIO(sensor_reset) :%d faile\n",
+			sinfo->sensor_reset);
+		goto suspend_fail;
+	}
+	CDBG("s5k3e2fx: gpio_free:%d line:%d\n", sinfo->sensor_reset,
+		__LINE__);
+	gpio_free(sinfo->sensor_reset);
+
+suspend_fail:
+	return rc;
+}
+static void s5k3e2fx_sensor_resume_setting(void)
+{
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+			     S5K3E2FX_REG_SOFTWARE_RESET,
+			     S5K3E2FX_SOFTWARE_RESET);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0100, 0x00);
+	/*--------------PLL setting for 80Mhz*/
+	/* PLL setting */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0305, 0x06);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0306, 0x00);
+	/*88 54.4Mhz */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0307, 0x83);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0301, 0x08);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0303, 0x01);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0309, 0x08);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x030b, 0x01);
+	/*--------------output size*/
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034c, 0x05);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034d, 0x10);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034e, 0x03);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034f, 0xcc);
+	/*--------------frame format (min blanking)*/
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0340, 0x03);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0341, 0xe2);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0342, 0x0a);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0343, 0xac);
+	/*--------------Binning */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0381, 0x01);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0383, 0x01);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0385, 0x01);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0387, 0x03);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3014, 0x06);
+	/*--------------MSR setting*/
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30c4, 0x01);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3000, 0x03);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3001, 0x94);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3002, 0x02);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3003, 0x95);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3004, 0x0f);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3005, 0x05);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3006, 0x3c);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3007, 0x8c);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3008, 0x93);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3009, 0x05);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300a, 0x3a);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300c, 0x02);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300d, 0x3e);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300f, 0x0e);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3010, 0x46);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3011, 0x64);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3012, 0x1e);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x301d, 0x3f);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3024, 0x04);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3028, 0x40);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3070, 0xdf);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x301b, 0x73);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x307e, 0x02);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30bd, 0x06);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30c2, 0x0b);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30ac, 0x81);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3151, 0xe6);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3029, 0x02);
+	/*--------------EVT4 setting*/
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30bf, 0x00);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3022, 0x87);
+	/*tune ADC to got batter yield rate in EDS */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3019, 0x60);
+	/*AF driving strength */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3146, 0x3c);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3152, 0x08);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x315a, 0xaa);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3159, 0x0a);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0205, 0x80);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0202, 0x03);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0200, 0x02);
+}
+
+static void s5k3e2fx_resume(struct early_suspend *handler)
+{
+	struct msm_camera_sensor_info *sinfo = s5k3e2fx_pdev->dev.platform_data;
+
+	if (!sinfo->need_suspend)
+		return;
+
+	/*check whether already suspend*/
+	if (s5k3e2fx_event.waked_up == 1) {
+		pr_info("S5k3e2fx: No nesesary to do Resume\n");
+		return;
+	}
+
+	pr_info("s5k3e2fx_resume\n");
+	/*init msm,clk ,GPIO,enable */
+	msm_camio_probe_on(s5k3e2fx_pdev);
+	msm_camio_clk_enable(CAMIO_MDC_CLK);
+
+	pr_info("msm_camio_probe_on\n");
+	/*read sensor ID and pull down reset */
+	msm_camio_clk_rate_set(S5K3E2FX_DEF_MCLK);
+	pr_info("msm_camio_clk_rate_set\n");
+	msleep(20);
+	s5k3e2fx_probe_init_sensor(sinfo);
+	CDBG("s5k3e2fx_probe_init_sensor\n");
+	/*init sensor,streaming on, SW init streaming off */
+	s5k3e2fx_sensor_resume_setting();
+	/*lens sharding */
+	s5k3e2fx_probe_init_lens_correction(sinfo);
+	/*stream on */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+			     S5K3E2FX_REG_MODE_SELECT,
+			     S5K3E2FX_MODE_SELECT_STREAM);
+
+	/*software standby */
+	msleep(25);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3130, 0x00);
+	mdelay(1);
+	/*stream off */
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
+			     S5K3E2FX_REG_MODE_SELECT,
+			     S5K3E2FX_MODE_SELECT_SW_STANDBY);
+	mdelay(1);
+	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3150, 0x51);
+	msleep(240);
+	/*set RST to low */
+	msm_camio_probe_off(s5k3e2fx_pdev);
+	msm_camio_clk_disable(CAMIO_MDC_CLK);
+	s5k3e2fx_event.waked_up = 1;
+	wake_up(&s5k3e2fx_event.event_wait);
+	pr_info("s5k3e2fx:resume done\n");
+	return;
+}
+
+
+static struct early_suspend early_suspend_s5k3e2fx = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN+1,
+	.resume = s5k3e2fx_resume,
+	.suspend = NULL,
+};
+
+static const char *s5k3e2fxVendor = "Samsung";
+static const char *s5k3e2fxNAME = "s5k3e2fx";
+static const char *s5k3e2fxSize = "5M";
+
+static ssize_t sensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "%s %s %s\n", s5k3e2fxVendor, s5k3e2fxNAME, s5k3e2fxSize);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+
+static struct kobject *android_s5k3e2fx;
+
+static int s5k3e2fx_sysfs_init(void)
+{
+	int ret ;
+	pr_info("s5k3e2fx:kobject creat and add\n");
+	android_s5k3e2fx = kobject_create_and_add("android_camera", NULL);
+	if (android_s5k3e2fx == NULL) {
+		pr_info("s5k3e2fx_sysfs_init: subsystem_register " \
+		"failed\n");
+		ret = -ENOMEM;
+		return ret ;
+	}
+	pr_info("s5k3e2fx:sysfs_create_file\n");
+	ret = sysfs_create_file(android_s5k3e2fx, &dev_attr_sensor.attr);
+	if (ret) {
+		pr_info("s5k3e2fx_sysfs_init: sysfs_create_file " \
+		"failed\n");
+		kobject_del(android_s5k3e2fx);
+	}
+	return 0 ;
+}
+
+
 static int s5k3e2fx_sensor_config(void __user *argp)
 {
 	struct sensor_cfg_data cdata;
@@ -2871,6 +3458,7 @@ static int s5k3e2fx_sensor_config(void __user *argp)
 		break;
 
 	case CFG_SET_MODE:
+		pr_info("CFG_SET_MODE\n");
 		rc = s5k3e2fx_video_config(cdata.mode, cdata.rs);
 		break;
 
@@ -2880,18 +3468,28 @@ static int s5k3e2fx_sensor_config(void __user *argp)
 
 	case CFG_MOVE_FOCUS:
 		rc = s5k3e2fx_move_focus(cdata.cfg.focus.dir,
-					 cdata.cfg.focus.steps);
+					 cdata.cfg.focus.steps,
+					 cdata.cfg.focus.coarse_delay,
+					 cdata.cfg.focus.fine_delay,
+					 cdata.cfg.focus.step_dir,
+					 cdata.cfg.focus.init_code_offset_max);
 		break;
 
 	case CFG_SET_DEFAULT_FOCUS:
 		rc = s5k3e2fx_set_default_focus();
 		break;
 
-/*	case CFG_GET_AF_MAX_STEPS: */
+	/*case CFG_GET_AF_MAX_STEPS: */
 	case CFG_SET_EFFECT:
 		rc = s5k3e2fx_set_default_focus();
 		break;
 
+	case CFG_I2C_IOCTL_R_OTP:{
+		rc = s5k3e2fx_i2c_read_fuseid(&cdata);
+		if (copy_to_user(argp, &cdata, sizeof(struct sensor_cfg_data)))
+			rc = -EFAULT;
+		}
+		break;
 	case CFG_SET_LENS_SHADING:
 	default:
 		rc = -EFAULT;
@@ -2902,7 +3500,7 @@ static int s5k3e2fx_sensor_config(void __user *argp)
 	return rc;
 }
 
-static int s5k3e2fx_sensor_probe(const struct msm_camera_sensor_info *info,
+static int s5k3e2fx_sensor_probe(struct msm_camera_sensor_info *info,
 				 struct msm_sensor_ctrl *s)
 {
 	int rc = 0;
@@ -2929,6 +3527,15 @@ static int s5k3e2fx_sensor_probe(const struct msm_camera_sensor_info *info,
 	s->s_release = s5k3e2fx_sensor_release;
 	s->s_config = s5k3e2fx_sensor_config;
 
+	/*register late resuem*/
+	register_early_suspend(&early_suspend_s5k3e2fx);
+	/*init wait event*/
+	init_waitqueue_head(&s5k3e2fx_event.event_wait);
+	/*init waked_up value*/
+	s5k3e2fx_event.waked_up = 1;
+	/*write sysfs*/
+	s5k3e2fx_sysfs_init();
+
 	return rc;
 
 probe_fail:
@@ -2936,154 +3543,9 @@ probe_fail:
 	return rc;
 }
 
-static int s5k3e2fx_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	int rc;
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-
-	if (!sinfo->need_suspend)
-		return 0;
-
-	CDBG("s5k3e2fx: camera suspend\n");
-	rc = gpio_request(sinfo->sensor_reset, "s5k3e2fx");
-	if (!rc)
-		gpio_direction_output(sinfo->sensor_reset, 0);
-	else {
-		pr_err("s5k3e2fx: request GPIO(sensor_reset) :%d faile\n",
-			sinfo->sensor_reset);
-		goto suspend_fail;
-	}
-	CDBG("s5k3e2fx: gpio_free:%d line:%d\n", sinfo->sensor_reset,
-		__LINE__);
-	gpio_free(sinfo->sensor_reset);
-
-suspend_fail:
-	return rc;
-}
-static void s5k3e2fx_sensor_resume_setting(void)
-{
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-			     S5K3E2FX_REG_SOFTWARE_RESET,
-			     S5K3E2FX_SOFTWARE_RESET);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0100, 0x00);
-	/*--------------PLL setting for 80Mhz*/
-	/* PLL setting */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0305, 0x06);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0306, 0x00);
-	/*88 54.4Mhz */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0307, 0x83);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0301, 0x08);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0303, 0x01);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0309, 0x08);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x030b, 0x01);
-	/*--------------output size*/
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034c, 0x05);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034d, 0x10);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034e, 0x03);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x034f, 0xcc);
-	/*--------------frame format (min blanking)*/
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0340, 0x03);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0341, 0xe2);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0342, 0x0a);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0343, 0xac);
-	/*--------------Binning */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0381, 0x01);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0383, 0x01);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0385, 0x01);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0387, 0x03);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3014, 0x06);
-	/*--------------MSR setting*/
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30c4, 0x01);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3000, 0x03);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3001, 0x94);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3002, 0x02);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3003, 0x95);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3004, 0x0f);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3005, 0x05);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3006, 0x3c);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3007, 0x8c);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3008, 0x93);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3009, 0x05);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300a, 0x3a);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300c, 0x02);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300d, 0x3e);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x300f, 0x0e);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3010, 0x46);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3011, 0x64);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3012, 0x1e);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x301d, 0x3f);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3024, 0x04);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3028, 0x40);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3070, 0xdf);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x301b, 0x73);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x307e, 0x02);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30bd, 0x06);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30c2, 0x0b);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30ac, 0x81);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3151, 0xe6);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3029, 0x02);
-	/*--------------EVT4 setting*/
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x30bf, 0x00);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3022, 0x87);
-	/*tune ADC to got batter yield rate in EDS */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3019, 0x60);
-	/*AF driving strength */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3146, 0x3c);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3152, 0x08);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x315a, 0xaa);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3159, 0x0a);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0205, 0x80);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0202, 0x03);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x0200, 0x02);
-}
-static int s5k3e2fx_resume(struct platform_device *pdev)
-{
-	int rc = 0;
-	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
-
-	if (!sinfo->need_suspend)
-		return 0;
-
-	CDBG("s5k3e2fx_resume\n");
-	/*init msm,clk ,GPIO,enable */
-	msm_camio_probe_on(pdev);
-	msm_camio_clk_enable(CAMIO_MDC_CLK);
-
-	CDBG("msm_camio_probe_on\n");
-	/*read sensor ID and pull down reset */
-	msm_camio_clk_rate_set(S5K3E2FX_DEF_MCLK);
-	CDBG("msm_camio_clk_rate_set\n");
-	msleep(20);
-	s5k3e2fx_probe_init_sensor(sinfo);
-	CDBG("s5k3e2fx_probe_init_sensor\n");
-	/*init sensor,streaming on, SW init streaming off */
-	s5k3e2fx_sensor_resume_setting();
-	/*lens sharding */
-	s5k3e2fx_probe_init_lens_correction(sinfo);
-	/*stream on */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-			     S5K3E2FX_REG_MODE_SELECT,
-			     S5K3E2FX_MODE_SELECT_STREAM);
-	/*software standby */
-	msleep(25);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3130, 0x00);
-	mdelay(1);
-	/*stream off */
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr,
-			     S5K3E2FX_REG_MODE_SELECT,
-			     S5K3E2FX_MODE_SELECT_SW_STANDBY);
-	mdelay(1);
-	s5k3e2fx_i2c_write_b(s5k3e2fx_client->addr, 0x3150, 0x51);
-	msleep(240);
-	/*set RST to low */
-	msm_camio_probe_off(pdev);
-	msm_camio_clk_disable(CAMIO_MDC_CLK);
-	CDBG("s5k3e2fx:resume done\n");
-	return rc;
-}
-
 static int __s5k3e2fx_probe(struct platform_device *pdev)
 {
+	s5k3e2fx_pdev = pdev;
 	return msm_camera_drv_start(pdev, s5k3e2fx_sensor_probe);
 }
 
@@ -3094,7 +3556,6 @@ static struct platform_driver msm_camera_driver = {
 		.owner = THIS_MODULE,
 	},
 	.suspend = s5k3e2fx_suspend,
-	.resume = s5k3e2fx_resume,
 };
 
 static int __init s5k3e2fx_init(void)
diff --git a/drivers/media/video/msm/s5k3h1gx.c b/drivers/media/video/msm/s5k3h1gx.c
new file mode 100644
index 0000000..c7e417c
--- /dev/null
+++ b/drivers/media/video/msm/s5k3h1gx.c
@@ -0,0 +1,1756 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include <mach/camera.h>
+#include <mach/vreg.h>
+#include <asm/mach-types.h>
+#include "s5k3h1gx.h"
+
+/* CAMIF output resolutions */
+/* 816x612, 24MHz MCLK 96MHz PCLK */
+#define SENSOR_FULL_SIZE_WIDTH 3280
+#define SENSOR_FULL_SIZE_HEIGHT 2464
+
+#define SENSOR_QTR_SIZE_WIDTH 1640
+#define SENSOR_QTR_SIZE_HEIGHT 1232
+
+#define SENSOR_HRZ_FULL_BLK_PIXELS 190
+#define SENSOR_VER_FULL_BLK_LINES 16 /* 0 */
+#define SENSOR_HRZ_QTR_BLK_PIXELS 1830
+#define SENSOR_VER_QTR_BLK_LINES 16 /* 8 */
+#define SENSOR_VER_QTR_BLK_LINES_PARALLEL 611 /* 16 */ /* 8 */
+
+static int cam_mode_sel = 0; /* 0: photo, 1: video@30fps, 2: video@24fps */
+/* 611: 30fps, 1073: 24fps */
+const int s5k3h1gx_ver_qtr_blk_lines_array[] = {611,611,1073};
+
+#define S5K3H1GX_AF_I2C_ADDR 0x18
+#define S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR 42 /* 36 */
+#define S5K3H1GX_SW_DAMPING_STEP 10
+#define S5K3H1GX_MAX_FPS 30
+#define S5K3H1GX_MAX_FPS_PARALLEL 30 /* 22 */
+
+/*=============================================================
+ SENSOR REGISTER DEFINES
+==============================================================*/
+
+#define S5K3H1GX_REG_MODEL_ID 0x0000
+#define S5K3H1GX_MODEL_ID 0x3810
+
+/* Color bar pattern selection */
+#define S5K3H1GX_COLOR_BAR_PATTERN_SEL_REG 0x0601
+
+#define REG_FRAME_LENGTH_LINES_MSB	0x0340
+#define REG_FRAME_LENGTH_LINES_LSB	0x0341
+#define REG_LINE_LENGTH_PCK_MSB 0x0342
+#define REG_LINE_LENGTH_PCK_LSB 0x0343
+#define REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB 0x0204
+#define REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB 0x0205
+#define REG_COARSE_INTEGRATION_TIME_MSB 0x0202
+#define REG_COARSE_INTEGRATION_TIME_LSB 0x0203
+
+#define S5K3H1GX_REG_GROUP_PARAMETER_HOLD 0x0104
+#define S5K3H1GX_GROUP_PARAMETER_HOLD 0x01
+#define S5K3H1GX_GROUP_PARAMETER_UNHOLD 0x00
+
+////////////////////////////
+
+#define Q8 0x00000100
+#define SENSOR_DEFAULT_CLOCK_RATE 24000000
+
+////////////////////////////////////////////////////////////
+
+/*============================================================================
+ TYPE DECLARATIONS
+============================================================================*/
+
+/* 16bit address - 8 bit context register structure */
+#if 0
+typedef struct reg_addr_val_pair_struct {
+	uint16_t reg_addr;
+	uint8_t reg_val;
+} reg_struct_type;
+#endif
+
+struct awb_lsc_struct_type {
+       unsigned int caBuff[8];  /*awb_calibartion*/
+	struct reg_addr_val_pair_struct LSC_table[150];  /*lsc_calibration*/
+	uint32_t LSC_table_CRC;
+};
+
+enum s5k3h1gx_test_mode_t {
+	TEST_OFF,
+	TEST_1,
+	TEST_2,
+	TEST_3
+};
+
+enum s5k3h1gx_resolution_t {
+	QTR_SIZE,
+	FULL_SIZE,
+	INVALID_SIZE
+};
+
+enum s5k3h1gx_reg_update_t{
+	REG_INIT,
+	REG_PERIODIC
+};
+
+/*20101011 QCT mesh LSC calibration*/
+static int global_mode = 0;
+
+static int sensor_probe_node;
+static int preview_frame_count;
+
+static struct wake_lock s5k3h1gx_wake_lock;
+
+static inline void init_suspend(void)
+{
+	wake_lock_init(&s5k3h1gx_wake_lock, WAKE_LOCK_IDLE, "s5k3h1gx");
+}
+
+static inline void deinit_suspend(void)
+{
+	wake_lock_destroy(&s5k3h1gx_wake_lock);
+}
+
+static inline void prevent_suspend(void)
+{
+	wake_lock(&s5k3h1gx_wake_lock);
+}
+
+static inline void allow_suspend(void)
+{
+	wake_unlock(&s5k3h1gx_wake_lock);
+}
+
+/*============================================================================
+DATA DECLARATIONS
+============================================================================*/
+
+/*  96MHz PCLK @ 24MHz MCLK inc*/
+
+
+/* FIXME: Changes from here */
+struct s5k3h1gx_work {
+  struct work_struct work;
+};
+
+static struct  s5k3h1gx_work *s5k3h1gx_sensorw;
+static struct  i2c_client *s5k3h1gx_client;
+static uint16_t s5k3h1gx_pos_tbl[S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR + 1];
+
+struct s5k3h1gx_ctrl {
+  const struct  msm_camera_sensor_info *sensordata;
+
+  uint32_t sensormode;
+  uint32_t fps_divider; /* init to 1 * 0x00000400 */
+  uint32_t pict_fps_divider; /* init to 1 * 0x00000400 */
+  uint16_t fps;
+
+  int16_t  curr_lens_pos;
+  uint16_t curr_step_pos;
+  uint16_t init_curr_lens_pos;
+  uint16_t my_reg_gain;
+  uint32_t my_reg_line_count;
+  uint16_t total_lines_per_frame;
+
+  enum s5k3h1gx_resolution_t prev_res;
+  enum s5k3h1gx_resolution_t pict_res;
+  enum s5k3h1gx_resolution_t curr_res;
+  enum s5k3h1gx_test_mode_t set_test;
+  enum s5k3h1gx_reg_update_t reg_update;
+
+  unsigned short imgaddr;
+};
+
+static struct s5k3h1gx_ctrl *s5k3h1gx_ctrl;
+static struct platform_device *s5k3h1gx_pdev;
+
+struct s5k3h1gx_waitevent{
+	uint32_t waked_up;
+	wait_queue_head_t event_wait;
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(s5k3h1gx_wait_queue);
+DEFINE_SEMAPHORE(s5k3h1gx_sem);
+
+
+/*=============================================================*/
+
+static int s5k3h1gx_i2c_rxdata(unsigned short saddr,
+	unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+	{
+		.addr   = saddr,
+		.flags = 0,
+		.len   = 2,
+		.buf   = rxdata,
+	},
+	{
+		.addr  = saddr,
+		.flags = I2C_M_RD,
+		.len   = length,
+		.buf   = rxdata,
+	},
+	};
+
+	if (i2c_transfer(s5k3h1gx_client->adapter, msgs, 2) < 0) {
+		pr_err("s5k3h1gx_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+	pr_info("%s: rxdata=0x%X\n", __func__, *rxdata);
+
+	return 0;
+}
+static int32_t s5k3h1gx_i2c_txdata(unsigned short saddr,
+				 unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txdata,
+		 },
+	};
+	if (i2c_transfer(s5k3h1gx_client->adapter, msg, 1) < 0) {
+		pr_err("s5k3h1gx_i2c_txdata failed 0x%x\n", saddr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int32_t s5k3h1gx_i2c_read_b(unsigned short saddr, unsigned short raddr,
+	unsigned short *rdata)
+{
+	int32_t rc = 0;
+	unsigned char buf[4];
+
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (raddr & 0xFF00)>>8;
+	buf[1] = (raddr & 0x00FF);
+
+	rc = s5k3h1gx_i2c_rxdata(saddr, buf, 1);
+	if (rc < 0)
+		return rc;
+
+	*rdata = buf[0];
+
+	if (rc < 0)
+		pr_info("s5k3h1gx_i2c_read failed!\n");
+
+	return rc;
+}
+
+
+static int32_t s5k3h1gx_i2c_read(unsigned short raddr,
+				unsigned short *rdata, int rlen)
+{
+	int32_t rc = 0;
+	unsigned char buf[2];
+	int count = 0;
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (raddr & 0xFF00) >> 8;
+	buf[1] = (raddr & 0x00FF);
+retry:
+	rc = s5k3h1gx_i2c_rxdata(s5k3h1gx_client->addr, buf, rlen);
+
+	if (rc < 0) {
+		pr_err("s5k3h1gx_i2c_read 0x%x failed!\n", raddr);
+		printk(KERN_ERR "starting read retry policy count:%d\n", count);
+		udelay(10);
+		count++;
+		if (count < 20) {
+			if (count > 10)
+				udelay(100);
+		} else
+			return rc;
+		goto retry;
+	}
+
+	*rdata = (rlen == 2 ? buf[0] << 8 | buf[1] : buf[0]);
+	return rc;
+}
+
+
+static int32_t s5k3h1gx_i2c_write_b(unsigned short saddr,
+  unsigned short waddr, uint8_t bdata)
+{
+  int32_t rc = -EFAULT;
+  unsigned char buf[3];
+  int count = 0;
+
+  memset(buf, 0, sizeof(buf));
+  buf[0] = (waddr & 0xFF00) >> 8;
+  buf[1] = (waddr & 0x00FF);
+  buf[2] = bdata;
+
+retry:
+  rc = s5k3h1gx_i2c_txdata(saddr, buf, 3);
+
+  if (rc < 0) {
+    pr_err("i2c_write_b failed, addr = 0x%x, val = 0x%x\n",
+      waddr, bdata);
+    pr_err(KERN_ERR "starting read retry policy count:%d\n", count);
+    udelay(10);
+    count++;
+    if (count < 20) {
+      if (count > 10)
+		udelay(100);
+    } else
+      return rc;
+    goto retry;
+  }
+
+  return rc;
+}
+
+static void s5k3h1gx_get_pict_fps(uint16_t fps, uint16_t *pfps)
+{
+	/* input fps is preview fps in Q8 format */
+	uint32_t divider, d1, d2;
+	uint16_t snapshot_height, preview_height, preview_width, snapshot_width;
+	struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+	if (s5k3h1gx_ctrl->prev_res == QTR_SIZE) {
+		preview_width =
+			SENSOR_QTR_SIZE_WIDTH  + SENSOR_HRZ_QTR_BLK_PIXELS;
+
+		if (sinfo->csi_if)
+			preview_height =
+				SENSOR_QTR_SIZE_HEIGHT +
+				SENSOR_VER_QTR_BLK_LINES;
+		else
+			preview_height =
+				SENSOR_QTR_SIZE_HEIGHT +
+				s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel] ;
+	} else {
+		/* full size resolution used for preview. */
+		preview_width =
+			SENSOR_FULL_SIZE_WIDTH + SENSOR_HRZ_FULL_BLK_PIXELS;
+		preview_height =
+			SENSOR_FULL_SIZE_HEIGHT + SENSOR_VER_FULL_BLK_LINES;
+	}
+
+	if (s5k3h1gx_ctrl->pict_res == QTR_SIZE) {
+		snapshot_width =
+			SENSOR_QTR_SIZE_WIDTH + SENSOR_HRZ_QTR_BLK_PIXELS;
+
+		if (sinfo->csi_if)
+			snapshot_height =
+				SENSOR_QTR_SIZE_HEIGHT +
+				SENSOR_VER_QTR_BLK_LINES;
+		else
+			snapshot_height =
+				SENSOR_QTR_SIZE_HEIGHT +
+				s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel] ;
+	} else {
+		snapshot_width =
+			SENSOR_FULL_SIZE_WIDTH +
+			SENSOR_HRZ_FULL_BLK_PIXELS;
+		snapshot_height =
+			SENSOR_FULL_SIZE_HEIGHT +
+			SENSOR_VER_FULL_BLK_LINES;
+	}
+
+	d1 = preview_height * 0x00000400 / snapshot_height;
+	d2 = preview_width * 0x00000400 / snapshot_width;
+
+	divider = (uint32_t) (d1 * d2) / 0x00000400;
+	*pfps = (uint16_t)(fps * divider / 0x00000400);
+
+} /* endof s5k3h1gx_get_pict_fps */
+
+static uint16_t s5k3h1gx_get_prev_lines_pf(void)
+{
+	struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+	if (s5k3h1gx_ctrl->prev_res == QTR_SIZE) {
+		if (sinfo->csi_if)
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			SENSOR_VER_QTR_BLK_LINES);
+		else
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (SENSOR_FULL_SIZE_HEIGHT +
+			SENSOR_VER_FULL_BLK_LINES);
+	}
+}
+
+static uint16_t s5k3h1gx_get_prev_pixels_pl(void)
+{
+	if (s5k3h1gx_ctrl->prev_res == QTR_SIZE) {
+		return (SENSOR_QTR_SIZE_WIDTH +
+			SENSOR_HRZ_QTR_BLK_PIXELS);
+	} else  {
+		return (SENSOR_FULL_SIZE_WIDTH +
+			SENSOR_HRZ_FULL_BLK_PIXELS);
+}
+}
+
+static uint16_t s5k3h1gx_get_pict_lines_pf(void)
+{
+	struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+	if (s5k3h1gx_ctrl->pict_res == QTR_SIZE) {
+		if (sinfo->csi_if)
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			SENSOR_VER_QTR_BLK_LINES);
+		else
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (SENSOR_FULL_SIZE_HEIGHT +
+			SENSOR_VER_FULL_BLK_LINES);
+	}
+}
+
+static uint16_t s5k3h1gx_get_pict_pixels_pl(void)
+{
+	if (s5k3h1gx_ctrl->pict_res == QTR_SIZE) {
+		return (SENSOR_QTR_SIZE_WIDTH +
+			SENSOR_HRZ_QTR_BLK_PIXELS);
+	} else  {
+		return (SENSOR_FULL_SIZE_WIDTH +
+			SENSOR_HRZ_FULL_BLK_PIXELS);
+	}
+}
+
+static uint32_t s5k3h1gx_get_pict_max_exp_lc(void)
+{
+	struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+	if (s5k3h1gx_ctrl->pict_res == QTR_SIZE) {
+		if (sinfo->csi_if)
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			SENSOR_VER_QTR_BLK_LINES);
+		else
+			return (SENSOR_QTR_SIZE_HEIGHT +
+			s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (SENSOR_FULL_SIZE_HEIGHT +
+			SENSOR_VER_FULL_BLK_LINES);
+	}
+}
+
+static int32_t s5k3h1gx_set_fps(struct fps_cfg *fps)
+{
+	int32_t rc = 0;
+	s5k3h1gx_ctrl->fps_divider = fps->fps_div;
+	s5k3h1gx_ctrl->pict_fps_divider = fps->pict_fps_div;
+	s5k3h1gx_ctrl->fps = fps->f_mult;
+	return rc;
+}
+
+static int32_t s5k3h1gx_i2c_write_table(
+	struct s5k3h1gx_i2c_reg_conf *reg_cfg_tbl, int num)
+{
+	int i;
+	int32_t rc = -EIO;
+	for (i = 0; i < num; i++) {
+		rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr,
+			reg_cfg_tbl->waddr, reg_cfg_tbl->bdata);
+		if (rc < 0)
+			break;
+		reg_cfg_tbl++;
+	}
+
+	return rc;
+}
+
+static int32_t s5k3h1gx_write_exp_gain
+  (uint16_t gain, uint32_t line)
+{
+	int32_t rc = 0;
+
+	uint16_t max_legal_gain = 0x0200;
+	uint32_t ll_ratio; /* Q10 */
+	uint32_t ll_pck, fl_lines;
+	uint16_t offset = 8; /* 4; */     /* kipper */
+	uint32_t gain_msb, gain_lsb;
+	uint32_t intg_t_msb, intg_t_lsb;
+	uint32_t ll_pck_msb, ll_pck_lsb;
+	struct s5k3h1gx_i2c_reg_conf tbl[3];
+	struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+	CDBG("Line:%d s5k3h1gx_write_exp_gain , gain=%d, line=%d\n",
+		__LINE__, gain, line);
+
+	if (s5k3h1gx_ctrl->sensormode == SENSOR_PREVIEW_MODE) {
+
+		s5k3h1gx_ctrl->my_reg_gain = gain;
+		s5k3h1gx_ctrl->my_reg_line_count = (uint16_t)line;
+
+		if (sinfo->csi_if)
+			fl_lines = SENSOR_QTR_SIZE_HEIGHT +
+				SENSOR_VER_QTR_BLK_LINES;
+		else
+			fl_lines = SENSOR_QTR_SIZE_HEIGHT +
+				s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel] ;
+
+		ll_pck = SENSOR_QTR_SIZE_WIDTH +
+			SENSOR_HRZ_QTR_BLK_PIXELS;
+
+	} else {
+
+		fl_lines = SENSOR_FULL_SIZE_HEIGHT +
+			SENSOR_VER_FULL_BLK_LINES;
+
+		ll_pck = SENSOR_FULL_SIZE_WIDTH +
+			SENSOR_HRZ_FULL_BLK_PIXELS;
+	}
+
+	if (gain > max_legal_gain)
+		gain = max_legal_gain;
+
+	/* in Q10 */
+	line = (line * s5k3h1gx_ctrl->fps_divider);
+
+	CDBG("s5k3h1gx_ctrl->fps_divider = %d\n",
+		s5k3h1gx_ctrl->fps_divider);
+	CDBG("fl_lines = %d\n", fl_lines);
+	CDBG("line = %d\n", line);
+	if ((fl_lines-offset) < (line / 0x400))
+		ll_ratio = (line / (fl_lines - offset));
+	else
+		ll_ratio = 0x400;
+	CDBG("ll_ratio = %d\n", ll_ratio);
+
+	/* update gain registers */
+	CDBG("gain = %d\n", gain);
+	gain_msb = (gain & 0xFF00) >> 8;
+	gain_lsb = gain & 0x00FF;
+	tbl[0].waddr = S5K3H1GX_REG_GROUP_PARAMETER_HOLD;
+	tbl[0].bdata = S5K3H1GX_GROUP_PARAMETER_HOLD;
+	tbl[1].waddr = REG_ANALOGUE_GAIN_CODE_GLOBAL_MSB;
+	tbl[1].bdata = gain_msb;
+	tbl[2].waddr = REG_ANALOGUE_GAIN_CODE_GLOBAL_LSB;
+	tbl[2].bdata = gain_lsb;
+	rc = s5k3h1gx_i2c_write_table(&tbl[0], ARRAY_SIZE(tbl));
+	if (rc < 0)
+		goto write_gain_done;
+
+	ll_pck = ll_pck * ll_ratio;
+	CDBG("ll_pck/0x400 = %d\n", ll_pck / 0x400);
+	ll_pck_msb = ((ll_pck / 0x400) & 0xFF00) >> 8;
+	ll_pck_lsb = (ll_pck / 0x400) & 0x00FF;
+	tbl[0].waddr = REG_LINE_LENGTH_PCK_MSB;
+	tbl[0].bdata = ll_pck_msb;
+	tbl[1].waddr = REG_LINE_LENGTH_PCK_LSB;
+	tbl[1].bdata = ll_pck_lsb;
+	rc = s5k3h1gx_i2c_write_table(&tbl[0], ARRAY_SIZE(tbl)-1);
+	if (rc < 0)
+		goto write_gain_done;
+
+	line = line / ll_ratio;
+	CDBG("line = %d\n", line);
+	intg_t_msb = (line & 0xFF00) >> 8;
+	intg_t_lsb = (line & 0x00FF);
+	tbl[0].waddr = REG_COARSE_INTEGRATION_TIME_MSB;
+	tbl[0].bdata = intg_t_msb;
+	tbl[1].waddr = REG_COARSE_INTEGRATION_TIME_LSB;
+	tbl[1].bdata = intg_t_lsb;
+	tbl[2].waddr = S5K3H1GX_REG_GROUP_PARAMETER_HOLD;
+	tbl[2].bdata = S5K3H1GX_GROUP_PARAMETER_UNHOLD;
+	rc = s5k3h1gx_i2c_write_table(&tbl[0], ARRAY_SIZE(tbl));
+
+write_gain_done:
+	return rc;
+}
+
+/* ### this function is not called for userspace ### */
+static int32_t s5k3h1gx_set_pict_exp_gain(uint16_t gain, uint32_t line)
+{
+	int32_t rc = 0;
+	rc = s5k3h1gx_write_exp_gain(gain, line);
+
+	return rc;
+} /* endof s5k3h1gx_set_pict_exp_gain*/
+
+static int32_t initialize_s5k3h1gx_registers(void)
+{
+	int32_t rc = 0;
+	struct msm_camera_sensor_info *sinfo =
+		s5k3h1gx_pdev->dev.platform_data;
+
+	mdelay(5);
+
+	if (sinfo->csi_if) {
+		if (s5k3h1gx_regs.init_mipi_size > 0)
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.init_mipi,
+				s5k3h1gx_regs.init_mipi_size);
+	} else {
+		if (s5k3h1gx_regs.init_parallel_size > 0)
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.init_parallel,
+				s5k3h1gx_regs.init_parallel_size);
+	}
+
+	return rc;
+} /* end of initialize_s5k3h1gx_ov8m0vc_registers. */
+
+static int32_t s5k3h1gx_setting(int rt)
+{
+	int32_t rc = 0;
+	/* reconfigure the qtr height to adjust frame rate */
+	uint16_t fl_line = 0;
+	struct msm_camera_sensor_info *sinfo =
+		s5k3h1gx_pdev->dev.platform_data;
+
+	switch (rt) {
+	case QTR_SIZE:
+		pr_err("s5k3h1gx_setting(QTR_SIZE)\n");
+		rc = s5k3h1gx_i2c_write_b(
+		        s5k3h1gx_client->addr, 0x0100, 0x00);
+
+		if (sinfo->csi_if) {
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.qtr_mipi,
+				s5k3h1gx_regs.qtr_mipi_size);
+		} else {
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.qtr_parallel,
+				s5k3h1gx_regs.qtr_parallel_size);
+			if (rc < 0)
+				return rc;
+		fl_line = SENSOR_QTR_SIZE_HEIGHT +
+			s5k3h1gx_ver_qtr_blk_lines_array[cam_mode_sel];
+		rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr,
+			REG_FRAME_LENGTH_LINES_MSB,
+			(fl_line & 0xFF00) >> 8);
+		if (rc < 0)
+			return rc;
+		rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr,
+			REG_FRAME_LENGTH_LINES_LSB,
+			fl_line & 0x00FF);
+		if (rc < 0)
+			return rc;
+		}
+			msleep(200);
+			rc = s5k3h1gx_i2c_write_b(
+				s5k3h1gx_client->addr, 0x0100, 0x01);
+		if (rc < 0)
+			return rc;
+
+		s5k3h1gx_ctrl->curr_res = QTR_SIZE;
+		break;
+
+	case FULL_SIZE:
+		pr_err("s5k3h1gx_setting(FULL_SIZE)\n");
+		rc = s5k3h1gx_i2c_write_b(
+				s5k3h1gx_client->addr, 0x0100, 0x00);
+
+		if (sinfo->csi_if) {
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.full_mipi,
+				s5k3h1gx_regs.full_mipi_size);
+		} else {
+			rc = s5k3h1gx_i2c_write_table(
+				s5k3h1gx_regs.full_parallel,
+				s5k3h1gx_regs.full_parallel_size);
+		}
+		if (rc < 0)
+			return rc;
+
+		msleep(100);
+		rc = s5k3h1gx_i2c_write_b(
+				s5k3h1gx_client->addr, 0x0100, 0x01);
+
+		if (rc < 0)
+			return rc;
+
+		s5k3h1gx_ctrl->curr_res = FULL_SIZE;
+		break;
+
+	default:
+		rc = -EFAULT;
+		return rc;
+	}
+
+	/* sync OV8810 method to set gain and line */
+#if 1
+	/*take raw picture for LSC calibration*/
+	if (global_mode) {
+		pr_info("[LSC calibration] set gain and line !!!!\n");
+		s5k3h1gx_write_exp_gain(32, 300);
+		global_mode = 0;
+	}
+#endif
+
+	return rc;
+} /* end of s5k3h1gx_setting */
+
+static int32_t s5k3h1gx_video_config(int mode)
+{
+	int32_t rc = 0;
+	static int pre_sel = 0;
+	int cur_sel = (cam_mode_sel > 1)?1:0;
+	s5k3h1gx_ctrl->sensormode = mode;
+
+	CDBG("cam_mode_sel %d cur_sel = %d, pre_sel = %d\n",
+		cam_mode_sel, cur_sel, pre_sel);
+
+	if (s5k3h1gx_ctrl->curr_res != s5k3h1gx_ctrl->prev_res
+		|| pre_sel != cur_sel
+		)  {
+	rc = s5k3h1gx_setting(s5k3h1gx_ctrl->prev_res);
+		if (rc < 0)
+			return rc;
+	} else {
+		s5k3h1gx_ctrl->curr_res = s5k3h1gx_ctrl->prev_res;
+	}
+		s5k3h1gx_ctrl->sensormode = mode;
+
+	pre_sel = cur_sel;
+
+	preview_frame_count = 0;
+	rc =
+		s5k3h1gx_write_exp_gain(s5k3h1gx_ctrl->my_reg_gain,
+			s5k3h1gx_ctrl->my_reg_line_count);
+
+	return rc;
+
+} /* end of s5k3h1gx_video_config */
+
+static int32_t s5k3h1gx_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	s5k3h1gx_ctrl->sensormode = mode;
+
+	if (s5k3h1gx_ctrl->curr_res != s5k3h1gx_ctrl->pict_res) {
+		rc = s5k3h1gx_setting(s5k3h1gx_ctrl->pict_res);
+		if (rc < 0)
+			return rc;
+	} else {
+		s5k3h1gx_ctrl->curr_res = s5k3h1gx_ctrl->pict_res;
+	}
+	s5k3h1gx_ctrl->sensormode = mode;
+
+	return rc;
+
+} /*end of s5k3h1gx_snapshot_config*/
+
+static int32_t s5k3h1gx_raw_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	s5k3h1gx_ctrl->sensormode = mode;
+	if (s5k3h1gx_ctrl->curr_res != s5k3h1gx_ctrl->pict_res) {
+		rc = s5k3h1gx_setting(s5k3h1gx_ctrl->pict_res);
+		if (rc < 0)
+			return rc;
+	} else {
+		s5k3h1gx_ctrl->curr_res = s5k3h1gx_ctrl->pict_res;
+	} /* Update sensor resolution */
+
+	s5k3h1gx_ctrl->sensormode = mode;
+
+	return rc;
+
+} /*end of s5k3h1gx_raw_snapshot_config*/
+
+static int32_t s5k3h1gx_set_sensor_mode(int mode,
+  int res)
+{
+  int32_t rc = 0;
+
+  switch (mode) {
+    case SENSOR_PREVIEW_MODE:
+      rc = s5k3h1gx_video_config(mode);
+      break;
+
+    case SENSOR_SNAPSHOT_MODE:
+      rc = s5k3h1gx_snapshot_config(mode);
+      break;
+
+    case SENSOR_RAW_SNAPSHOT_MODE:
+      rc = s5k3h1gx_raw_snapshot_config(mode);
+      break;
+
+    default:
+      rc = -EINVAL;
+      break;
+  }
+
+  return rc;
+}
+
+static int s5k3h1gx_probe_init_done(const struct msm_camera_sensor_info *data)
+{
+	int32_t rc = 0;
+
+	pr_info("[Camera] gpio_request(%d, \"s5k3h1gx\")\n", data->sensor_pwd);
+	rc = gpio_request(data->sensor_pwd, "s5k3h1gx");
+	if (!rc)
+		gpio_direction_output(data->sensor_pwd, 0);
+	else
+		pr_err("GPIO (%d) request failed\n", data->sensor_pwd);
+
+	gpio_free(data->sensor_pwd);
+
+       if (data->sensor_reset) {
+               msleep(5);
+               rc = gpio_request(data->sensor_reset, "s5k3h1gx");
+               if (!rc)
+                       gpio_direction_output(data->sensor_reset, 0);
+               else
+                       pr_err("GPIO (%d) request faile\n", data->sensor_reset);
+               gpio_free(data->sensor_reset);
+       }
+
+
+	return 0;
+}
+
+static int32_t s5k3h1gx_power_down(void)
+{
+  return 0;
+}
+
+static int s5k3h1gx_probe_init_sensor(const struct msm_camera_sensor_info *data)
+{
+	int32_t rc = 0;
+	uint16_t chipid = 0;
+
+	pr_info("%s\n", __func__);
+
+	/* Read sensor Model ID: */
+	rc = s5k3h1gx_i2c_read(S5K3H1GX_REG_MODEL_ID, &chipid, 2);
+	if (rc < 0) {
+		pr_err("read sensor id fail\n");
+		goto init_probe_fail;
+	} else
+		data->camera_set_source(SECOND_SOURCE);
+
+	/* Compare sensor ID to S5K3H1GX ID: */
+	pr_info("%s, Expected id=0x%x\n", __func__, S5K3H1GX_MODEL_ID);
+	pr_info("%s, Read id=0x%x\n", __func__, chipid);
+
+	if (chipid != S5K3H1GX_MODEL_ID) {
+		pr_err("sensor model id is incorrect\n");
+		rc = -ENODEV;
+		goto init_probe_fail;
+	}
+
+	pr_info("s5k3h1gx_probe_init_sensor finishes\n");
+	goto init_probe_done;
+
+init_probe_fail:
+	s5k3h1gx_probe_init_done(data);
+init_probe_done:
+	return rc;
+}
+
+static void s5k3h1gx_setup_af_tbl(void)
+{
+  int i;
+  uint16_t s5k3h1gx_nl_region_boundary1 = 3;
+  uint16_t s5k3h1gx_nl_region_boundary2 = 5;
+  uint16_t s5k3h1gx_nl_region_code_per_step1 = 40;
+  uint16_t s5k3h1gx_nl_region_code_per_step2 = 20;
+  uint16_t s5k3h1gx_l_region_code_per_step = 16;
+
+  s5k3h1gx_pos_tbl[0] = 0;
+
+  for (i = 1; i <= S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR; i++) {
+    if (i <= s5k3h1gx_nl_region_boundary1)
+      s5k3h1gx_pos_tbl[i] = s5k3h1gx_pos_tbl[i-1] +
+      s5k3h1gx_nl_region_code_per_step1;
+    else if (i <= s5k3h1gx_nl_region_boundary2)
+      s5k3h1gx_pos_tbl[i] = s5k3h1gx_pos_tbl[i-1] +
+      s5k3h1gx_nl_region_code_per_step2;
+    else
+      s5k3h1gx_pos_tbl[i] = s5k3h1gx_pos_tbl[i-1] +
+      s5k3h1gx_l_region_code_per_step;
+  }
+}
+
+static int32_t
+s5k3h1gx_go_to_position(uint32_t lens_pos, uint8_t mask)
+{
+  int32_t rc = 0;
+  unsigned char buf[2];
+  uint8_t code_val_msb, code_val_lsb;
+
+  code_val_msb = lens_pos >> 4;
+  code_val_lsb = (lens_pos & 0x000F) << 4;
+  code_val_lsb |= mask;
+
+  buf[0] = code_val_msb;
+  buf[1] = code_val_lsb;
+  rc = s5k3h1gx_i2c_txdata(S5K3H1GX_AF_I2C_ADDR >> 1, buf, 2);
+  if (rc < 0)
+    pr_err("i2c_write failed, saddr = 0x%x addr = 0x%x, val =0x%x!\n",
+      S5K3H1GX_AF_I2C_ADDR >> 1, buf[0], buf[1]);
+
+  return rc;
+}
+
+/*20101011 for LSC calibration*/
+static int s5k3h1gx_QCT_LSC_calibration_set_rawflag(void)
+{
+	global_mode = 1;
+	return 1;
+}
+
+static int s5k3h1gx_i2c_read_fuseid(struct sensor_cfg_data *cdata)
+{
+
+	int32_t  rc;
+	unsigned short i, R1, R2, R3;
+	unsigned short  OTP[10];
+
+	pr_info("%s: sensor OTP information:\n", __func__);
+
+	for (i = 0; i < 10; i++)
+		OTP[i] = 5;
+
+	rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr, 0x3124, 0x10);
+	if (rc < 0)
+		pr_info("%s: i2c_write_b 0x30FB fail\n", __func__);
+
+	rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr, 0x3127, 0xF1);
+	if (rc < 0)
+		pr_info("%s: i2c_write_b 0x30FB fail\n", __func__);
+
+	mdelay(4);
+
+	for (i = 0; i < 10; i++) {
+		rc = s5k3h1gx_i2c_write_b(s5k3h1gx_client->addr, 0x312B, i);
+			if (rc < 0)
+			pr_info("%s: i2c_write_b 0x310C fail\n", __func__);
+		rc = s5k3h1gx_i2c_read_b(s5k3h1gx_client->addr, 0x312C, &R1);
+			if (rc < 0)
+			pr_info("%s: i2c_read_b 0x310F fail\n", __func__);
+		rc = s5k3h1gx_i2c_read_b(s5k3h1gx_client->addr, 0x312D, &R2);
+			if (rc < 0)
+			pr_info("%s: i2c_read_b 0x310E fail\n", __func__);
+		rc = s5k3h1gx_i2c_read_b(s5k3h1gx_client->addr, 0x312E, &R3);
+			if (rc < 0)
+			pr_info("%s: i2c_read_b 0x310D fail\n", __func__);
+
+		if ((R3&0x0F) != 0)
+			OTP[i] = (short)(R3&0x0F);
+		else if ((R2&0x0F) != 0)
+			OTP[i] = (short)(R2&0x0F);
+		else if ((R2>>4) != 0)
+			OTP[i] = (short)(R2>>4);
+		else if ((R1&0x0F) != 0)
+			OTP[i] = (short)(R1&0x0F);
+		else
+			OTP[i] = (short)(R1>>4);
+
+	}
+	pr_info("%s: VenderID=%x,LensID=%x,SensorID=%x%x\n", __func__,
+		OTP[0], OTP[1], OTP[2], OTP[3]);
+	pr_info("%s: ModuleFuseID= %x%x%x%x%x%x\n", __func__,
+		OTP[4], OTP[5], OTP[6], OTP[7], OTP[8], OTP[9]);
+
+    cdata->cfg.fuse.fuse_id_word1 = 0;
+    cdata->cfg.fuse.fuse_id_word2 = 0;
+	cdata->cfg.fuse.fuse_id_word3 = (OTP[0]);
+	cdata->cfg.fuse.fuse_id_word4 =
+		(OTP[4]<<20) |
+		(OTP[5]<<16) |
+		(OTP[6]<<12) |
+		(OTP[7]<<8) |
+		(OTP[8]<<4) |
+		(OTP[9]);
+
+	pr_info("s5k3h1gx: fuse->fuse_id_word1:%d\n",
+		cdata->cfg.fuse.fuse_id_word1);
+	pr_info("s5k3h1gx: fuse->fuse_id_word2:%d\n",
+		cdata->cfg.fuse.fuse_id_word2);
+	pr_info("s5k3h1gx: fuse->fuse_id_word3:0x%08x\n",
+		cdata->cfg.fuse.fuse_id_word3);
+	pr_info("s5k3h1gx: fuse->fuse_id_word4:0x%08x\n",
+		cdata->cfg.fuse.fuse_id_word4);
+	return 0;
+}
+
+static int s5k3h1gx_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+  int32_t rc = 0;
+  struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+  pr_info("Calling s5k3h1gx_sensor_open_init\n");
+
+  down(&s5k3h1gx_sem);
+
+  if (data == NULL) {
+    pr_info("data is a NULL pointer\n");
+    goto init_fail;
+  }
+
+  s5k3h1gx_ctrl = kzalloc(sizeof(struct s5k3h1gx_ctrl), GFP_KERNEL);
+
+  if (!s5k3h1gx_ctrl) {
+    rc = -ENOMEM;
+    goto init_fail;
+  }
+
+  s5k3h1gx_ctrl->curr_lens_pos = -1;
+  s5k3h1gx_ctrl->fps_divider = 1 * 0x00000400;
+  s5k3h1gx_ctrl->pict_fps_divider = 1 * 0x00000400;
+  s5k3h1gx_ctrl->set_test = TEST_OFF;
+  s5k3h1gx_ctrl->prev_res = QTR_SIZE;
+  s5k3h1gx_ctrl->pict_res = FULL_SIZE;
+  s5k3h1gx_ctrl->curr_res = INVALID_SIZE;
+  s5k3h1gx_ctrl->reg_update = REG_INIT;
+
+  if (data)
+    s5k3h1gx_ctrl->sensordata = data;
+
+  /* switch pclk and mclk between main cam and 2nd cam */
+  pr_info("doing clk switch (s5k3h1gx)\n");
+
+  if (data->camera_clk_switch != NULL)
+    data->camera_clk_switch();
+
+  msm_camio_probe_on(s5k3h1gx_pdev);
+
+  /* for parallel interface */
+  if (!sinfo->csi_if) {
+    mdelay(20);
+    msm_camio_camif_pad_reg_reset();
+    mdelay(20);
+  }
+	pr_info("[Camera] gpio_request(%d, \"s5k3h1gx\")\n", data->sensor_pwd);
+	rc = gpio_request(data->sensor_pwd, "s5k3h1gx");
+	if (!rc) {
+		gpio_direction_output(data->sensor_pwd, 1);
+	} else {
+		pr_err("GPIO (%d) request failed\n", data->sensor_pwd);
+		goto init_fail;
+	}
+	gpio_free(data->sensor_pwd);
+	msleep(5);
+	rc = gpio_request(data->sensor_reset, "s5k3h1gx");
+	if (!rc) {
+		gpio_direction_output(data->sensor_reset, 1);
+	} else {
+		pr_err("GPIO (%d) request failed\n", data->sensor_reset);
+		goto init_fail;
+	}
+	gpio_free(data->sensor_reset);
+	msleep(1);
+
+  /* read sensor id */
+  rc = s5k3h1gx_probe_init_sensor(data);
+
+  if (rc < 0)
+    goto init_fail;
+
+  if (!sinfo->csi_if) {
+  rc = s5k3h1gx_i2c_write_table(
+         s5k3h1gx_regs.common_parallel,
+	          s5k3h1gx_regs.common_parallel_size);
+  }
+  else
+  {
+  rc = s5k3h1gx_i2c_write_table(
+		s5k3h1gx_regs.common_mipi,
+			s5k3h1gx_regs.common_mipi_size);
+  }
+
+  if (rc < 0)
+	      goto init_fail;
+
+  rc = s5k3h1gx_i2c_write_b(
+	s5k3h1gx_client->addr, 0x0100, 0x01);
+
+  /* set up lens position table */
+  s5k3h1gx_setup_af_tbl();
+  s5k3h1gx_go_to_position(0, 0);
+  s5k3h1gx_ctrl->curr_lens_pos = 0;
+  s5k3h1gx_ctrl->curr_step_pos = 0;
+
+  goto init_done;
+
+init_fail:
+  pr_err("%s: init_fail\n", __func__);
+
+init_done:
+  up(&s5k3h1gx_sem);
+  pr_info("%s: init_done\n", __func__);
+  return rc;
+
+} /* end of s5k3h1gx_sensor_open_init */
+
+static int s5k3h1gx_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&s5k3h1gx_wait_queue);
+	return 0;
+}
+
+static const struct i2c_device_id s5k3h1gx_i2c_id[] = {
+  { "s5k3h1gx", 0},
+  { }
+};
+
+static int s5k3h1gx_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	pr_info("s5k3h1gx_probe called!\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	s5k3h1gx_sensorw = kzalloc(sizeof(struct s5k3h1gx_work), GFP_KERNEL);
+	if (!s5k3h1gx_sensorw) {
+		pr_err("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, s5k3h1gx_sensorw);
+	s5k3h1gx_init_client(client);
+	s5k3h1gx_client = client;
+
+	msleep(50);
+
+	pr_info("s5k3h1gx_probe successed! rc = %d\n", rc);
+	return 0;
+
+probe_failure:
+	pr_err("s5k3h1gx_probe failed! rc = %d\n", rc);
+	return rc;
+}
+
+static int __exit s5k3h1gx_i2c_remove(struct i2c_client *client)
+{
+	struct s5k3h1gx_work_t *sensorw = i2c_get_clientdata(client);
+	free_irq(client->irq, sensorw);
+	deinit_suspend();
+	s5k3h1gx_client = NULL;
+	kfree(sensorw);
+	return 0;
+}
+
+static struct i2c_driver s5k3h1gx_i2c_driver = {
+  .id_table = s5k3h1gx_i2c_id,
+  .probe	= s5k3h1gx_i2c_probe,
+  .remove = __exit_p(s5k3h1gx_i2c_remove),
+  .driver = {
+    .name = "s5k3h1gx",
+  },
+};
+
+static const char *S5K3H1GXVendor = "samsung";
+static const char *S5K3H1GXNAME = "S5K3H1GX";
+static const char *S5K3H1GXSize = "8M";
+
+static ssize_t sensor_vendor_show( struct device *dev,
+  struct device_attribute *attr, char *buf)
+{
+  ssize_t ret = 0;
+
+  sprintf(buf, "%s %s %s\n", S5K3H1GXVendor, S5K3H1GXNAME, S5K3H1GXSize);
+  ret = strlen(buf) + 1;
+
+  return ret;
+}
+
+DEFINE_MUTEX(s5k3h1gx_cam_mode_lock);
+
+static ssize_t sensor_read_cam_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	mutex_lock(&s5k3h1gx_cam_mode_lock);
+	length = sprintf(buf, "%d\n", cam_mode_sel);
+	mutex_unlock(&s5k3h1gx_cam_mode_lock);
+	return length;
+}
+
+static ssize_t sensor_set_cam_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+	mutex_lock(&s5k3h1gx_cam_mode_lock);
+	tmp = buf[0] - 0x30; /* only get the first char */
+	cam_mode_sel = tmp;
+	mutex_unlock(&s5k3h1gx_cam_mode_lock);
+	return count;
+}
+
+static ssize_t sensor_read_node( struct device *dev,
+  struct device_attribute *attr, char *buf)
+{
+  ssize_t length;
+  length = sprintf(buf, "%d\n", sensor_probe_node);
+  return length;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+static DEVICE_ATTR(cam_mode, 0644, sensor_read_cam_mode, sensor_set_cam_mode);
+static DEVICE_ATTR(node, 0444, sensor_read_node, NULL);
+
+static struct kobject *android_s5k3h1gx = NULL;
+
+static int s5k3h1gx_sysfs_init(void)
+{
+  int ret = 0;
+  pr_info("s5k3h1gx:kobject creat and add\n");
+  android_s5k3h1gx = kobject_create_and_add("android_camera", NULL);
+  if (android_s5k3h1gx == NULL) {
+    pr_info("s5k3h1gx_sysfs_init: subsystem_register failed\n");
+    ret = -ENOMEM;
+    return ret ;
+  }
+  pr_info("s5k3h1gx:sysfs_create_file\n");
+  ret = sysfs_create_file(android_s5k3h1gx, &dev_attr_sensor.attr);
+  if (ret) {
+    pr_info("s5k3h1gx_sysfs_init: sysfs_create_file failed\n");
+    ret = -EFAULT;
+    goto error;
+  }
+
+	ret = sysfs_create_file(android_s5k3h1gx, &dev_attr_cam_mode.attr);
+	if (ret) {
+		pr_info("s5k3h1gx_sysfs_init: dev_attr_cam_mode failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+  ret = sysfs_create_file(android_s5k3h1gx, &dev_attr_node.attr);
+  if (ret) {
+    pr_info("s5k3h1gx_sysfs_init: dev_attr_node failed\n");
+    ret = -EFAULT;
+    goto error;
+  }
+
+  return ret;
+
+error:
+  kobject_del(android_s5k3h1gx);
+  return ret;
+}
+
+static int32_t
+s5k3h1gx_move_focus(int direction, int32_t num_steps)
+{
+  uint16_t s5k3h1gx_sw_damping_time_wait = 1;
+  uint16_t s5k3h1gx_damping_threshold = 10;
+  uint8_t s5k3h1gx_mode_mask = 0x02;
+  int16_t step_direction;
+  int16_t curr_lens_pos;
+  int16_t curr_step_pos;
+  int16_t dest_lens_pos;
+  int16_t dest_step_pos;
+  int16_t target_dist;
+  int16_t small_step;
+  int16_t next_lens_pos;
+  int16_t time_wait_per_step;
+  int32_t rc = 0, time_wait;
+  int8_t s5k3h1gx_sw_damping_required = 0;
+  uint16_t s5k3h1gx_max_fps_val;
+  struct msm_camera_sensor_info *sinfo = s5k3h1gx_pdev->dev.platform_data;
+
+  if (num_steps > S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR)
+      num_steps = S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR;
+  else if (num_steps == 0)
+      return -EINVAL;
+
+  if (direction == MOVE_NEAR)
+      step_direction = 1;
+  else if (direction == MOVE_FAR)
+      step_direction = -1;
+  else
+      return -EINVAL;
+
+  /* need to decide about default position and power supplied
+   * at start up and reset */
+  curr_lens_pos = s5k3h1gx_ctrl->curr_lens_pos;
+  curr_step_pos = s5k3h1gx_ctrl->curr_step_pos;
+
+  if (curr_lens_pos < s5k3h1gx_ctrl->init_curr_lens_pos)
+      curr_lens_pos = s5k3h1gx_ctrl->init_curr_lens_pos;
+
+  dest_step_pos = curr_step_pos + (step_direction * num_steps);
+
+  if (dest_step_pos < 0)
+      dest_step_pos = 0;
+  else if (dest_step_pos > S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR)
+      dest_step_pos = S5K3H1GX_TOTAL_STEPS_NEAR_TO_FAR;
+
+  if (dest_step_pos == s5k3h1gx_ctrl->curr_step_pos)
+      return rc;
+
+  dest_lens_pos = s5k3h1gx_pos_tbl[dest_step_pos];
+  target_dist = step_direction * (dest_lens_pos - curr_lens_pos);
+
+  if (sinfo->csi_if)
+	s5k3h1gx_max_fps_val = S5K3H1GX_MAX_FPS;
+  else
+	s5k3h1gx_max_fps_val = S5K3H1GX_MAX_FPS_PARALLEL;
+
+
+  /* HW damping */
+  if (step_direction < 0
+    && target_dist >= s5k3h1gx_pos_tbl[s5k3h1gx_damping_threshold]) {
+    s5k3h1gx_sw_damping_required = 1;
+    time_wait = 1000000
+      / s5k3h1gx_max_fps_val
+      - S5K3H1GX_SW_DAMPING_STEP * s5k3h1gx_sw_damping_time_wait * 1000;
+  } else
+    time_wait = 1000000 / s5k3h1gx_max_fps_val;
+
+  time_wait_per_step = (int16_t) (time_wait / target_dist);
+
+  if (time_wait_per_step >= 800)
+    /* ~800 */
+    s5k3h1gx_mode_mask = 0x5;
+  else if (time_wait_per_step >= 400)
+    /* ~400 */
+    s5k3h1gx_mode_mask = 0x4;
+  else if (time_wait_per_step >= 200)
+    /* 200~400 */
+    s5k3h1gx_mode_mask = 0x3;
+  else if (time_wait_per_step >= 100)
+    /* 100~200 */
+    s5k3h1gx_mode_mask = 0x2;
+  else if (time_wait_per_step >= 50)
+    /* 50~100 */
+    s5k3h1gx_mode_mask = 0x1;
+  else {
+    if (time_wait >= 17600)
+      s5k3h1gx_mode_mask = 0x0D;
+    else if (time_wait >= 8800)
+      s5k3h1gx_mode_mask = 0x0C;
+    else if (time_wait >= 4400)
+      s5k3h1gx_mode_mask = 0x0B;
+    else if (time_wait >= 2200)
+      s5k3h1gx_mode_mask = 0x0A;
+    else
+      s5k3h1gx_mode_mask = 0x09;
+  }
+
+  if (s5k3h1gx_sw_damping_required) {
+    small_step = (uint16_t) target_dist / S5K3H1GX_SW_DAMPING_STEP;
+    if ((target_dist % S5K3H1GX_SW_DAMPING_STEP) != 0)
+      small_step = small_step + 1;
+
+    for (next_lens_pos = curr_lens_pos + (step_direction*small_step);
+      (step_direction*next_lens_pos) <= (step_direction*dest_lens_pos);
+      next_lens_pos += (step_direction*small_step)) {
+      rc = s5k3h1gx_go_to_position(next_lens_pos, s5k3h1gx_mode_mask);
+      if (rc < 0) {
+      CDBG("s5k3h1gx_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+      }
+      curr_lens_pos = next_lens_pos;
+      mdelay(s5k3h1gx_sw_damping_time_wait);
+    }
+
+    if (curr_lens_pos != dest_lens_pos) {
+      rc = s5k3h1gx_go_to_position(dest_lens_pos, s5k3h1gx_mode_mask);
+      if (rc < 0) {
+      pr_err("s5k3h1gx_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+      }
+      mdelay(s5k3h1gx_sw_damping_time_wait);
+    }
+  } else {
+    rc = s5k3h1gx_go_to_position(dest_lens_pos, s5k3h1gx_mode_mask);
+    if (rc < 0) {
+      pr_err("s5k3h1gx_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+    }
+  }
+
+  s5k3h1gx_ctrl->curr_lens_pos = dest_lens_pos;
+  s5k3h1gx_ctrl->curr_step_pos = dest_step_pos;
+
+  return rc;
+}
+
+static int32_t
+s5k3h1gx_set_default_focus(void)
+{
+  int32_t rc = 0;
+  if (s5k3h1gx_ctrl->curr_step_pos != 0) {
+    rc = s5k3h1gx_move_focus(MOVE_FAR, s5k3h1gx_ctrl->curr_step_pos);
+    if (rc < 0) {
+      pr_err("s5k3h1gx_set_default_focus Failed!!!\n");
+      return rc;
+    }
+  } else {
+    rc = s5k3h1gx_go_to_position(0, 0x02);
+    if (rc < 0) {
+      pr_err("s5k3h1gx_go_to_position Failed!!!\n");
+      return rc;
+    }
+  }
+
+  s5k3h1gx_ctrl->curr_lens_pos = 0;
+  s5k3h1gx_ctrl->init_curr_lens_pos = 0;
+  s5k3h1gx_ctrl->curr_step_pos = 0;
+
+  return rc;
+}
+
+uint8_t s5k3h1gx_preview_skip_frame(void)
+{
+	if (s5k3h1gx_ctrl->sensormode == SENSOR_PREVIEW_MODE
+		&& preview_frame_count < 2) {
+		preview_frame_count++;
+		return 1;
+	}
+	return 0;
+}
+
+int s5k3h1gx_sensor_config(void __user *argp)
+{
+  struct sensor_cfg_data cdata;
+  long rc = 0;
+
+  if (copy_from_user(&cdata,
+    (void *)argp,
+    sizeof(struct sensor_cfg_data)))
+    return -EFAULT;
+
+  down(&s5k3h1gx_sem);
+
+  CDBG("s5k3h1gx_sensor_config: cfgtype = %d\n",
+    cdata.cfgtype);
+  switch (cdata.cfgtype) {
+  case CFG_GET_PICT_FPS:
+    s5k3h1gx_get_pict_fps(
+      cdata.cfg.gfps.prevfps,
+      &(cdata.cfg.gfps.pictfps));
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_GET_PREV_L_PF:
+    cdata.cfg.prevl_pf =
+      s5k3h1gx_get_prev_lines_pf();
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_GET_PREV_P_PL:
+    cdata.cfg.prevp_pl =
+      s5k3h1gx_get_prev_pixels_pl();
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_GET_PICT_L_PF:
+    cdata.cfg.pictl_pf =
+      s5k3h1gx_get_pict_lines_pf();
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_GET_PICT_P_PL:
+    cdata.cfg.pictp_pl =
+      s5k3h1gx_get_pict_pixels_pl();
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_GET_PICT_MAX_EXP_LC:
+    cdata.cfg.pict_max_exp_lc =
+      s5k3h1gx_get_pict_max_exp_lc();
+
+    if (copy_to_user((void *)argp,
+      &cdata,
+      sizeof(struct sensor_cfg_data)))
+      rc = -EFAULT;
+    break;
+
+  case CFG_SET_FPS:
+  case CFG_SET_PICT_FPS:
+    rc = s5k3h1gx_set_fps(&(cdata.cfg.fps));
+    break;
+
+  case CFG_SET_EXP_GAIN:
+	rc = s5k3h1gx_write_exp_gain(
+		cdata.cfg.exp_gain.gain,
+		cdata.cfg.exp_gain.line);
+    break;
+
+  case CFG_SET_PICT_EXP_GAIN:
+	rc = s5k3h1gx_set_pict_exp_gain(
+		cdata.cfg.exp_gain.gain,
+		cdata.cfg.exp_gain.line);
+    break;
+
+  case CFG_SET_MODE:
+    rc = s5k3h1gx_set_sensor_mode(cdata.mode,
+      cdata.rs);
+    break;
+
+  case CFG_PWR_DOWN:
+    rc = s5k3h1gx_power_down();
+    break;
+
+  case CFG_MOVE_FOCUS:
+    rc =
+      s5k3h1gx_move_focus(
+      cdata.cfg.focus.dir,
+      cdata.cfg.focus.steps);
+    break;
+
+  case CFG_SET_DEFAULT_FOCUS:
+    rc =
+      s5k3h1gx_set_default_focus();
+    break;
+
+	case CFG_I2C_IOCTL_R_OTP:{
+		pr_info("Line:%d CFG_I2C_IOCTL_R_OTP \n", __LINE__);
+		rc = s5k3h1gx_i2c_read_fuseid(&cdata);
+		if (copy_to_user(argp, &cdata, sizeof(struct sensor_cfg_data)))
+			rc = -EFAULT;
+		}
+		break;
+
+  /*20101011 for QCT mesh LSC calibration*/
+  case CFG_SET_QCT_LSC_RAW_CAPTURE:
+		pr_info("Line:%d : CFG_SET_QCT_LSC_RAW_CAPTURE \n", __LINE__);
+		rc = s5k3h1gx_QCT_LSC_calibration_set_rawflag();
+		break;
+
+  default:
+    rc = -EFAULT;
+    break;
+  }
+
+  prevent_suspend();
+  up(&s5k3h1gx_sem);
+
+  return rc;
+}
+
+static int s5k3h1gx_sensor_release(void)
+{
+	int rc = -EBADF;
+
+	down(&s5k3h1gx_sem);
+	pr_info("%s, %d\n", __func__, __LINE__);
+
+	if (s5k3h1gx_ctrl) {
+		rc = gpio_request(
+			s5k3h1gx_ctrl->sensordata->sensor_pwd, "s5k3h1gx");
+		if (!rc)
+			gpio_direction_output(
+				s5k3h1gx_ctrl->sensordata->sensor_pwd, 0);
+		else
+			pr_err("GPIO (%d) request failed\n",
+				s5k3h1gx_ctrl->sensordata->sensor_pwd);
+		gpio_free(s5k3h1gx_ctrl->sensordata->sensor_pwd);
+	}
+
+	msleep(5);
+       rc = gpio_request(
+               s5k3h1gx_ctrl->sensordata->sensor_reset, "s5k3h1gx");
+       if (!rc)
+               gpio_direction_output(
+                       s5k3h1gx_ctrl->sensordata->sensor_reset, 0);
+      else
+               pr_err("GPIO (%d) request faile\n",
+                       s5k3h1gx_ctrl->sensordata->sensor_reset);
+       gpio_free(s5k3h1gx_ctrl->sensordata->sensor_reset);
+
+
+	msm_camio_probe_off(s5k3h1gx_pdev);
+
+	if (s5k3h1gx_ctrl != NULL) {
+		kfree(s5k3h1gx_ctrl);
+		s5k3h1gx_ctrl = NULL;
+	}
+
+	allow_suspend();
+	pr_info("s5k3h1gx_release completed\n");
+	up(&s5k3h1gx_sem);
+
+	return rc;
+}
+
+static int s5k3h1gx_sensor_probe(struct msm_camera_sensor_info *info,
+  struct msm_sensor_ctrl *s)
+{
+  int rc = 0;
+  pr_info("s5k3h1gx_sensor_probe()\n");
+
+  rc = i2c_add_driver(&s5k3h1gx_i2c_driver);
+  if (rc < 0 || s5k3h1gx_client == NULL) {
+    rc = -ENOTSUPP;
+    goto probe_fail;
+  }
+
+  pr_info("s5k3h1 s->node %d\n", s->node);
+  sensor_probe_node = s->node;
+
+  /* switch PCLK and MCLK to Main cam */
+  pr_info("s5k3h1gx: s5k3h1gx_sensor_probe: switch clk\n");
+  if (info->camera_clk_switch != NULL)
+    info->camera_clk_switch();
+
+  mdelay(20);
+
+  pr_info("[Camera] gpio_request(%d, \"s5k3h1gx\")\n", info->sensor_pwd);
+  rc = gpio_request(info->sensor_pwd, "s5k3h1gx");
+  if (!rc)
+    gpio_direction_output(info->sensor_pwd, 1);
+  else
+    pr_err("GPIO (%d) request failed\n", info->sensor_pwd);
+  gpio_free(info->sensor_pwd);
+
+  msleep(100);
+
+  /* read sensor id */
+  rc = s5k3h1gx_probe_init_sensor(info);
+
+  if (rc < 0)
+    goto probe_fail;
+
+  /* Initialize Sensor registers */
+  rc = initialize_s5k3h1gx_registers();
+  if (rc < 0)
+    return rc;
+
+  if (info->camera_main_set_probe != NULL)
+    info->camera_main_set_probe(true);
+
+  init_suspend();
+  s->s_init = s5k3h1gx_sensor_open_init;
+  s->s_release = s5k3h1gx_sensor_release;
+  s->s_config  = s5k3h1gx_sensor_config;
+  s5k3h1gx_probe_init_done(info);
+  s5k3h1gx_sysfs_init();
+
+  pr_info("%s: s5k3h1gx_probe_init_done %d\n",  __func__, __LINE__);
+  goto probe_done;
+
+probe_fail:
+  pr_err("SENSOR PROBE FAILS!\n");
+probe_done:
+  return rc;
+
+}
+
+static int __s5k3h1gx_probe(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	pr_info("s5k3h1gx_probe\n");
+	s5k3h1gx_pdev = pdev;
+	if (sdata->camera_main_get_probe != NULL) {
+		if (sdata->camera_main_get_probe()) {
+			pr_info("__s5k3h1gx_probe camera main get probed already.\n");
+			return 0;
+		}
+	}
+	return msm_camera_drv_start(pdev, s5k3h1gx_sensor_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __s5k3h1gx_probe,
+	.driver = {
+		.name = "msm_camera_s5k3h1gx",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init s5k3h1gx_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(s5k3h1gx_init);
diff --git a/drivers/media/video/msm/s5k3h1gx.h b/drivers/media/video/msm/s5k3h1gx.h
new file mode 100644
index 0000000..cfd7583
--- /dev/null
+++ b/drivers/media/video/msm/s5k3h1gx.h
@@ -0,0 +1,93 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef S5K3H1GX_H
+#define S5K3H1GX_H
+
+#include <linux/types.h>
+#include <mach/camera.h>
+
+struct s5k3h1gx_i2c_reg_conf {
+	unsigned short waddr;
+	unsigned char  bdata;
+};
+
+struct s5k3h1gx_reg_t {
+	struct s5k3h1gx_i2c_reg_conf *init_mipi;
+	uint16_t init_mipi_size;
+	struct s5k3h1gx_i2c_reg_conf *init_parallel;
+	uint16_t init_parallel_size;
+
+	struct s5k3h1gx_i2c_reg_conf *common_mipi;
+	uint16_t common_mipi_size;
+	struct s5k3h1gx_i2c_reg_conf *common_parallel;
+	uint16_t common_parallel_size;
+
+	struct s5k3h1gx_i2c_reg_conf *qtr_mipi;
+	uint16_t qtr_mipi_size;
+	struct s5k3h1gx_i2c_reg_conf *qtr_parallel;
+	uint16_t qtr_parallel_size;
+
+	struct s5k3h1gx_i2c_reg_conf *full_mipi;
+	uint16_t full_mipi_size;
+	struct s5k3h1gx_i2c_reg_conf *full_parallel;
+	uint16_t full_parallel_size;
+};
+
+extern struct s5k3h1gx_reg_t s5k3h1gx_regs;
+
+#endif
+
diff --git a/drivers/media/video/msm/s5k3h1gx_reg.c b/drivers/media/video/msm/s5k3h1gx_reg.c
new file mode 100644
index 0000000..3854828
--- /dev/null
+++ b/drivers/media/video/msm/s5k3h1gx_reg.c
@@ -0,0 +1,420 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "s5k3h1gx.h"
+
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_init_settings_array_mipi[] =
+{
+  /* Because we will turn off power source after probe, there is no need to set register here */
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_init_settings_array_parallel[] =
+{
+  /* Because we will turn off power source after probe, there is no need to set register here */
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_common_settings_array_mipi[] =
+{
+  { 0x0100 , 0x00 },
+  { 0x3091 , 0x00 },
+  { 0x310E , 0x00 },
+  { 0x0111 , 0x01 },
+  { 0x3098 , 0xAB },
+  { 0x309A , 0x01 },
+  { 0x310D , 0xC6 },
+  { 0x30C3 , 0x40 },
+  { 0x308E , 0x05 },
+  { 0x308F , 0x88 },
+  { 0x30BB , 0x02 },
+  { 0x30C7 , 0x1A },
+  { 0x30BC , 0x38 },
+  { 0x30BD , 0x40 },
+  { 0x3110 , 0x70 },
+  { 0x3111 , 0x80 },
+  { 0x3112 , 0x7B },
+  { 0x3113 , 0xC0 },
+  { 0x3000 , 0x08 },
+  { 0x3001 , 0x05 },
+  { 0x3002 , 0x0D },
+  { 0x3003 , 0x21 },
+  { 0x3004 , 0x62 },
+  { 0x3005 , 0x0B },
+  { 0x3006 , 0x6D },
+  { 0x3007 , 0x02 },
+  { 0x3008 , 0x62 },
+  { 0x3009 , 0x62 },
+  { 0x300A , 0x41 },
+  { 0x300B , 0x10 },
+  { 0x300C , 0x21 },
+  { 0x300D , 0x04 },
+  { 0x307E , 0x03 },
+  { 0x307F , 0xA5 },
+  { 0x3080 , 0x04 },
+  { 0x3081 , 0x29 },
+  { 0x3082 , 0x03 },
+  { 0x3083 , 0x21 },
+  { 0x3011 , 0x5F },
+  { 0x3156 , 0xE2 },
+  { 0x3027 , 0x0E },
+  { 0x300f , 0x02 },
+  { 0x3072 , 0x13 },
+  { 0x3073 , 0x61 },
+  { 0x3074 , 0x92 },
+  { 0x3075 , 0x10 },
+  { 0x3076 , 0xA2 },
+  { 0x3077 , 0x02 },
+  { 0x3078 , 0x91 },
+  { 0x3079 , 0x91 },
+  { 0x307A , 0x61 },
+  { 0x307B , 0x18 },
+  { 0x307C , 0x61 },
+  { 0x3010 , 0x10 },
+  { 0x3017 , 0x74 },
+  { 0x3018 , 0x00 },
+  { 0x3020 , 0x02 },
+  { 0x3021 , 0x24 },
+  { 0x3023 , 0x40 },
+  { 0x3024 , 0x08 },
+  { 0x3025 , 0x08 },
+  { 0x301C , 0xD4 },
+  { 0x315D , 0x00 },
+  { 0x3053 , 0xCF },
+  { 0x3054 , 0x00 },
+  { 0x3055 , 0x35 },
+  { 0x3062 , 0x04 },
+  { 0x3063 , 0x38 },
+  { 0x3016 , 0x2c },
+  { 0x3157 , 0x02 },
+  { 0x3158 , 0x00 },
+  { 0x315B , 0x02 },
+  { 0x315C , 0x00 },
+  { 0x301B , 0x04 },
+  { 0x301A , 0xC4 },
+  { 0x302d , 0x19 },
+  { 0x302b , 0x04 },
+  { 0x0305 , 0x04 }, /* pre_pll_clk_div = 4 */
+  { 0x0306 , 0x00 }, /* pll_multiplier */
+  { 0x0307 , 0x66 }, /* pll_multiplier = 102 */
+  { 0x0303 , 0x01 }, /* vt_sys_clk_div = 1 */
+  { 0x0301 , 0x05 }, /* vt_pix_clk_div = 5 */
+  { 0x030B , 0x01 }, /* op_sys_clk_div = 1 */
+  { 0x0309 , 0x05 }, /* op_pix_clk_div = 5 */
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_common_settings_array_parallel[] =
+{
+  { 0x0100 , 0x00 },
+  /* MIPI/CCP/Parallel Setting */
+  { 0x3091 , 0x00 },
+  { 0x3065 , 0x15 },  /* sync mode */
+  { 0x310E , 0x08 },  /* reg_sel 08h:parallel / 04h: CCP / 00h : MIPI */
+  { 0x0111 , 0x01 },  /* CCP2_signalling_mode */
+  { 0x308E , 0x05 },
+  { 0x308F , 0x88 },
+  /* Manufacture Setting */
+  { 0x3000 , 0x08 },
+  { 0x3001 , 0x05 },
+  { 0x3002 , 0x0D },
+  { 0x3003 , 0x21 },
+  { 0x3004 , 0x62 },
+  { 0x3005 , 0x0B },
+  { 0x3006 , 0x6D },
+  { 0x3007 , 0x02 },
+  { 0x3008 , 0x62 },
+  { 0x3009 , 0x62 },
+  { 0x300A , 0x41 },
+  { 0x300B , 0x10 },
+  { 0x300C , 0x21 },
+  { 0x300D , 0x04 },
+  { 0x307E , 0x03 },
+  { 0x307F , 0xA5 },
+  { 0x3080 , 0x04 },
+  { 0x3081 , 0x29 },
+  { 0x3082 , 0x03 },
+  { 0x3083 , 0x21 },
+  { 0x3011 , 0x5F },
+  { 0x3156 , 0xE2 },
+ /* { 0x3027 , 0x0E }, */
+  { 0x300f , 0x02 },
+  { 0x3072 , 0x13 },
+  { 0x3073 , 0x61 },
+  { 0x3074 , 0x92 },
+  { 0x3075 , 0x10 },
+  { 0x3076 , 0xA2 },
+  { 0x3077 , 0x02 },
+  { 0x3078 , 0x91 },
+  { 0x3079 , 0x91 },
+  { 0x307A , 0x61 },
+  { 0x307B , 0x18 },
+  { 0x307C , 0x61 },
+  { 0x3010 , 0x10 },
+  { 0x3017 , 0x74 },
+  { 0x3018 , 0x00 },
+  { 0x3020 , 0x02 },
+  { 0x3021 , 0x24 },
+  { 0x3023 , 0x40 },
+  { 0x3024 , 0x08 },
+  { 0x3025 , 0x08 },
+  { 0x301C , 0xD4 },
+  { 0x315D , 0x00 },
+  { 0x3053 , 0xCF },
+  { 0x3054 , 0x00 },
+  { 0x3055 , 0x35 },
+  { 0x3062 , 0x04 },
+  { 0x3063 , 0x38 },
+  { 0x3016 , 0x2c },
+  { 0x3157 , 0x02 },
+  { 0x3158 , 0x00 },
+  { 0x315B , 0x02 },
+  { 0x315C , 0x00 },
+  { 0x301A , 0xC4 },
+  { 0x301B , 0x04 },
+  { 0x302d , 0x19 },
+  { 0x302b , 0x04 },
+  { 0x310d , 0xe6 },
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_qtr_settings_array_mipi[] =
+{
+  { 0x30CC , 0xA0 }, /* DPHY_band_ctrl 560 ~ 640Mbps */
+  { 0x0344 , 0x00 }, /* Xaddrstart 0d */
+  { 0x0345 , 0x00 },
+  { 0x0346 , 0x00 }, /* Yaddrstart 0d */
+  { 0x0347 , 0x00 },
+  { 0x0348 , 0x0C }, /* Xaddrend 3279d */
+  { 0x0349 , 0xCf },
+  { 0x034A , 0x09 }, /* Yaddrend 2463d */
+  { 0x034B , 0x9F },
+  { 0x0381 , 0x01 }, /* x_even_inc = 1 */
+  { 0x0383 , 0x01 }, /* x_odd_inc = 1 */
+  { 0x0385 , 0x01 }, /* y_even_inc = 1 */
+  { 0x0387 , 0x03 }, /* y_odd_inc = 3 */
+  { 0x034C , 0x06 }, /* x_output_size = 1640 */
+  { 0x034D , 0x68 },
+  { 0x034E , 0x04 }, /* y_output_size = 1232 */
+  { 0x034F , 0xD0 },
+  { 0x0200 , 0x02 }, /* fine integration time */
+  { 0x0201 , 0x50 },
+  { 0x0202 , 0x03 }, /* Coarse integration time */
+  { 0x0203 , 0xA0 },
+  { 0x0204 , 0x00 }, /* Analog gain */
+  { 0x0205 , 0x20 },
+  { 0x0342 , 0x0D }, /* Line_length_pck 3470d */
+  { 0x0343 , 0x8E },
+  { 0x0340 , 0x04 }, /* Frame_length_lines 1248d */
+  { 0x0341 , 0xE0 },
+  { 0x300E , 0xED }, /* Reserved */
+  { 0x3085 , 0x00 }, /* Reserved */
+  { 0x301D , 0x81 }, /* Reserved */
+  { 0x3086 , 0x03 }, /* Reserved */
+  { 0x3087 , 0x34 }, /* Reserved */
+  { 0x3065 , 0x15 }, /* Reserved */
+  { 0x3028 , 0x40 }, /* Reserved */
+  { 0x0100 , 0x01 },
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_qtr_settings_array_parallel[] =
+{
+  /* PLL settings  MCLK:24MHz,vt_pix_clk_freq_mhz=130.2MHz,op_sys_clk_freq_mhz=65.1MHz */
+  { 0x0305 , 0x08 }, /* pre_pll_clk_div = 8	*/
+  { 0x0306 , 0x01 }, /* pll_multiplier */
+  { 0x0307 , 0x40 }, /* pll_multiplier = 320 */
+  { 0x0303 , 0x01 }, /* vt_sys_clk_div = 1 */
+  { 0x0301 , 0x05 }, /* vt_pix_clk_div = 5 */
+  { 0x030B , 0x01 }, /* op_sys_clk_div = 1 */
+  { 0x0309 , 0x0A }, /* op_pix_clk_div = 10 */
+  /* DBLR Clock setting = 96Mhz = vt_pix_clk_freq_mhz/2 */
+  { 0x3027 , 0x7E },
+
+  /* Readout	H:1/2 SubSampling binning, V:1/2 SubSampling binning */
+  { 0x0344 , 0x00 }, /* X addr start 0d */
+  { 0x0345 , 0x00 },
+  { 0x0346 , 0x00 }, /* Y addr start 0d */
+  { 0x0347 , 0x00 },
+  { 0x0348 , 0x0C }, /* X addr end 3279d */
+  { 0x0349 , 0xCF },
+  { 0x034A , 0x09 }, /* Y addr end 2463d */
+  { 0x034B , 0x9F },
+  { 0x0381 , 0x01 }, /* x_even_inc = 1 */
+  { 0x0383 , 0x01 }, /* x_odd_inc = 1 */
+  { 0x0385 , 0x01 }, /* y_even_inc = 1 */
+  { 0x0387 , 0x03 }, /* y_odd_inc = 3 */
+  /* ------------- */
+  { 0x0401 , 0x01 }, /* Derating_en  = 1 (disable) */
+  { 0x0405 , 0x10 },
+  { 0x0700 , 0x05 }, /* fifo_threshold = 1328 */
+  { 0x0701 , 0x30 },
+  /* ------------- */
+  { 0x034C , 0x06 }, /* x_output_size = 1640 */
+  { 0x034D , 0x68 },
+  { 0x034E , 0x04 }, /* y_output_size = 1232 */
+  { 0x034F , 0xD0 },
+  { 0x0200 , 0x03 }, /* fine integration time */
+  { 0x0201 , 0x50 },
+  /* ------------- */
+  { 0x0202 , 0x03 }, /* Coarse integration time */
+  { 0x0203 , 0xA0 }, /* DB */
+  /* ------------- */
+  { 0x0204 , 0x00 }, /* Analog gain */
+  { 0x0205 , 0x20 },
+  { 0x0342 , 0x0D }, /* Line_length_pck 3470d */
+  { 0x0343 , 0x8E },
+  { 0x0340 , 0x07 }, /* Frame_length_lines 1843d */
+  { 0x0341 , 0x33 },
+  /* Manufacture Setting */
+  { 0x300E , 0xED },
+  { 0x3085 , 0x00 },
+  { 0x301D , 0x81 },
+  { 0x3028 , 0x40 },
+  { 0x3086 , 0x03 },
+  { 0x3087 , 0x34 },
+  { 0x3065 , 0x15 },
+  /* ------------- */
+  { 0x310C , 0x50 }, /* pclk invert */
+  { 0x3117 , 0x0F }, /* H/V sync driving strength 6mA */
+  { 0x3118 , 0xF0 }, /* parallel data driving strength 6mA */
+  /* ------------- */
+
+  /*{ 0x0100 , 0x01 },*/
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_full_settings_array_mipi[] =
+{
+  { 0x30CC , 0xA0 }, /* DPHY_band_ctrl 560 ~ 640Mbps */
+  { 0x0344 , 0x00 }, /* X addr start 0d */
+  { 0x0345 , 0x00 },
+  { 0x0346 , 0x00 }, /* Y addr start 0d */
+  { 0x0347 , 0x00 },
+  { 0x0348 , 0x0C }, /* X addr end 3279d */
+  { 0x0349 , 0xCf },
+  { 0x034A , 0x09 }, /* Y addr end 2463d */
+  { 0x034B , 0x9F },
+  { 0x0381 , 0x01 }, /* x_even_inc = 1 */
+  { 0x0383 , 0x01 }, /* x_odd_inc = 1 */
+  { 0x0385 , 0x01 }, /* y_even_inc = 1 */
+  { 0x0387 , 0x01 }, /* y_odd_inc = 1 */
+  { 0x034C , 0x0C }, /* x_output_size = 3280 */
+  { 0x034D , 0xD0 },
+  { 0x034E , 0x09 }, /* y_output_size = 2464 */
+  { 0x034F , 0xA0 },
+  { 0x0200 , 0x02 }, /* fine integration time */
+  { 0x0201 , 0x50 },
+  { 0x0202 , 0x04 }, /* Coarse integration time */
+  { 0x0203 , 0xE7 },
+  { 0x0204 , 0x00 }, /* Analog gain */
+  { 0x0205 , 0x20 },
+  { 0x0342 , 0x0D }, /* Line_length_pck */
+  { 0x0343 , 0x8E },
+  { 0x0340 , 0x09 }, /* Frame_length_lines */
+  { 0x0341 , 0xB0 },
+  { 0x300E , 0xE9 }, /* Reserved */
+  { 0x3085 , 0x01 }, /* Reserved */
+  { 0x301D , 0x01 }, /* Reserved */
+  { 0x3086 , 0x03 }, /* Reserved */
+  { 0x3087 , 0x34 }, /* Reserved */
+  { 0x3065 , 0x15 }, /* Reserved */
+  { 0x3028 , 0x41 }, /* Reserved */
+  { 0x0100 , 0x01 },
+};
+
+struct s5k3h1gx_i2c_reg_conf s5k3h1gx_full_settings_array_parallel[] =
+{
+  /* PLL settings  MCLK:24MHz,vt_pix_clk_freq_mhz=96MHz,op_sys_clk_freq_mhz=96MHz */
+  { 0x0305 , 0x04 }, /* pre_pll_clk_div = 4 */
+  { 0x0306 , 0x00 }, /* pll_multiplier */
+  { 0x0307 , 0xA0 }, /* pll_multiplier  = 160 */
+  { 0x0303 , 0x01 }, /* vt_sys_clk_div = 1 */
+  { 0x0301 , 0x0A }, /* vt_pix_clk_div = 10 */
+  { 0x030B , 0x01 }, /* op_sys_clk_div = 1 */
+  { 0x0309 , 0x0A }, /* op_pix_clk_div = 10 */
+  /* DBLR Clock setting = 96Mhz = vt_pix_clk_freq_mhz */
+  { 0x3027 , 0x3E },
+  /* Readout	Full */
+  { 0x0344 , 0x00 }, /* X addr start 0d */
+  { 0x0345 , 0x00 },
+  { 0x0346 , 0x00 }, /* Y addr start 0d */
+  { 0x0347 , 0x00 },
+  { 0x0348 , 0x0C }, /* X addr end 3279d */
+  { 0x0349 , 0xCF },
+  { 0x034A , 0x09 }, /* Y addr end 2463d */
+  { 0x034B , 0x9F },
+  { 0x0381 , 0x01 }, /* x_even_inc = 1 */
+  { 0x0383 , 0x01 }, /* x_odd_inc = 1 */
+  { 0x0385 , 0x01 }, /* y_even_inc = 1 */
+  { 0x0387 , 0x01 }, /* y_odd_inc = 1 */
+  /* ------------- */
+  { 0x0401 , 0x00 }, /* Scaler OFF */
+  { 0x0405 , 0x10 }, /* Scaling ratio 16/16 */
+  { 0x0700 , 0x03 }, /* fifo_threshold = 818d */
+  { 0x0701 , 0x32 },
+  /* ------------- */
+  { 0x034C , 0x0C }, /* x_output_size = 3280 */
+  { 0x034D , 0xD0 },
+  { 0x034E , 0x09 }, /* y_output_size = 2464 */
+  { 0x034F , 0xA0 },
+  { 0x0200 , 0x03 }, /* fine integration time */
+  { 0x0201 , 0x50 },
+  { 0x0202 , 0x04 }, /* Coarse integration time */
+  { 0x0203 , 0xE7 },
+  { 0x0204 , 0x00 }, /* Analog gain */
+  { 0x0205 , 0x20 },
+  { 0x0342 , 0x0D }, /* Line_length_pck 3470d */
+  { 0x0343 , 0x8E },
+  { 0x0340 , 0x09 }, /* Frame_length_lines 2480d */
+  { 0x0341 , 0xB0 },
+  /* Manufacture Setting */
+  { 0x300E , 0xE9 },
+  { 0x3085 , 0x01 },
+  { 0x301D , 0x01 },
+  { 0x3086 , 0x03 },
+  { 0x3087 , 0x34 },
+  { 0x3028 , 0x41 },
+  { 0x3065 , 0x15 },
+  /* ------------- */
+  { 0x310C , 0x50 }, /* pclk invert */
+  { 0x3117 , 0x0F }, /* H/V sync driving strength 6mA */
+  { 0x3118 , 0xF0 }, /* parallel data driving strength 6mA */
+  /* ------------- */
+
+  /*{ 0x0100 , 0x01 },*/
+};
+
+
+
+struct s5k3h1gx_reg_t s5k3h1gx_regs = {
+	.init_mipi = &s5k3h1gx_init_settings_array_mipi[0],
+	.init_mipi_size = ARRAY_SIZE(s5k3h1gx_init_settings_array_mipi),
+	.init_parallel = &s5k3h1gx_init_settings_array_parallel[0],
+	.init_parallel_size = ARRAY_SIZE(s5k3h1gx_init_settings_array_parallel),
+
+	.common_mipi = &s5k3h1gx_common_settings_array_mipi[0],
+	.common_mipi_size = ARRAY_SIZE(s5k3h1gx_common_settings_array_mipi),
+	.common_parallel = &s5k3h1gx_common_settings_array_parallel[0],
+	.common_parallel_size = ARRAY_SIZE(s5k3h1gx_common_settings_array_parallel),
+
+	.qtr_mipi = &s5k3h1gx_qtr_settings_array_mipi[0],
+	.qtr_mipi_size = ARRAY_SIZE(s5k3h1gx_qtr_settings_array_mipi),
+	.qtr_parallel = &s5k3h1gx_qtr_settings_array_parallel[0],
+	.qtr_parallel_size = ARRAY_SIZE(s5k3h1gx_qtr_settings_array_parallel),
+
+	.full_mipi = &s5k3h1gx_full_settings_array_mipi[0],
+	.full_mipi_size = ARRAY_SIZE(s5k3h1gx_full_settings_array_mipi),
+	.full_parallel = &s5k3h1gx_full_settings_array_parallel[0],
+	.full_parallel_size = ARRAY_SIZE(s5k3h1gx_full_settings_array_parallel),
+};
diff --git a/drivers/media/video/msm/s5k6aafx.c b/drivers/media/video/msm/s5k6aafx.c
new file mode 100644
index 0000000..b7b84b4
--- /dev/null
+++ b/drivers/media/video/msm/s5k6aafx.c
@@ -0,0 +1,1022 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <media/msm_camera.h>
+#include <mach/gpio.h>
+#include "s5k6aafx.h"
+
+struct s5k6aafx_work {
+	struct work_struct work;
+};
+
+static struct s5k6aafx_work *s5k6aafx_sensorw;
+static struct i2c_client *s5k6aafx_client;
+
+struct s5k6aafx_ctrl {
+	const struct msm_camera_sensor_info *sensordata;
+};
+
+static struct s5k6aafx_ctrl *s5k6aafx_ctrl;
+static struct platform_device *s5k6aafx_pdev;
+
+static int op_mode;
+static DECLARE_WAIT_QUEUE_HEAD(s5k6aafx_wait_queue);
+DEFINE_SEMAPHORE(s5k6aafx_sem);
+
+static int sensor_probe_node = 0;
+static enum frontcam_t previous_mirror_mode;
+
+static enum wb_mode current_wb = CAMERA_AWB_AUTO;
+static int s5k6aafx_set_wb(enum wb_mode wb_value);
+
+#define MAX_I2C_RETRIES 20
+static int i2c_transfer_retry(struct i2c_adapter *adap,
+			struct i2c_msg *msgs,
+			int len)
+{
+	int i2c_retry = 0;
+	int ns; /* number sent */
+
+	while (i2c_retry++ < MAX_I2C_RETRIES) {
+		ns = i2c_transfer(adap, msgs, len);
+		if (ns == len)
+			break;
+		pr_err("%s: try %d/%d: i2c_transfer sent: %d, len %d\n",
+			__func__,
+			i2c_retry, MAX_I2C_RETRIES, ns, len);
+		msleep(10);
+	}
+
+	return ns == len ? 0 : -EIO;
+}
+
+
+static int s5k6aafx_i2c_txdata(unsigned short saddr,
+				  unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txdata,
+		 },
+	};
+
+	if (i2c_transfer_retry(s5k6aafx_client->adapter, msg, 1) < 0) {
+		pr_info("s5k6aafx_i2c_txdata failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int s5k6aafx_i2c_write(unsigned short saddr,
+				 unsigned short waddr, unsigned short wdata)
+{
+	int rc = -EIO;
+	unsigned char buf[4];
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	buf[2] = (wdata & 0xFF00) >> 8;
+	buf[3] = (wdata & 0x00FF);
+	rc = s5k6aafx_i2c_txdata(saddr, buf, 4);
+	if (rc < 0)
+		pr_info("i2c_write failed, addr = 0x%x, val = 0x%x!\n",
+		     waddr, wdata);
+
+	return rc;
+}
+
+static int s5k6aafx_i2c_write_table(struct s5k6aafx_i2c_reg_conf const
+				       *reg_conf_tbl, int num_of_items_in_table)
+{
+	int i;
+	int rc = -EIO;
+
+	for (i = 0; i < num_of_items_in_table; i++) {
+		rc = s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		       reg_conf_tbl->waddr, reg_conf_tbl->wdata);
+		if (rc < 0)
+			break;
+		reg_conf_tbl++;
+	}
+	return rc;
+}
+
+static int s5k6aafx_i2c_rxdata(unsigned short saddr,
+			      unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = 2,
+		 .buf = rxdata,
+		 },
+		{
+		 .addr = saddr,
+		 .flags = I2C_M_RD,
+		 .len = length,
+		 .buf = rxdata,
+		 },
+	};
+
+	if (i2c_transfer_retry(s5k6aafx_client->adapter, msgs, 2) < 0) {
+		pr_info("s5k6aafx_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int s5k6aafx_i2c_read(unsigned short saddr,
+				unsigned short raddr, unsigned short *rdata)
+{
+	int32_t rc = 0;
+	unsigned char buf[4];
+
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (raddr & 0xFF00)>>8;
+	buf[1] = (raddr & 0x00FF);
+
+	rc = s5k6aafx_i2c_rxdata(saddr, buf, 2);
+	if (rc < 0){
+		printk(KERN_ERR "s5k6aafx_i2c_read failed!\n");
+		return rc;
+	}
+
+	*rdata = buf[0] << 8 | buf[1];
+
+	return rc;
+}
+
+static int s5k6aafx_gpio_pull(int gpio_pin, int pull_mode)
+{
+	int rc = 0;
+	rc = gpio_request(gpio_pin, "s5k6aafx");
+	if (!rc)
+		gpio_direction_output(gpio_pin, pull_mode);
+	else
+		pr_err("GPIO(%d) request failed\n", gpio_pin);
+	gpio_free(gpio_pin);
+	return rc;
+}
+
+static int s5k6aafx_set_sensor_mode(int mode)
+{
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		pr_info("s5k6aafx:sensor set mode: preview\n");
+		op_mode = SENSOR_PREVIEW_MODE;
+
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL);
+
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_W_ADDL, 0x01F4);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, 0x0000); /* REG_TC_GP_EnableCapture */
+		/* REG_TC_GP_EnableCaptureChanged */
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, 0x0001);
+
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_W_ADDL, 0x0400);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, 0x007F);
+		s5k6aafx_set_wb(current_wb);
+
+		break;
+
+	case SENSOR_SNAPSHOT_MODE:
+		pr_info("s5k6aafx:sensor set mode: snapshot\n");
+		op_mode = SENSOR_SNAPSHOT_MODE;
+
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL);
+
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_W_ADDL, 0x01F4);
+		/* REG_TC_GP_EnableCapture */
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, 0x0001);
+		/* REG_TC_GP_EnableCaptureChanged */
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, 0x0001);
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s5k6aafx_set_effect(int effect)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (effect) {
+	case CAMERA_EFFECT_OFF:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EE, 0x0000);
+		break;
+	case CAMERA_EFFECT_MONO:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EE, 0x0001);
+		break;
+	case CAMERA_EFFECT_NEGATIVE:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EE, 0x0002);
+		break;
+	case CAMERA_EFFECT_SEPIA:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EE, 0x0003);
+		break;
+	case CAMERA_EFFECT_AQUA:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EE, 0x0004);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int s5k6aafx_set_antibanding(enum antibanding_mode antibanding_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (antibanding_value) {
+	case CAMERA_ANTI_BANDING_50HZ:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DC, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DE, 0x0001);
+		break;
+	case CAMERA_ANTI_BANDING_60HZ:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DC, 0x0002);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DE, 0x0001);
+		break;
+	case CAMERA_ANTI_BANDING_AUTO:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DC, 0x0002);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DE, 0x0001);
+		break;
+	}
+	return 0;
+}
+
+
+static int s5k6aafx_set_brightness(enum brightness_t brightness_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (brightness_value) {
+	case CAMERA_BRIGHTNESS_N4:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0xFF81);
+		break;
+	case CAMERA_BRIGHTNESS_N3:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0xFFA1);
+		break;
+	case CAMERA_BRIGHTNESS_N2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0xFFC1);
+		break;
+	case CAMERA_BRIGHTNESS_N1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0xFFE1);
+		break;
+	case CAMERA_BRIGHTNESS_D:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0x0000);
+		break;
+	case CAMERA_BRIGHTNESS_P1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0x001F);
+		break;
+	case CAMERA_BRIGHTNESS_P2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0x003F);
+		break;
+	case CAMERA_BRIGHTNESS_P3:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0x005F);
+		break;
+	case CAMERA_BRIGHTNESS_P4:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E4, 0x007F);
+		break;
+	default:
+		 break;
+	}
+	return 0;
+}
+
+static int s5k6aafx_set_wb(enum wb_mode wb_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (wb_value) {
+	case CAMERA_AWB_AUTO: /*auto*/
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0400, 0x007F);
+		break;
+	case CAMERA_AWB_CLOUDY: /*cloudy*/
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0400, 0x0077);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D0, 0x0147);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D2, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D4, 0x0100);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D6, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D8, 0x0138);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DA, 0x0001);
+		break;
+	case CAMERA_AWB_INDOOR_HOME: /*Fluorescent*/
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0400, 0x0077);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D0, 0x00D9);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D2, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D4, 0x0100);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D6, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D8, 0x0200);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DA, 0x0001);
+		break;
+	case CAMERA_AWB_INDOOR_OFFICE: /*Incandescent*/
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0400, 0x0077);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D0, 0x00D9);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D2, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D4, 0x0100);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D6, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D8, 0x0219);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DA, 0x0001);
+		break;
+	case CAMERA_AWB_SUNNY: /*outdoor*/
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0400, 0x0077);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D0, 0x0133);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D2, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D4, 0x0100);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D6, 0x0001);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03D8, 0x0119);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x03DA, 0x0001);
+		break;
+	default:
+		break;
+	}
+	current_wb = wb_value;
+	return 0;
+}
+
+
+static int s5k6aafx_set_sharpness(enum sharpness_mode sharpness_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (sharpness_value) {
+	case CAMERA_SHARPNESS_X0:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EA, 0xFF81);
+		break;
+	case CAMERA_SHARPNESS_X1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EA, 0xFFC1);
+		break;
+	case CAMERA_SHARPNESS_X2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EA, 0x0000);
+		break;
+	case CAMERA_SHARPNESS_X3:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EA, 0x003F);
+		break;
+	case CAMERA_SHARPNESS_X4:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01EA, 0x007F);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+
+static int s5k6aafx_set_saturation(enum saturation_mode saturation_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (saturation_value) {
+	case CAMERA_SATURATION_X0:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E8, 0xFF81);
+		break;
+	case CAMERA_SATURATION_X05:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E8, 0xFFC1);
+		break;
+	case CAMERA_SATURATION_X1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E8, 0x0000);
+		break;
+	case CAMERA_SATURATION_X15:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E8, 0x003F);
+		break;
+	case CAMERA_SATURATION_X2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E8, 0x007F);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int s5k6aafx_set_contrast(enum contrast_mode contrast_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (contrast_value) {
+	case CAMERA_CONTRAST_N2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E6, 0xFF81);
+		break;
+	case CAMERA_CONTRAST_N1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E6, 0xFFC1);
+		break;
+	case CAMERA_CONTRAST_D:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E6, 0x0000);
+		break;
+	case CAMERA_CONTRAST_P1:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E6, 0x003F);
+		break;
+	case CAMERA_CONTRAST_P2:
+		s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x01E6, 0x007F);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int s5k6aafx_set_front_camera_mode(enum frontcam_t frontcam_value)
+{
+	if (op_mode == SENSOR_SNAPSHOT_MODE || previous_mirror_mode == frontcam_value)
+		return 0;
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_ADDH_SW_REG_INT);
+
+	switch (frontcam_value) {
+	case CAMERA_MIRROR:
+		/*mirror and flip*/
+			s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x02D4, 0x0002);
+			s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x02D6, 0x0002);
+
+		break;
+	case CAMERA_REVERSE:
+		/*reverse mode*/
+			s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x02D4, 0x0003);
+			s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x02D6, 0x0003);
+
+		break;
+
+	default:
+		break;
+	}
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x021E, 0x0001);
+
+	previous_mirror_mode = frontcam_value;
+
+	return 0;
+}
+
+#if 0
+static int s5k6aafx_set_metering_mode(enum aec_metering_mode metering_value)
+{
+	uint16_t weight_table[32];
+	uint8_t i;
+
+	if (op_mode == SENSOR_SNAPSHOT_MODE)
+		return 0;
+
+	for (i = 0; i < 32; i++)
+		weight_table[i] = 0x0101;
+
+	if (metering_value == CAMERA_METERING_CENTERING) {
+		weight_table[9] = 0x0303;
+		weight_table[10] = 0x0303;
+		weight_table[13] = 0x0303; /* 0x0305 */
+		weight_table[14] = 0x0303; /* 0x0503 */
+		weight_table[17] = 0x0303; /* 0x0305 */
+		weight_table[18] = 0x0303; /* 0x0503 */
+		weight_table[21] = 0x0303;
+		weight_table[22] = 0x0303;
+	} else if (metering_value == CAMERA_METERING_SPOT) {
+		weight_table[13] = 0x0501;
+		weight_table[14] = 0x0105;
+		weight_table[17] = 0x0501;
+		weight_table[18] = 0x0105;
+	} else if (metering_value >= CAMERA_METERING_ZONE1 &&
+		metering_value <= CAMERA_METERING_ZONE16) {
+		i = metering_value - CAMERA_METERING_ZONE1;
+		i += (i & 0xFC); /* i=i+((int)(i/4))*4 */
+		weight_table[i] = 0x0505;
+		weight_table[i+4] = 0x0505;
+	}
+
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL);
+	s5k6aafx_i2c_write(s5k6aafx_client->addr,
+		S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT);
+	s5k6aafx_i2c_write(s5k6aafx_client->addr, S5K6AAFX_REG_W_ADDL, 0x100E);
+
+	for (i = 0; i < 32; i++) {
+		CDBG("write table[%d]=%x\n", i, weight_table[i]);
+		s5k6aafx_i2c_write(s5k6aafx_client->addr,
+			S5K6AAFX_REG_WR, weight_table[i]);
+	}
+
+	return 0;
+}
+#endif
+
+static int s5k6aafx_sensor_read_id(const struct msm_camera_sensor_info *data)
+{
+	uint16_t model_id;
+	int rc = 0;
+
+	pr_info("s5k6aafx_sensor_read_id\n");
+	/* Read the Model ID of the sensor */
+	rc = s5k6aafx_i2c_write(s5k6aafx_client->addr,
+	       S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL);
+	if (rc < 0)
+		goto init_probe_fail;
+	rc = s5k6aafx_i2c_write(s5k6aafx_client->addr,
+	       S5K6AAFX_REG_R_ADDH, S5K6AAFX_ADDH_SW_REG_INT);
+	if (rc < 0)
+		goto init_probe_fail;
+	rc = s5k6aafx_i2c_write(s5k6aafx_client->addr,
+	       S5K6AAFX_REG_R_ADDL, S5K6AAFX_REG_MODEL_ID);
+	if (rc < 0)
+		goto init_probe_fail;
+	rc = s5k6aafx_i2c_read(s5k6aafx_client->addr,
+		S5K6AAFX_REG_WR, &model_id);
+	if (rc < 0)
+		goto init_probe_fail;
+
+	pr_info("s5k6aafx: model_id = 0x%x\n", model_id);
+	/* Check if it matches it with the value in Datasheet */
+	if (model_id != S5K6AAFX_MODEL_ID) {
+		pr_info("invalid model id\n");
+		rc = -EINVAL;
+		goto init_probe_fail;
+	}
+
+init_probe_fail:
+	return rc;
+
+}
+
+int s5k6aafx_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+	int rc = 0;
+	s5k6aafx_ctrl = kzalloc(sizeof(struct s5k6aafx_ctrl), GFP_KERNEL);
+	if (!s5k6aafx_ctrl) {
+		pr_info("s5k6aafx_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+
+	if (data == NULL) {
+		pr_err("%s sensor data is NULL\n", __func__);
+		return -EINVAL;
+	}
+	s5k6aafx_ctrl->sensordata = data;
+
+
+	if (s5k6aafx_gpio_pull(data->sensor_pwd, 1) < 0)
+		goto init_fail;
+	mdelay(1);
+
+	/*switch PCLK and MCLK to 2nd cam*/
+	pr_info("s5k6aafx: s5k6aafx_sensor_probe switch clk\n");
+	if(data->camera_clk_switch != NULL)
+		data->camera_clk_switch();
+
+	/*MCLK enable*/
+	pr_info("s5k6aafx: MCLK enable clk\n");
+	msm_camio_probe_on(s5k6aafx_pdev);
+	mdelay(3);
+
+	if (s5k6aafx_gpio_pull(data->sensor_reset, 1) < 0)
+		goto init_fail;
+	mdelay(10);
+	msm_camio_camif_pad_reg_reset();
+	/*reset sensor*/
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.reset_init[0],
+		s5k6aafx_regs.reset_init_size);
+	if (rc < 0)
+		goto init_fail;
+	mdelay(100);
+
+	/*T&P setting*/
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.TP_init[0],
+		s5k6aafx_regs.TP_init_size);
+	if (rc < 0)
+		goto init_fail;
+
+	/*analog setting*/
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.analog_setting_init[0],
+		s5k6aafx_regs.analog_setting_init_size);
+	if (rc < 0)
+		goto init_fail;
+	mdelay(10);
+
+	/*set initial register*/
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.register_init[0],
+			s5k6aafx_regs.register_init_size);
+	if (rc < 0)
+		goto init_fail;
+
+	/*set clock*/
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.clk_init[0],
+			s5k6aafx_regs.clk_init_size);
+
+	if (rc < 0)
+		goto init_fail;
+	mdelay(100);
+
+	/* preview configuration */
+	rc = s5k6aafx_i2c_write_table(&s5k6aafx_regs.prev_snap_conf_init[0],
+			s5k6aafx_regs.prev_snap_conf_init_size);
+
+	if (rc < 0)
+		goto init_fail;
+
+	rc = s5k6aafx_sensor_read_id(data);
+	if (rc < 0)
+		goto init_fail;
+
+	previous_mirror_mode = -1;
+init_done:
+	return rc;
+
+init_fail:
+	kfree(s5k6aafx_ctrl);
+	return rc;
+}
+
+static int s5k6aafx_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&s5k6aafx_wait_queue);
+	return 0;
+}
+
+int s5k6aafx_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cfg_data;
+	long rc = 0;
+	if (copy_from_user(&cfg_data,
+			   (void *)argp, sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	switch (cfg_data.cfgtype) {
+	case CFG_SET_MODE:
+		rc = s5k6aafx_set_sensor_mode(cfg_data.mode);
+		break;
+	case CFG_SET_EFFECT:
+		rc = s5k6aafx_set_effect(cfg_data.cfg.effect);
+		break;
+	case CFG_SET_ANTIBANDING:
+		rc = s5k6aafx_set_antibanding
+				(cfg_data.cfg.antibanding_value);
+		break;
+	case CFG_SET_BRIGHTNESS:
+		rc = s5k6aafx_set_brightness
+				(cfg_data.cfg.brightness_value);
+		break;
+	case CFG_SET_WB:
+		rc = s5k6aafx_set_wb(cfg_data.cfg.wb_value);
+		break;
+	case CFG_SET_SHARPNESS:
+		rc = s5k6aafx_set_sharpness
+			(cfg_data.cfg.sharpness_value);
+		break;
+	case CFG_SET_SATURATION:
+		rc = s5k6aafx_set_saturation
+			(cfg_data.cfg.saturation_value);
+		break;
+	case CFG_SET_CONTRAST:
+		rc = s5k6aafx_set_contrast(cfg_data.cfg.contrast_value);
+		break;
+	case CFG_SET_FRONT_CAMERA_MODE:
+		rc = s5k6aafx_set_front_camera_mode(cfg_data.cfg.frontcam_value);
+		break;
+#if 0
+	case CFG_SET_EXPOSURE_MODE:
+		rc = s5k6aafx_set_metering_mode
+			(cfg_data.cfg.metering_value);
+		break;
+#endif
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+int s5k6aafx_sensor_release(void)
+{
+	int rc = 0;
+	down(&s5k6aafx_sem);
+	rc = s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x022e, 0x01);
+	rc = s5k6aafx_i2c_write(s5k6aafx_client->addr, 0x0230, 0x01);
+	mdelay(133);
+
+	if (s5k6aafx_ctrl)
+		s5k6aafx_gpio_pull(s5k6aafx_ctrl->sensordata->sensor_reset, 0);
+	mdelay(1);
+	msm_camio_probe_off(s5k6aafx_pdev);
+	mdelay(1);
+	if (s5k6aafx_ctrl)
+		s5k6aafx_gpio_pull(s5k6aafx_ctrl->sensordata->sensor_pwd, 0);
+
+	if (s5k6aafx_ctrl) {
+		kfree(s5k6aafx_ctrl);
+		s5k6aafx_ctrl = NULL;
+	}
+
+	up(&s5k6aafx_sem);
+
+	return rc;
+}
+
+static const char *S5K6AAFXVendor = "Samsung";
+static const char *S5K6AAFXNAME = "s5k6aafx";
+static const char *S5K6AAFXSize = "1M";
+static uint32_t htcwc_value;
+
+static ssize_t sensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "%s %s %s\n", S5K6AAFXVendor, S5K6AAFXNAME, S5K6AAFXSize);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static ssize_t htcwc_get(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", htcwc_value);
+	return length;
+}
+
+static ssize_t htcwc_set(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+
+	tmp = buf[0] - 0x30; /* only get the first char */
+
+#if 0
+	if (strcmp(current->comm,"com.android.camera")!=0){
+		pr_info("No permission : not camera ap\n");
+		return -EINVAL;
+	}
+#endif
+
+	htcwc_value = tmp;
+	//pr_info("current_comm = %s\n", current->comm);
+	pr_info("htcwc_value = %d\n", htcwc_value);
+	return count;
+}
+
+static ssize_t sensor_read_node(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", sensor_probe_node);
+	return length;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+static DEVICE_ATTR(htcwc, 0777, htcwc_get, htcwc_set);
+static DEVICE_ATTR(node, 0444, sensor_read_node, NULL);
+
+static struct kobject *android_s5k6aafx;
+
+static int s5k6aafx_sysfs_init(void)
+{
+	int ret ;
+	pr_info("s5k6aafx:kobject creat and add\n");
+	android_s5k6aafx = kobject_create_and_add("android_camera2", NULL);
+	if (android_s5k6aafx == NULL) {
+		pr_info("s5k6aafx_sysfs_init: subsystem_register " \
+		"failed\n");
+		ret = -ENOMEM;
+		return ret ;
+	}
+	pr_info("s5k6aafx:sysfs_create_file\n");
+	ret = sysfs_create_file(android_s5k6aafx, &dev_attr_sensor.attr);
+	if (ret) {
+		pr_info("s5k6aafx_sysfs_init: sysfs_create_file " \
+		"failed\n");
+		kobject_del(android_s5k6aafx);
+	}
+
+	ret = sysfs_create_file(android_s5k6aafx, &dev_attr_htcwc.attr);
+	if (ret) {
+		pr_info("s5k6aafx_sysfs_init: sysfs_create_file htcwc failed\n");
+		kobject_del(android_s5k6aafx);
+	}
+
+       ret = sysfs_create_file(android_s5k6aafx, &dev_attr_node.attr);
+	if (ret) {
+		pr_info("s5k6aafx_sysfs_init: dev_attr_node failed\n");
+		kobject_del(android_s5k6aafx);
+	}
+
+	return 0 ;
+}
+
+
+static int s5k6aafx_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int rc = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		rc = -ENOTSUPP;
+		goto probe_failure;
+	}
+
+	s5k6aafx_sensorw = kzalloc(sizeof(struct s5k6aafx_work), GFP_KERNEL);
+
+	if (!s5k6aafx_sensorw) {
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, s5k6aafx_sensorw);
+	s5k6aafx_init_client(client);
+	s5k6aafx_client = client;
+
+	pr_info("s5k6aafx_probe succeeded!\n");
+
+	return 0;
+
+probe_failure:
+	kfree(s5k6aafx_sensorw);
+	s5k6aafx_sensorw = NULL;
+	pr_info("s5k6aafx_probe failed!\n");
+	return rc;
+}
+
+static const struct i2c_device_id s5k6aafx_i2c_id[] = {
+	{"s5k6aafx", 0},
+	{},
+};
+
+static struct i2c_driver s5k6aafx_i2c_driver = {
+	.id_table = s5k6aafx_i2c_id,
+	.probe = s5k6aafx_i2c_probe,
+	.remove = __exit_p(s5k6aafx_i2c_remove),
+	.driver = {
+		   .name = "s5k6aafx",
+		   },
+};
+
+static int s5k6aafx_sensor_probe(struct msm_camera_sensor_info *info,
+				struct msm_sensor_ctrl *s)
+{
+	int rc = i2c_add_driver(&s5k6aafx_i2c_driver);
+	if (rc < 0 || s5k6aafx_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_done;
+	}
+
+	pr_info("s5k6aafx s->node %d\n", s->node);
+	sensor_probe_node = s->node;
+	/*2nd camera pwd*/
+	if (s5k6aafx_gpio_pull(info->sensor_pwd, 1) < 0)
+		goto probe_fail;
+	/*main camera pwd*/
+	if (s5k6aafx_gpio_pull(105, 0) < 0)
+		goto probe_fail;
+	mdelay(5);
+
+	/*switch clk source*/
+	pr_info("s5k6aafx: s5k6aafx_sensor_probe switch clk\n");
+	if(info->camera_clk_switch != NULL)
+		info->camera_clk_switch();
+
+	/*MCLK enable*/
+	pr_info("s5k6aafx: MCLK enable clk\n");
+	msm_camio_probe_on(s5k6aafx_pdev);
+	mdelay(10);
+
+	if (s5k6aafx_gpio_pull(info->sensor_reset, 1) < 0)
+		goto probe_fail;
+	mdelay(10);
+
+	rc = s5k6aafx_sensor_read_id(info);
+	if (rc < 0)
+		goto probe_fail;
+	if (info->camera_main_set_probe != NULL)
+		info->camera_main_set_probe(true);
+	s->s_init = s5k6aafx_sensor_open_init;
+	s->s_release = s5k6aafx_sensor_release;
+	s->s_config = s5k6aafx_sensor_config;
+
+	/*init done*/
+	msm_camio_probe_off(s5k6aafx_pdev);
+
+	s5k6aafx_gpio_pull(info->sensor_pwd, 0);
+	mdelay(5);
+
+	s5k6aafx_sysfs_init();
+
+	mdelay(5);
+
+probe_done:
+	pr_info("%s %s:%d\n", __FILE__, __func__, __LINE__);
+	return rc;
+probe_fail:
+	msm_camio_probe_off(s5k6aafx_pdev);
+	pr_err("S5K6AAFX probe failed\n");
+	return rc;
+
+}
+
+static int __s5k6aafx_probe(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+
+	s5k6aafx_pdev = pdev;
+	if (sdata->camera_main_get_probe != NULL) {
+		if (sdata->camera_main_get_probe()) {
+			pr_info("__s5k6aafx_probe camera main get probed already.\n");
+			return 0;
+		}
+	}
+	/*init reset /1 pwd/2pwd*/
+	s5k6aafx_gpio_pull(sdata->sensor_pwd, 0);
+	s5k6aafx_gpio_pull(105, 1);
+	mdelay(10);
+	s5k6aafx_gpio_pull(sdata->sensor_reset, 0);
+	return msm_camera_drv_start(pdev, s5k6aafx_sensor_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __s5k6aafx_probe,
+	.driver = {
+		   .name = "msm_camera_s5k6aafx",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init s5k6aafx_init(void)
+{
+
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(s5k6aafx_init);
diff --git a/drivers/media/video/msm/s5k6aafx.h b/drivers/media/video/msm/s5k6aafx.h
new file mode 100644
index 0000000..43d20b1
--- /dev/null
+++ b/drivers/media/video/msm/s5k6aafx.h
@@ -0,0 +1,80 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef S5K6AAFX_H
+#define S5K6AAFX_H
+
+#include <linux/types.h>
+#include <mach/camera.h>
+
+/* S5K6AAFX Registers and their values */
+/* Sensor Core Registers */
+#define S5K6AAFX_REG_I2C_MODE 0xFCFC
+#define  S5K6AAFX_I2C_MODE_SENSOR 0x0000
+#define  S5K6AAFX_I2C_MODE_GENERAL 0xD000
+
+#define  S5K6AAFX_REG_MODEL_ID 0x0152
+#define  S5K6AAFX_MODEL_ID 0x06AA
+
+/* Mode select register */
+#define S5K6AAFX_REG_MODE_SELECT 0x107E
+#define S5K6AAFX_MODE_SELECT_STREAM 0x0000
+#define S5K6AAFX_MODE_SELECT_SW_STANDBY 0x0001
+
+#define S5K6AAFX_ADDH_SW_REG_INT 0x7000
+#define S5K6AAFX_REG_W_ADDH 0x0028
+#define S5K6AAFX_REG_W_ADDL 0x002A
+#define S5K6AAFX_REG_R_ADDH 0x002C
+#define S5K6AAFX_REG_R_ADDL 0x002E
+#define S5K6AAFX_REG_WR 0x0F12
+
+#define S5K6AAFX_QTR_SIZE_WIDTH 0x0280
+#define S5K6AAFX_QTR_SIZE_HEIGHT 0x01E0
+#define S5K6AAFX_FULL_SIZE_WIDTH 0x0500
+#define S5K6AAFX_FULL_SIZE_HEIGHT 0x0400
+#define S5K6AAFX_ADJ_FULL_SIZE_WIDTH S5K6AAFX_QTR_SIZE_WIDTH*2
+#define S5K6AAFX_ADJ_FULL_SIZE_HEIGHT S5K6AAFX_QTR_SIZE_HEIGHT*2
+
+extern struct s5k6aafx_reg s5k6aafx_regs;
+
+struct s5k6aafx_i2c_reg_conf {
+	unsigned short waddr;
+	unsigned short wdata;
+};
+
+struct s5k6aafx_reg {
+	const struct s5k6aafx_i2c_reg_conf *reset_init;
+	uint16_t reset_init_size;
+        const struct s5k6aafx_i2c_reg_conf *TP_init;
+        uint16_t TP_init_size;
+        const struct s5k6aafx_i2c_reg_conf *analog_setting_init;
+        uint16_t analog_setting_init_size;
+	const struct s5k6aafx_i2c_reg_conf *register_init;
+	uint16_t register_init_size;
+	const struct s5k6aafx_i2c_reg_conf *clk_init;
+	uint16_t clk_init_size;
+	const struct s5k6aafx_i2c_reg_conf *prev_snap_conf_init;
+	uint16_t prev_snap_conf_init_size;
+	/* for full-size preview */
+	const struct s5k6aafx_i2c_reg_conf *clk_init_tb2;
+	uint16_t clk_init_tb2_size;
+	const struct s5k6aafx_i2c_reg_conf *prev_snap_conf_init_tb2;
+	uint16_t prev_snap_conf_init_tb2_size;
+};
+
+#endif /* S5K6AAFX_H */
diff --git a/drivers/media/video/msm/s5k6aafx_reg_mecha.c b/drivers/media/video/msm/s5k6aafx_reg_mecha.c
new file mode 100644
index 0000000..fc54aa2
--- /dev/null
+++ b/drivers/media/video/msm/s5k6aafx_reg_mecha.c
@@ -0,0 +1,2647 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "s5k6aafx.h"
+
+static const struct s5k6aafx_i2c_reg_conf const reset_init_tbl[] = {
+	/* change to general mode */
+	{S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL},
+	{0x0010, 0x0001}, /* Reset */
+	{0x1030, 0x0000}, /* Clear host interrupt so main will wait */
+	{0x0014, 0x0001}, /* ARM go */
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const TP_init_tbl[] = {
+
+	/* Start T&P part */
+	/* DO NOT DELETE T&P SECTION COMMENTS! They are required to debug T&P related issues. */
+	/* svn://transrdsrv/svn/svnroot/System/Software/tcevb/SDK+FW/ISP_Oscar/Firmware */
+	/* Rev: 33110-33110 */
+	/* Signature: */
+	/* md5 f0ba942df15b96de5c09e6cf13fed9c9 .btp */
+	/* md5 8bc59f72129cb36e6f6db4be5ddca1f6 .htp */
+	/* md5 954ec97efcabad291d89f63e29f32490 .RegsMap.h */
+	/* md5 5c29fe50b51e7e860313f5b3b6452bfd .RegsMap.bin */
+	/* md5 6211407baaa234b753431cde4ba32402 .base.RegsMap.h */
+	/* md5 90cc21d42cc5f02eb80b2586e5c46d9b .base.RegsMap.bin */
+
+	{S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT},
+	{S5K6AAFX_REG_W_ADDL, 0x1D60},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4936},
+	{S5K6AAFX_REG_WR, 0x4836},
+	{S5K6AAFX_REG_WR, 0x2205},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA4E},
+	{S5K6AAFX_REG_WR, 0x4935},
+	{S5K6AAFX_REG_WR, 0x2002},
+	{S5K6AAFX_REG_WR, 0x83C8},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x3120},
+	{S5K6AAFX_REG_WR, 0x8088},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x8008},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2204},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA3E},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2206},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA39},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2207},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA34},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2208},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2F},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x2209},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2A},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x220A},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA25},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x220B},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA20},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x6108},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x39FF},
+	{S5K6AAFX_REG_WR, 0x3901},
+	{S5K6AAFX_REG_WR, 0x6748},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x32C0},
+	{S5K6AAFX_REG_WR, 0x6390},
+	{S5K6AAFX_REG_WR, 0x482E},
+	{S5K6AAFX_REG_WR, 0x6708},
+	{S5K6AAFX_REG_WR, 0x491A},
+	{S5K6AAFX_REG_WR, 0x482D},
+	{S5K6AAFX_REG_WR, 0x3108},
+	{S5K6AAFX_REG_WR, 0x60C1},
+	{S5K6AAFX_REG_WR, 0x6882},
+	{S5K6AAFX_REG_WR, 0x1A51},
+	{S5K6AAFX_REG_WR, 0x8201},
+	{S5K6AAFX_REG_WR, 0x4C2B},
+	{S5K6AAFX_REG_WR, 0x2607},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0736},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA05},
+	{S5K6AAFX_REG_WR, 0x4829},
+	{S5K6AAFX_REG_WR, 0x22D8},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA09},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0x68A1},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x4825},
+	{S5K6AAFX_REG_WR, 0x2224},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA00},
+	{S5K6AAFX_REG_WR, 0x4822},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0x60A0},
+	{S5K6AAFX_REG_WR, 0x4D22},
+	{S5K6AAFX_REG_WR, 0x6D29},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x481F},
+	{S5K6AAFX_REG_WR, 0x228F},
+	{S5K6AAFX_REG_WR, 0x00D2},
+	{S5K6AAFX_REG_WR, 0x30D8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9F2},
+	{S5K6AAFX_REG_WR, 0x652C},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0x218B},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x127B},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0398},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F0D},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x890D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1F2F},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1FE1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2043},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2003},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20CD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20EF},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2123},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0100},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EC1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EAD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F79},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x04AC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0704},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B9},
+	{S5K6AAFX_REG_WR, 0x48C3},
+	{S5K6AAFX_REG_WR, 0x49C3},
+	{S5K6AAFX_REG_WR, 0x8800},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4DC0},
+	{S5K6AAFX_REG_WR, 0x68AC},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B3},
+	{S5K6AAFX_REG_WR, 0x68A9},
+	{S5K6AAFX_REG_WR, 0x4ABC},
+	{S5K6AAFX_REG_WR, 0x42A1},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x4BBD},
+	{S5K6AAFX_REG_WR, 0x8A1B},
+	{S5K6AAFX_REG_WR, 0x3301},
+	{S5K6AAFX_REG_WR, 0x8013},
+	{S5K6AAFX_REG_WR, 0x8813},
+	{S5K6AAFX_REG_WR, 0x1C14},
+	{S5K6AAFX_REG_WR, 0x2B00},
+	{S5K6AAFX_REG_WR, 0xD00F},
+	{S5K6AAFX_REG_WR, 0x2201},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C2F},
+	{S5K6AAFX_REG_WR, 0x42B9},
+	{S5K6AAFX_REG_WR, 0xD300},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x60AE},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C28},
+	{S5K6AAFX_REG_WR, 0x42B0},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0x1E59},
+	{S5K6AAFX_REG_WR, 0x8021},
+	{S5K6AAFX_REG_WR, 0xBCF8},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x48AF},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF997},
+	{S5K6AAFX_REG_WR, 0x4AAD},
+	{S5K6AAFX_REG_WR, 0x4BAE},
+	{S5K6AAFX_REG_WR, 0x8811},
+	{S5K6AAFX_REG_WR, 0x885B},
+	{S5K6AAFX_REG_WR, 0x8852},
+	{S5K6AAFX_REG_WR, 0x4359},
+	{S5K6AAFX_REG_WR, 0x1889},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7C5},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98F},
+	{S5K6AAFX_REG_WR, 0x49A5},
+	{S5K6AAFX_REG_WR, 0x8989},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x0349},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98E},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x489F},
+	{S5K6AAFX_REG_WR, 0x8F80},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF991},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x43C0},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF994},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF998},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x4898},
+	{S5K6AAFX_REG_WR, 0x8840},
+	{S5K6AAFX_REG_WR, 0x4360},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x6028},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F1},
+	{S5K6AAFX_REG_WR, 0xB082},
+	{S5K6AAFX_REG_WR, 0x4D96},
+	{S5K6AAFX_REG_WR, 0x4E91},
+	{S5K6AAFX_REG_WR, 0x88A8},
+	{S5K6AAFX_REG_WR, 0x1C2C},
+	{S5K6AAFX_REG_WR, 0x3420},
+	{S5K6AAFX_REG_WR, 0x4F90},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD018},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF988},
+	{S5K6AAFX_REG_WR, 0x9001},
+	{S5K6AAFX_REG_WR, 0x9802},
+	{S5K6AAFX_REG_WR, 0x6B39},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF978},
+	{S5K6AAFX_REG_WR, 0x9901},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF95F},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF96A},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x21FF},
+	{S5K6AAFX_REG_WR, 0x3101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x88E8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD00A},
+	{S5K6AAFX_REG_WR, 0x4980},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x3128},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF979},
+	{S5K6AAFX_REG_WR, 0x8D38},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8538},
+	{S5K6AAFX_REG_WR, 0xBCFE},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0409},
+	{S5K6AAFX_REG_WR, 0x0C09},
+	{S5K6AAFX_REG_WR, 0x1A40},
+	{S5K6AAFX_REG_WR, 0x4976},
+	{S5K6AAFX_REG_WR, 0x6849},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF971},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE75B},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x6801},
+	{S5K6AAFX_REG_WR, 0x040D},
+	{S5K6AAFX_REG_WR, 0x0C2D},
+	{S5K6AAFX_REG_WR, 0x6844},
+	{S5K6AAFX_REG_WR, 0x486F},
+	{S5K6AAFX_REG_WR, 0x8981},
+	{S5K6AAFX_REG_WR, 0x1C28},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF927},
+	{S5K6AAFX_REG_WR, 0x8060},
+	{S5K6AAFX_REG_WR, 0x4970},
+	{S5K6AAFX_REG_WR, 0x69C9},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF968},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x80A0},
+	{S5K6AAFX_REG_WR, 0x0228},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF92D},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x496B},
+	{S5K6AAFX_REG_WR, 0x2300},
+	{S5K6AAFX_REG_WR, 0x5EC9},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xDA02},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x3001},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE797},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x4867},
+	{S5K6AAFX_REG_WR, 0x4E65},
+	{S5K6AAFX_REG_WR, 0x7800},
+	{S5K6AAFX_REG_WR, 0x6AB7},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x6A37},
+	{S5K6AAFX_REG_WR, 0x495D},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0x688D},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x684D},
+	{S5K6AAFX_REG_WR, 0x4859},
+	{S5K6AAFX_REG_WR, 0x8841},
+	{S5K6AAFX_REG_WR, 0x6820},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF94B},
+	{S5K6AAFX_REG_WR, 0x8DF1},
+	{S5K6AAFX_REG_WR, 0x434F},
+	{S5K6AAFX_REG_WR, 0x0A3A},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD30C},
+	{S5K6AAFX_REG_WR, 0x4D5C},
+	{S5K6AAFX_REG_WR, 0x26FF},
+	{S5K6AAFX_REG_WR, 0x8829},
+	{S5K6AAFX_REG_WR, 0x3601},
+	{S5K6AAFX_REG_WR, 0x43B1},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF944},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0x8828},
+	{S5K6AAFX_REG_WR, 0x4330},
+	{S5K6AAFX_REG_WR, 0x8028},
+	{S5K6AAFX_REG_WR, 0xE73B},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x436A},
+	{S5K6AAFX_REG_WR, 0x0A12},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD304},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F3},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0xB410},
+	{S5K6AAFX_REG_WR, 0x4848},
+	{S5K6AAFX_REG_WR, 0x4950},
+	{S5K6AAFX_REG_WR, 0x89C0},
+	{S5K6AAFX_REG_WR, 0x2316},
+	{S5K6AAFX_REG_WR, 0x5ECC},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x42A0},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C22},
+	{S5K6AAFX_REG_WR, 0x82CA},
+	{S5K6AAFX_REG_WR, 0x2318},
+	{S5K6AAFX_REG_WR, 0x5ECA},
+	{S5K6AAFX_REG_WR, 0x4290},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C10},
+	{S5K6AAFX_REG_WR, 0x8308},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4C45},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02AD},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF91E},
+	{S5K6AAFX_REG_WR, 0x6030},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFE0},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE741},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4C3D},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02ED},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF916},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD1},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE732},
+	{S5K6AAFX_REG_WR, 0x230D},
+	{S5K6AAFX_REG_WR, 0x071B},
+	{S5K6AAFX_REG_WR, 0x18C3},
+	{S5K6AAFX_REG_WR, 0x8818},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD001},
+	{S5K6AAFX_REG_WR, 0x4308},
+	{S5K6AAFX_REG_WR, 0xE000},
+	{S5K6AAFX_REG_WR, 0x4388},
+	{S5K6AAFX_REG_WR, 0x8018},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x2402},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x8809},
+	{S5K6AAFX_REG_WR, 0x078A},
+	{S5K6AAFX_REG_WR, 0xD500},
+	{S5K6AAFX_REG_WR, 0x2406},
+	{S5K6AAFX_REG_WR, 0x2900},
+	{S5K6AAFX_REG_WR, 0xD01F},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x207D},
+	{S5K6AAFX_REG_WR, 0x00C0},
+	{S5K6AAFX_REG_WR, 0x2600},
+	{S5K6AAFX_REG_WR, 0x4D2D},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD019},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x8229},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F9},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x482A},
+	{S5K6AAFX_REG_WR, 0x0309},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFDB},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x4304},
+	{S5K6AAFX_REG_WR, 0x1C21},
+	{S5K6AAFX_REG_WR, 0x4C26},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x3C14},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD2},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2121},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFCD},
+	{S5K6AAFX_REG_WR, 0x802E},
+	{S5K6AAFX_REG_WR, 0xE6FD},
+	{S5K6AAFX_REG_WR, 0x822E},
+	{S5K6AAFX_REG_WR, 0x0789},
+	{S5K6AAFX_REG_WR, 0x0FC9},
+	{S5K6AAFX_REG_WR, 0x0089},
+	{S5K6AAFX_REG_WR, 0x223B},
+	{S5K6AAFX_REG_WR, 0x4311},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8DA},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x491B},
+	{S5K6AAFX_REG_WR, 0x8FC8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD007},
+	{S5K6AAFX_REG_WR, 0x2000},
+	{S5K6AAFX_REG_WR, 0x87C8},
+	{S5K6AAFX_REG_WR, 0x8F88},
+	{S5K6AAFX_REG_WR, 0x4C19},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD002},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE689},
+	{S5K6AAFX_REG_WR, 0x4815},
+	{S5K6AAFX_REG_WR, 0x3060},
+	{S5K6AAFX_REG_WR, 0x8900},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD103},
+	{S5K6AAFX_REG_WR, 0x4814},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8CA},
+	{S5K6AAFX_REG_WR, 0x2010},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x14D8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x235C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xF4B0},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1554},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1AB8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0080},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x046C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0468},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1100},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0x198C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0AC4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB0A0},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0xB0B4},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x044E},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0450},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9CE7},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9FB8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x14C1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27E1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x88DF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x275D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ED3},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0xA144},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1F87},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ECB},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x26F9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x4027},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9F03},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9D9C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x85D9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0500},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* End T&P part */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const analog_setting_init_tbl[] = {
+	/* Start tuning part */
+
+	/* Analog Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x1102},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1108},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	{0xF40C, 0x0060},
+
+	{S5K6AAFX_REG_W_ADDL, 0x11B6},
+	{S5K6AAFX_REG_WR, 0x0020},
+	{S5K6AAFX_REG_WR, 0x0010},
+	{S5K6AAFX_REG_WR, 0x0008},
+	{S5K6AAFX_REG_WR, 0x0004},
+
+	{S5K6AAFX_REG_W_ADDL, 0x119C},
+	{S5K6AAFX_REG_WR, 0x0040},
+
+	{S5K6AAFX_REG_W_ADDL, 0x07B6},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0003},
+	{S5K6AAFX_REG_WR, 0x0006},
+	{S5K6AAFX_REG_WR, 0x000C},
+	{S5K6AAFX_REG_WR, 0x0018},
+
+	{0x1000, 0x0001}, /* Set host interrupt so main start run */
+
+	/* delay 10ms */
+
+};
+
+static const struct s5k6aafx_i2c_reg_conf const register_init_tbl[] = {
+// Start user init script
+
+// End user init script
+
+	/* param_start - TVAR_ash_GASAlpha */
+	/* parawrite _start - TVAR_ash_GASAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x0712},
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[0] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[1] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[2] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_GASAlpha[3] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[4] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[5] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[6] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[7] */
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_GASAlpha[8] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[9] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[10] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[11] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_GASAlpha[12] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[13] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[14] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[15] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[16] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[17] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[18] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[19] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[20] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[21] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[22] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[23] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[24] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[25] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[26] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[27] */
+	/* parawrite _end - TVAR_ash_GASAlpha */
+
+	/* parawrite _start - TVAR_ash_GASOutdoorAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x074A},
+	{S5K6AAFX_REG_WR, 0x00FB},	//TVAR_ash_GASOutdoorAlpha[0]
+	{S5K6AAFX_REG_WR, 0x00FF},	//TVAR_ash_GASOutdoorAlpha[1]
+	{S5K6AAFX_REG_WR, 0x00F9},	//TVAR_ash_GASOutdoorAlpha[2]
+	{S5K6AAFX_REG_WR, 0x0104},	//TVAR_ash_GASOutdoorAlpha[3]
+	/* parawrite _end - TVAR_ash_GASOutdoorAlpha */
+
+	{S5K6AAFX_REG_W_ADDL, 0x075A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* ash_bParabolicEstiwrite ation */
+	{S5K6AAFX_REG_WR, 0x0282}, /* ash_uParabolicCenterX */
+	{S5K6AAFX_REG_WR, 0x0216}, /* ash_uParabolicCenterY */
+	{S5K6AAFX_REG_WR, 0x000B}, /* ash_uParabolicScalingA */
+	{S5K6AAFX_REG_WR, 0x000E}, /* ash_uParabolicScalingB */
+
+	/* parawrite _start - TVAR_ash_pGAS */
+	{S5K6AAFX_REG_W_ADDL, 0x247C},
+	{S5K6AAFX_REG_WR, 0x02B2}, /* TVAR_ash_pGAS[0] */
+	{S5K6AAFX_REG_WR, 0x01C3}, /* TVAR_ash_pGAS[1] */
+	{S5K6AAFX_REG_WR, 0x0138}, /* TVAR_ash_pGAS[2] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_pGAS[3] */
+	{S5K6AAFX_REG_WR, 0x00E5}, /* TVAR_ash_pGAS[4] */
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[5] */
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[6] */
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[7] */
+	{S5K6AAFX_REG_WR, 0x00DA}, /* TVAR_ash_pGAS[8] */
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[9] */
+	{S5K6AAFX_REG_WR, 0x0110}, /* TVAR_ash_pGAS[10] */
+	{S5K6AAFX_REG_WR, 0x0179}, /* TVAR_ash_pGAS[11] */
+	{S5K6AAFX_REG_WR, 0x0232}, /* TVAR_ash_pGAS[12] */
+	{S5K6AAFX_REG_WR, 0x01EC}, /* TVAR_ash_pGAS[13] */
+	{S5K6AAFX_REG_WR, 0x0148}, /* TVAR_ash_pGAS[14] */
+	{S5K6AAFX_REG_WR, 0x00F3}, /* TVAR_ash_pGAS[15] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[16] */
+	{S5K6AAFX_REG_WR, 0x00A3}, /* TVAR_ash_pGAS[17] */
+	{S5K6AAFX_REG_WR, 0x0089}, /* TVAR_ash_pGAS[18] */
+	{S5K6AAFX_REG_WR, 0x007A}, /* TVAR_ash_pGAS[19] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[20] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[21] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[22] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[23] */
+	{S5K6AAFX_REG_WR, 0x010A}, /* TVAR_ash_pGAS[24] */
+	{S5K6AAFX_REG_WR, 0x0181}, /* TVAR_ash_pGAS[25] */
+	{S5K6AAFX_REG_WR, 0x015D}, /* TVAR_ash_pGAS[26] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[27] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[28] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[29] */
+	{S5K6AAFX_REG_WR, 0x0058}, /* TVAR_ash_pGAS[30] */
+	{S5K6AAFX_REG_WR, 0x003F}, /* TVAR_ash_pGAS[31] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[32] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[33] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[34] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[35] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[36] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[37] */
+	{S5K6AAFX_REG_WR, 0x010A}, /* TVAR_ash_pGAS[38] */
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[39] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[40] */
+	{S5K6AAFX_REG_WR, 0x008A}, /* TVAR_ash_pGAS[41] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[42] */
+	{S5K6AAFX_REG_WR, 0x0030}, /* TVAR_ash_pGAS[43] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[44] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[45] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[46] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[47] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[48] */
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[49] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[50] */
+	{S5K6AAFX_REG_WR, 0x00D2}, /* TVAR_ash_pGAS[51] */
+	{S5K6AAFX_REG_WR, 0x00FA}, /* TVAR_ash_pGAS[52] */
+	{S5K6AAFX_REG_WR, 0x00B7}, /* TVAR_ash_pGAS[53] */
+	{S5K6AAFX_REG_WR, 0x0073}, /* TVAR_ash_pGAS[54] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[55] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[56] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[57] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[58] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[59] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[60] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[61] */
+	{S5K6AAFX_REG_WR, 0x0045}, /* TVAR_ash_pGAS[62] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[63] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[64] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[65] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[66] */
+	{S5K6AAFX_REG_WR, 0x006B}, /* TVAR_ash_pGAS[67] */
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[68] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[69] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[70] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[71] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[72] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[73] */
+	{S5K6AAFX_REG_WR, 0x0018}, /* TVAR_ash_pGAS[74] */
+	{S5K6AAFX_REG_WR, 0x003F}, /* TVAR_ash_pGAS[75] */
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[76] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[77] */
+	{S5K6AAFX_REG_WR, 0x00FD}, /* TVAR_ash_pGAS[78] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[79] */
+	{S5K6AAFX_REG_WR, 0x0075}, /* TVAR_ash_pGAS[80] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[81] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[82] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[83] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[84] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[85] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[86] */
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[87] */
+	{S5K6AAFX_REG_WR, 0x004C}, /* TVAR_ash_pGAS[88] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[89] */
+	{S5K6AAFX_REG_WR, 0x00CB}, /* TVAR_ash_pGAS[90] */
+	{S5K6AAFX_REG_WR, 0x0121}, /* TVAR_ash_pGAS[91] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[92] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[93] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[94] */
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[95] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[96] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[97] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[98] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[99] */
+	{S5K6AAFX_REG_WR, 0x003B}, /* TVAR_ash_pGAS[100] */
+	{S5K6AAFX_REG_WR, 0x006D}, /* TVAR_ash_pGAS[101] */
+	{S5K6AAFX_REG_WR, 0x00AE}, /* TVAR_ash_pGAS[102] */
+	{S5K6AAFX_REG_WR, 0x00F0}, /* TVAR_ash_pGAS[103] */
+	{S5K6AAFX_REG_WR, 0x0163}, /* TVAR_ash_pGAS[104] */
+	{S5K6AAFX_REG_WR, 0x0107}, /* TVAR_ash_pGAS[105] */
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[106] */
+	{S5K6AAFX_REG_WR, 0x0085}, /* TVAR_ash_pGAS[107] */
+	{S5K6AAFX_REG_WR, 0x0053}, /* TVAR_ash_pGAS[108] */
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[109] */
+	{S5K6AAFX_REG_WR, 0x0029}, /* TVAR_ash_pGAS[110] */
+	{S5K6AAFX_REG_WR, 0x002F}, /* TVAR_ash_pGAS[111] */
+	{S5K6AAFX_REG_WR, 0x0042}, /* TVAR_ash_pGAS[112] */
+	{S5K6AAFX_REG_WR, 0x0066}, /* TVAR_ash_pGAS[113] */
+	{S5K6AAFX_REG_WR, 0x009E}, /* TVAR_ash_pGAS[114] */
+	{S5K6AAFX_REG_WR, 0x00DC}, /* TVAR_ash_pGAS[115] */
+	{S5K6AAFX_REG_WR, 0x012D}, /* TVAR_ash_pGAS[116] */
+	{S5K6AAFX_REG_WR, 0x01E1}, /* TVAR_ash_pGAS[117] */
+	{S5K6AAFX_REG_WR, 0x014C}, /* TVAR_ash_pGAS[118] */
+	{S5K6AAFX_REG_WR, 0x0102}, /* TVAR_ash_pGAS[119] */
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[120] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[121] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[122] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[123] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[124] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[125] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[126] */
+	{S5K6AAFX_REG_WR, 0x00D7}, /* TVAR_ash_pGAS[127] */
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[128] */
+	{S5K6AAFX_REG_WR, 0x0196}, /* TVAR_ash_pGAS[129] */
+	{S5K6AAFX_REG_WR, 0x029C}, /* TVAR_ash_pGAS[130] */
+	{S5K6AAFX_REG_WR, 0x01C0}, /* TVAR_ash_pGAS[131] */
+	{S5K6AAFX_REG_WR, 0x0144}, /* TVAR_ash_pGAS[132] */
+	{S5K6AAFX_REG_WR, 0x0108}, /* TVAR_ash_pGAS[133] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[134] */
+	{S5K6AAFX_REG_WR, 0x00BB}, /* TVAR_ash_pGAS[135] */
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[136] */
+	{S5K6AAFX_REG_WR, 0x00AC}, /* TVAR_ash_pGAS[137] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[138] */
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[139] */
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[140] */
+	{S5K6AAFX_REG_WR, 0x017B}, /* TVAR_ash_pGAS[141] */
+	{S5K6AAFX_REG_WR, 0x0222}, /* TVAR_ash_pGAS[142] */
+	{S5K6AAFX_REG_WR, 0x0281}, /* TVAR_ash_pGAS[143] */
+	{S5K6AAFX_REG_WR, 0x019C}, /* TVAR_ash_pGAS[144] */
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[145] */
+	{S5K6AAFX_REG_WR, 0x00E7}, /* TVAR_ash_pGAS[146] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[147] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[148] */
+	{S5K6AAFX_REG_WR, 0x00B3}, /* TVAR_ash_pGAS[149] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[150] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[151] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[152] */
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[153] */
+	{S5K6AAFX_REG_WR, 0x0139}, /* TVAR_ash_pGAS[154] */
+	{S5K6AAFX_REG_WR, 0x01E4}, /* TVAR_ash_pGAS[155] */
+	{S5K6AAFX_REG_WR, 0x01B4}, /* TVAR_ash_pGAS[156] */
+	{S5K6AAFX_REG_WR, 0x011D}, /* TVAR_ash_pGAS[157] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_pGAS[158] */
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[159] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[160] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[161] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[162] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[163] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[164] */
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[165] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[166] */
+	{S5K6AAFX_REG_WR, 0x00D6}, /* TVAR_ash_pGAS[167] */
+	{S5K6AAFX_REG_WR, 0x0142}, /* TVAR_ash_pGAS[168] */
+	{S5K6AAFX_REG_WR, 0x013A}, /* TVAR_ash_pGAS[169] */
+	{S5K6AAFX_REG_WR, 0x00D3}, /* TVAR_ash_pGAS[170] */
+	{S5K6AAFX_REG_WR, 0x00AA}, /* TVAR_ash_pGAS[171] */
+	{S5K6AAFX_REG_WR, 0x007C}, /* TVAR_ash_pGAS[172] */
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[173] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[174] */
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[175] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[176] */
+	{S5K6AAFX_REG_WR, 0x0044}, /* TVAR_ash_pGAS[177] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[178] */
+	{S5K6AAFX_REG_WR, 0x007A}, /* TVAR_ash_pGAS[179] */
+	{S5K6AAFX_REG_WR, 0x009E}, /* TVAR_ash_pGAS[180] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[181] */
+	{S5K6AAFX_REG_WR, 0x00F9}, /* TVAR_ash_pGAS[182] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[183] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[184] */
+	{S5K6AAFX_REG_WR, 0x0052}, /* TVAR_ash_pGAS[185] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[186] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[187] */
+	{S5K6AAFX_REG_WR, 0x0013}, /* TVAR_ash_pGAS[188] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[189] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[190] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[191] */
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[192] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[193] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[194] */
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[195] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[196] */
+	{S5K6AAFX_REG_WR, 0x006C}, /* TVAR_ash_pGAS[197] */
+	{S5K6AAFX_REG_WR, 0x0039}, /* TVAR_ash_pGAS[198] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[199] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[200] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[201] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[202] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[203] */
+	{S5K6AAFX_REG_WR, 0x0018}, /* TVAR_ash_pGAS[204] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[205] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[206] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[207] */
+	{S5K6AAFX_REG_WR, 0x00DA}, /* TVAR_ash_pGAS[208] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[209] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[210] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[211] */
+	{S5K6AAFX_REG_WR, 0x0015}, /* TVAR_ash_pGAS[212] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[213] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[214] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[215] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[216] */
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[217] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[218] */
+	{S5K6AAFX_REG_WR, 0x006D}, /* TVAR_ash_pGAS[219] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[220] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[221] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[222] */
+	{S5K6AAFX_REG_WR, 0x006B}, /* TVAR_ash_pGAS[223] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[224] */
+	{S5K6AAFX_REG_WR, 0x0019}, /* TVAR_ash_pGAS[225] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[226] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[227] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[228] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[229] */
+	{S5K6AAFX_REG_WR, 0x001D}, /* TVAR_ash_pGAS[230] */
+	{S5K6AAFX_REG_WR, 0x0043}, /* TVAR_ash_pGAS[231] */
+	{S5K6AAFX_REG_WR, 0x0075}, /* TVAR_ash_pGAS[232] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[233] */
+	{S5K6AAFX_REG_WR, 0x00FA}, /* TVAR_ash_pGAS[234] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[235] */
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[236] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[237] */
+	{S5K6AAFX_REG_WR, 0x0028}, /* TVAR_ash_pGAS[238] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[239] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[240] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[241] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[242] */
+	{S5K6AAFX_REG_WR, 0x0033}, /* TVAR_ash_pGAS[243] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[244] */
+	{S5K6AAFX_REG_WR, 0x008F}, /* TVAR_ash_pGAS[245] */
+	{S5K6AAFX_REG_WR, 0x00C2}, /* TVAR_ash_pGAS[246] */
+	{S5K6AAFX_REG_WR, 0x0132}, /* TVAR_ash_pGAS[247] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[248] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[249] */
+	{S5K6AAFX_REG_WR, 0x0077}, /* TVAR_ash_pGAS[250] */
+	{S5K6AAFX_REG_WR, 0x004A}, /* TVAR_ash_pGAS[251] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[252] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[253] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[254] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[255] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[256] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[257] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[258] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[259] */
+	{S5K6AAFX_REG_WR, 0x019B}, /* TVAR_ash_pGAS[260] */
+	{S5K6AAFX_REG_WR, 0x0117}, /* TVAR_ash_pGAS[261] */
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[262] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[263] */
+	{S5K6AAFX_REG_WR, 0x0085}, /* TVAR_ash_pGAS[264] */
+	{S5K6AAFX_REG_WR, 0x0067}, /* TVAR_ash_pGAS[265] */
+	{S5K6AAFX_REG_WR, 0x0059}, /* TVAR_ash_pGAS[266] */
+	{S5K6AAFX_REG_WR, 0x005C}, /* TVAR_ash_pGAS[267] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[268] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[269] */
+	{S5K6AAFX_REG_WR, 0x00AE}, /* TVAR_ash_pGAS[270] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[271] */
+	{S5K6AAFX_REG_WR, 0x0146}, /* TVAR_ash_pGAS[272] */
+	{S5K6AAFX_REG_WR, 0x0249}, /* TVAR_ash_pGAS[273] */
+	{S5K6AAFX_REG_WR, 0x017C}, /* TVAR_ash_pGAS[274] */
+	{S5K6AAFX_REG_WR, 0x010F}, /* TVAR_ash_pGAS[275] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[276] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[277] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[278] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[279] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[280] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[281] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[282] */
+	{S5K6AAFX_REG_WR, 0x00E3}, /* TVAR_ash_pGAS[283] */
+	{S5K6AAFX_REG_WR, 0x012E}, /* TVAR_ash_pGAS[284] */
+	{S5K6AAFX_REG_WR, 0x01BF}, /* TVAR_ash_pGAS[285] */
+	{S5K6AAFX_REG_WR, 0x0289}, /* TVAR_ash_pGAS[286] */
+	{S5K6AAFX_REG_WR, 0x019B}, /* TVAR_ash_pGAS[287] */
+	{S5K6AAFX_REG_WR, 0x0116}, /* TVAR_ash_pGAS[288] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[289] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[290] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[291] */
+	{S5K6AAFX_REG_WR, 0x009D}, /* TVAR_ash_pGAS[292] */
+	{S5K6AAFX_REG_WR, 0x00A4}, /* TVAR_ash_pGAS[293] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[294] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_pGAS[295] */
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[296] */
+	{S5K6AAFX_REG_WR, 0x0175}, /* TVAR_ash_pGAS[297] */
+	{S5K6AAFX_REG_WR, 0x0239}, /* TVAR_ash_pGAS[298] */
+	{S5K6AAFX_REG_WR, 0x01C5}, /* TVAR_ash_pGAS[299] */
+	{S5K6AAFX_REG_WR, 0x0125}, /* TVAR_ash_pGAS[300] */
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[301] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[302] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[303] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[304] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[305] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[306] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[307] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[308] */
+	{S5K6AAFX_REG_WR, 0x00CD}, /* TVAR_ash_pGAS[309] */
+	{S5K6AAFX_REG_WR, 0x010D}, /* TVAR_ash_pGAS[310] */
+	{S5K6AAFX_REG_WR, 0x0189}, /* TVAR_ash_pGAS[311] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* TVAR_ash_pGAS[312] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[313] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[314] */
+	{S5K6AAFX_REG_WR, 0x007D}, /* TVAR_ash_pGAS[315] */
+	{S5K6AAFX_REG_WR, 0x0050}, /* TVAR_ash_pGAS[316] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[317] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[318] */
+	{S5K6AAFX_REG_WR, 0x0032}, /* TVAR_ash_pGAS[319] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[320] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[321] */
+	{S5K6AAFX_REG_WR, 0x009F}, /* TVAR_ash_pGAS[322] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[323] */
+	{S5K6AAFX_REG_WR, 0x0118}, /* TVAR_ash_pGAS[324] */
+	{S5K6AAFX_REG_WR, 0x010C}, /* TVAR_ash_pGAS[325] */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* TVAR_ash_pGAS[326] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[327] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[328] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[329] */
+	{S5K6AAFX_REG_WR, 0x0017}, /* TVAR_ash_pGAS[330] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[331] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[332] */
+	{S5K6AAFX_REG_WR, 0x001F}, /* TVAR_ash_pGAS[333] */
+	{S5K6AAFX_REG_WR, 0x0040}, /* TVAR_ash_pGAS[334] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[335] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[336] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[337] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[338] */
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[339] */
+	{S5K6AAFX_REG_WR, 0x0078}, /* TVAR_ash_pGAS[340] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[341] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[342] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[343] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[344] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[345] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[346] */
+	{S5K6AAFX_REG_WR, 0x001F}, /* TVAR_ash_pGAS[347] */
+	{S5K6AAFX_REG_WR, 0x004B}, /* TVAR_ash_pGAS[348] */
+	{S5K6AAFX_REG_WR, 0x0088}, /* TVAR_ash_pGAS[349] */
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[350] */
+	{S5K6AAFX_REG_WR, 0x00EA}, /* TVAR_ash_pGAS[351] */
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[352] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[353] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[354] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[355] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[356] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[357] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[358] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[359] */
+	{S5K6AAFX_REG_WR, 0x0013}, /* TVAR_ash_pGAS[360] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[361] */
+	{S5K6AAFX_REG_WR, 0x0071}, /* TVAR_ash_pGAS[362] */
+	{S5K6AAFX_REG_WR, 0x00A0}, /* TVAR_ash_pGAS[363] */
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[364] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[365] */
+	{S5K6AAFX_REG_WR, 0x0076}, /* TVAR_ash_pGAS[366] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[367] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[368] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[369] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[370] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[371] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[372] */
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[373] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[374] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[375] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[376] */
+	{S5K6AAFX_REG_WR, 0x010B}, /* TVAR_ash_pGAS[377] */
+	{S5K6AAFX_REG_WR, 0x00CC}, /* TVAR_ash_pGAS[378] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[379] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[380] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[381] */
+	{S5K6AAFX_REG_WR, 0x0015}, /* TVAR_ash_pGAS[382] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[383] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[384] */
+	{S5K6AAFX_REG_WR, 0x000E}, /* TVAR_ash_pGAS[385] */
+	{S5K6AAFX_REG_WR, 0x0021}, /* TVAR_ash_pGAS[386] */
+	{S5K6AAFX_REG_WR, 0x0043}, /* TVAR_ash_pGAS[387] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[388] */
+	{S5K6AAFX_REG_WR, 0x00A0}, /* TVAR_ash_pGAS[389] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* TVAR_ash_pGAS[390] */
+	{S5K6AAFX_REG_WR, 0x00EB}, /* TVAR_ash_pGAS[391] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[392] */
+	{S5K6AAFX_REG_WR, 0x007E}, /* TVAR_ash_pGAS[393] */
+	{S5K6AAFX_REG_WR, 0x004E}, /* TVAR_ash_pGAS[394] */
+	{S5K6AAFX_REG_WR, 0x002F}, /* TVAR_ash_pGAS[395] */
+	{S5K6AAFX_REG_WR, 0x0021}, /* TVAR_ash_pGAS[396] */
+	{S5K6AAFX_REG_WR, 0x0020}, /* TVAR_ash_pGAS[397] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[398] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[399] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[400] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[401] */
+	{S5K6AAFX_REG_WR, 0x00BD}, /* TVAR_ash_pGAS[402] */
+	{S5K6AAFX_REG_WR, 0x01AD}, /* TVAR_ash_pGAS[403] */
+	{S5K6AAFX_REG_WR, 0x0122}, /* TVAR_ash_pGAS[404] */
+	{S5K6AAFX_REG_WR, 0x00E3}, /* TVAR_ash_pGAS[405] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[406] */
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[407] */
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[408] */
+	{S5K6AAFX_REG_WR, 0x0051}, /* TVAR_ash_pGAS[409] */
+	{S5K6AAFX_REG_WR, 0x004E}, /* TVAR_ash_pGAS[410] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[411] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[412] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[413] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[414] */
+	{S5K6AAFX_REG_WR, 0x0101}, /* TVAR_ash_pGAS[415] */
+	{S5K6AAFX_REG_WR, 0x0267}, /* TVAR_ash_pGAS[416] */
+	{S5K6AAFX_REG_WR, 0x018C}, /* TVAR_ash_pGAS[417] */
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[418] */
+	{S5K6AAFX_REG_WR, 0x00E5}, /* TVAR_ash_pGAS[419] */
+	{S5K6AAFX_REG_WR, 0x00C2}, /* TVAR_ash_pGAS[420] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[421] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[422] */
+	{S5K6AAFX_REG_WR, 0x0086}, /* TVAR_ash_pGAS[423] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[424] */
+	{S5K6AAFX_REG_WR, 0x0099}, /* TVAR_ash_pGAS[425] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[426] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[427] */
+	{S5K6AAFX_REG_WR, 0x016C}, /* TVAR_ash_pGAS[428] */
+	{S5K6AAFX_REG_WR, 0x01F3}, /* TVAR_ash_pGAS[429] */
+	{S5K6AAFX_REG_WR, 0x0136}, /* TVAR_ash_pGAS[430] */
+	{S5K6AAFX_REG_WR, 0x00D6}, /* TVAR_ash_pGAS[431] */
+	{S5K6AAFX_REG_WR, 0x00B3}, /* TVAR_ash_pGAS[432] */
+	{S5K6AAFX_REG_WR, 0x00A1}, /* TVAR_ash_pGAS[433] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[434] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[435] */
+	{S5K6AAFX_REG_WR, 0x0098}, /* TVAR_ash_pGAS[436] */
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[437] */
+	{S5K6AAFX_REG_WR, 0x00C5}, /* TVAR_ash_pGAS[438] */
+	{S5K6AAFX_REG_WR, 0x00ED}, /* TVAR_ash_pGAS[439] */
+	{S5K6AAFX_REG_WR, 0x014D}, /* TVAR_ash_pGAS[440] */
+	{S5K6AAFX_REG_WR, 0x0207}, /* TVAR_ash_pGAS[441] */
+	{S5K6AAFX_REG_WR, 0x014C}, /* TVAR_ash_pGAS[442] */
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[443] */
+	{S5K6AAFX_REG_WR, 0x00A4}, /* TVAR_ash_pGAS[444] */
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[445] */
+	{S5K6AAFX_REG_WR, 0x0077}, /* TVAR_ash_pGAS[446] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[447] */
+	{S5K6AAFX_REG_WR, 0x005E}, /* TVAR_ash_pGAS[448] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[449] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[450] */
+	{S5K6AAFX_REG_WR, 0x009F}, /* TVAR_ash_pGAS[451] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[452] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[453] */
+	{S5K6AAFX_REG_WR, 0x0162}, /* TVAR_ash_pGAS[454] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[455] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[456] */
+	{S5K6AAFX_REG_WR, 0x0079}, /* TVAR_ash_pGAS[457] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[458] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[459] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[460] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[461] */
+	{S5K6AAFX_REG_WR, 0x0033}, /* TVAR_ash_pGAS[462] */
+	{S5K6AAFX_REG_WR, 0x004A}, /* TVAR_ash_pGAS[463] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[464] */
+	{S5K6AAFX_REG_WR, 0x0092}, /* TVAR_ash_pGAS[465] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[466] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[467] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[468] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[469] */
+	{S5K6AAFX_REG_WR, 0x0059}, /* TVAR_ash_pGAS[470] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[471] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[472] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[473] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[474] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[475] */
+	{S5K6AAFX_REG_WR, 0x0020}, /* TVAR_ash_pGAS[476] */
+	{S5K6AAFX_REG_WR, 0x003B}, /* TVAR_ash_pGAS[477] */
+	{S5K6AAFX_REG_WR, 0x005E}, /* TVAR_ash_pGAS[478] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[479] */
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[480] */
+	{S5K6AAFX_REG_WR, 0x008B}, /* TVAR_ash_pGAS[481] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[482] */
+	{S5K6AAFX_REG_WR, 0x0045}, /* TVAR_ash_pGAS[483] */
+	{S5K6AAFX_REG_WR, 0x0024}, /* TVAR_ash_pGAS[484] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[485] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[486] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[487] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[488] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[489] */
+	{S5K6AAFX_REG_WR, 0x0017}, /* TVAR_ash_pGAS[490] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[491] */
+	{S5K6AAFX_REG_WR, 0x0060}, /* TVAR_ash_pGAS[492] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[493] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[494] */
+	{S5K6AAFX_REG_WR, 0x0060}, /* TVAR_ash_pGAS[495] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[496] */
+	{S5K6AAFX_REG_WR, 0x001D}, /* TVAR_ash_pGAS[497] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[498] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[499] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[500] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[501] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[502] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[503] */
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[504] */
+	{S5K6AAFX_REG_WR, 0x0047}, /* TVAR_ash_pGAS[505] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[506] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[507] */
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[508] */
+	{S5K6AAFX_REG_WR, 0x0042}, /* TVAR_ash_pGAS[509] */
+	{S5K6AAFX_REG_WR, 0x0023}, /* TVAR_ash_pGAS[510] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[511] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[512] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[513] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[514] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[515] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[516] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[517] */
+	{S5K6AAFX_REG_WR, 0x0039}, /* TVAR_ash_pGAS[518] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[519] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[520] */
+	{S5K6AAFX_REG_WR, 0x0076}, /* TVAR_ash_pGAS[521] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[522] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[523] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[524] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[525] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[526] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[527] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[528] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[529] */
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[530] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[531] */
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[532] */
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[533] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[534] */
+	{S5K6AAFX_REG_WR, 0x007E}, /* TVAR_ash_pGAS[535] */
+	{S5K6AAFX_REG_WR, 0x005C}, /* TVAR_ash_pGAS[536] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[537] */
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[538] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[539] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[540] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[541] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[542] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[543] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[544] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[545] */
+	{S5K6AAFX_REG_WR, 0x012F}, /* TVAR_ash_pGAS[546] */
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_pGAS[547] */
+	{S5K6AAFX_REG_WR, 0x00A7}, /* TVAR_ash_pGAS[548] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[549] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[550] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[551] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[552] */
+	{S5K6AAFX_REG_WR, 0x0047}, /* TVAR_ash_pGAS[553] */
+	{S5K6AAFX_REG_WR, 0x0049}, /* TVAR_ash_pGAS[554] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[555] */
+	{S5K6AAFX_REG_WR, 0x0058}, /* TVAR_ash_pGAS[556] */
+	{S5K6AAFX_REG_WR, 0x006E}, /* TVAR_ash_pGAS[557] */
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[558] */
+	{S5K6AAFX_REG_WR, 0x01CB}, /* TVAR_ash_pGAS[559] */
+	{S5K6AAFX_REG_WR, 0x0123}, /* TVAR_ash_pGAS[560] */
+	{S5K6AAFX_REG_WR, 0x00D5}, /* TVAR_ash_pGAS[561] */
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[562] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[563] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[564] */
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[565] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[566] */
+	{S5K6AAFX_REG_WR, 0x0079}, /* TVAR_ash_pGAS[567] */
+	{S5K6AAFX_REG_WR, 0x0078}, /* TVAR_ash_pGAS[568] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[569] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[570] */
+	{S5K6AAFX_REG_WR, 0x0108}, /* TVAR_ash_pGAS[571] */
+	/* parawrite _end - TVAR_ash_pGAS */
+
+        {S5K6AAFX_REG_W_ADDL, 0x0C48},
+        {S5K6AAFX_REG_WR, 0x0550}, /* R*/
+        {S5K6AAFX_REG_WR, 0x0400}, /* G*/
+        {S5K6AAFX_REG_WR, 0x0600}, /*B */
+
+#if 0
+	{S5K6AAFX_REG_W_ADDL, 0x0F12},
+	{S5K6AAFX_REG_WR, 0x02C9}, /* awbb_GLocusR */
+	{S5K6AAFX_REG_WR, 0x033F}, /* awbb_GLocusB */
+#endif
+
+	/* param_start - TVAR_ash_AwbAshCord */
+	{S5K6AAFX_REG_W_ADDL, 0x0704},
+	{S5K6AAFX_REG_WR, 0x00ED/*0x00C7*/}, /* TVAR_ash_AwbAshCord[0] */
+	{S5K6AAFX_REG_WR, 0x0124/*0x00F7*/}, /* TVAR_ash_AwbAshCord[1] */
+	{S5K6AAFX_REG_WR, 0x012B/*0x0107*/}, /* TVAR_ash_AwbAshCord[2] */
+	{S5K6AAFX_REG_WR, 0x014A/*0x0142*/}, /* TVAR_ash_AwbAshCord[3] */
+	{S5K6AAFX_REG_WR, 0x0190/*0x017A*/}, /* TVAR_ash_AwbAshCord[4] */
+	{S5K6AAFX_REG_WR, 0x01B2/*0x01A0*/}, /* TVAR_ash_AwbAshCord[5] */
+	{S5K6AAFX_REG_WR, 0x01C4/*0x01B6*/}, /* TVAR_ash_AwbAshCord[6] */
+	/* param_end - TVAR_ash_AwbAshCord */
+
+	{S5K6AAFX_REG_W_ADDL, 0x0754},
+	{S5K6AAFX_REG_WR, 0x247C},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0E1A},
+	{S5K6AAFX_REG_WR, 0x0138},
+
+	/* AWB Speed */
+	{S5K6AAFX_REG_W_ADDL, 0x0E7C},
+	{S5K6AAFX_REG_WR, 0x0010},
+	{S5K6AAFX_REG_WR, 0x0003},
+
+	/* AWB grid */
+	{S5K6AAFX_REG_W_ADDL, 0x0E42},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0E82},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xFFC4},   
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xFFDA},
+	{S5K6AAFX_REG_WR, 0xFFF2},   
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xFFC4},   
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xFFC4},   
+	{S5K6AAFX_REG_WR, 0x0000},
+	
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x004B},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0064},
+	//{S5K6AAFX_REG_WR, 0x0030},
+	//{S5K6AAFX_REG_WR, 0x0040},
+	//{S5K6AAFX_REG_WR, 0x0000},
+	//{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* param_start - awbb_IndoorGrZones_m_BGrid */
+	{S5K6AAFX_REG_W_ADDL, 0x0C50},
+	{S5K6AAFX_REG_WR, 0x0389},  
+	{S5K6AAFX_REG_WR, 0x0396},  
+	{S5K6AAFX_REG_WR, 0x0365},  
+	{S5K6AAFX_REG_WR, 0x03A4},  
+	{S5K6AAFX_REG_WR, 0x0343},  
+	{S5K6AAFX_REG_WR, 0x03A4},  
+	{S5K6AAFX_REG_WR, 0x0323},  
+	{S5K6AAFX_REG_WR, 0x0390},  
+	{S5K6AAFX_REG_WR, 0x0300},  
+	{S5K6AAFX_REG_WR, 0x036D},  
+	{S5K6AAFX_REG_WR, 0x02E0},  
+	{S5K6AAFX_REG_WR, 0x0356},  
+	{S5K6AAFX_REG_WR, 0x02CC},  
+	{S5K6AAFX_REG_WR, 0x033C},  
+	{S5K6AAFX_REG_WR, 0x02C0},  
+	{S5K6AAFX_REG_WR, 0x0325},  
+	{S5K6AAFX_REG_WR, 0x02B4},  
+	{S5K6AAFX_REG_WR, 0x0303},  
+	{S5K6AAFX_REG_WR, 0x02AA},  
+	{S5K6AAFX_REG_WR, 0x02E7},  
+	{S5K6AAFX_REG_WR, 0x02A1},  
+	{S5K6AAFX_REG_WR, 0x02D5},  
+	{S5K6AAFX_REG_WR, 0x0298},  
+	{S5K6AAFX_REG_WR, 0x02C9},  
+	{S5K6AAFX_REG_WR, 0x028D},  
+	{S5K6AAFX_REG_WR, 0x02BF},  
+	{S5K6AAFX_REG_WR, 0x0284},  
+	{S5K6AAFX_REG_WR, 0x02B4},  
+	{S5K6AAFX_REG_WR, 0x0279},  
+	{S5K6AAFX_REG_WR, 0x02A9},  
+	{S5K6AAFX_REG_WR, 0x026D},  
+	{S5K6AAFX_REG_WR, 0x02A1},  
+	{S5K6AAFX_REG_WR, 0x0260},  
+	{S5K6AAFX_REG_WR, 0x029B},  
+	{S5K6AAFX_REG_WR, 0x025A},  
+	{S5K6AAFX_REG_WR, 0x0291},  
+	{S5K6AAFX_REG_WR, 0x0252},  
+	{S5K6AAFX_REG_WR, 0x028A},  
+	{S5K6AAFX_REG_WR, 0x024F},  
+	{S5K6AAFX_REG_WR, 0x0284},  
+	{S5K6AAFX_REG_WR, 0x024C},  
+	{S5K6AAFX_REG_WR, 0x0279},  
+	{S5K6AAFX_REG_WR, 0x0259},  
+	{S5K6AAFX_REG_WR, 0x0265},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	{S5K6AAFX_REG_WR, 0x0000},  
+	/* param_end - awbb_IndoorGrZones_m_BGrid */
+
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0CF8},
+	{S5K6AAFX_REG_WR, 0x0115},
+	{S5K6AAFX_REG_WR, 0x0000},
+	
+	/* param_end - awbb_OutdoorGrZones_m_BGrid */
+	{S5K6AAFX_REG_W_ADDL, 0x0d08},	   
+	{S5K6AAFX_REG_WR, 0X026D},          	
+	{S5K6AAFX_REG_WR, 0X029D},              
+	{S5K6AAFX_REG_WR, 0X025B},              
+	{S5K6AAFX_REG_WR, 0X029D},              
+	{S5K6AAFX_REG_WR, 0X024D},              
+	{S5K6AAFX_REG_WR, 0X0293},              
+	{S5K6AAFX_REG_WR, 0X0240},              
+	{S5K6AAFX_REG_WR, 0X0286},              
+	{S5K6AAFX_REG_WR, 0X0236},              
+	{S5K6AAFX_REG_WR, 0X0279},              
+	{S5K6AAFX_REG_WR, 0X022D},              
+	{S5K6AAFX_REG_WR, 0X026C},              
+	{S5K6AAFX_REG_WR, 0X0225},              
+	{S5K6AAFX_REG_WR, 0X0260},              
+	{S5K6AAFX_REG_WR, 0X0225},              
+	{S5K6AAFX_REG_WR, 0X0254},              
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_WR, 0X0000},
+                               
+	{S5K6AAFX_REG_WR, 0X0004},
+	{S5K6AAFX_REG_WR, 0X0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0D74},
+	{S5K6AAFX_REG_WR, 0X0222},              
+	{S5K6AAFX_REG_WR, 0X0000},
+
+	/* param_start - SARR_usGammaLutRGBIndoor */
+	{S5K6AAFX_REG_W_ADDL, 0x04C8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x000A},
+	{S5K6AAFX_REG_WR, 0x0028},
+	{S5K6AAFX_REG_WR, 0x003E},
+	{S5K6AAFX_REG_WR, 0x0072},
+	{S5K6AAFX_REG_WR, 0x00DA},
+	{S5K6AAFX_REG_WR, 0x0129},
+	{S5K6AAFX_REG_WR, 0x0165},
+	{S5K6AAFX_REG_WR, 0x01C5},
+	{S5K6AAFX_REG_WR, 0x0224},
+	{S5K6AAFX_REG_WR, 0x028F},
+	{S5K6AAFX_REG_WR, 0x02EE},
+	{S5K6AAFX_REG_WR, 0x033C},
+	{S5K6AAFX_REG_WR, 0x0380},
+	{S5K6AAFX_REG_WR, 0x03C3},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x000A},
+	{S5K6AAFX_REG_WR, 0x0028},
+	{S5K6AAFX_REG_WR, 0x003E},
+	{S5K6AAFX_REG_WR, 0x0072},
+	{S5K6AAFX_REG_WR, 0x00DA},
+	{S5K6AAFX_REG_WR, 0x0129},
+	{S5K6AAFX_REG_WR, 0x0165},
+	{S5K6AAFX_REG_WR, 0x01C5},
+	{S5K6AAFX_REG_WR, 0x0224},
+	{S5K6AAFX_REG_WR, 0x028F},
+	{S5K6AAFX_REG_WR, 0x02EE},
+	{S5K6AAFX_REG_WR, 0x033C},
+	{S5K6AAFX_REG_WR, 0x0380},
+	{S5K6AAFX_REG_WR, 0x03C3},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x000A},
+	{S5K6AAFX_REG_WR, 0x0028},
+	{S5K6AAFX_REG_WR, 0x003E},
+	{S5K6AAFX_REG_WR, 0x0072},
+	{S5K6AAFX_REG_WR, 0x00DA},
+	{S5K6AAFX_REG_WR, 0x0129},
+	{S5K6AAFX_REG_WR, 0x0165},
+	{S5K6AAFX_REG_WR, 0x01C5},
+	{S5K6AAFX_REG_WR, 0x0224},
+	{S5K6AAFX_REG_WR, 0x028F},
+	{S5K6AAFX_REG_WR, 0x02EE},
+	{S5K6AAFX_REG_WR, 0x033C},
+	{S5K6AAFX_REG_WR, 0x0380},
+	{S5K6AAFX_REG_WR, 0x03C3},
+	{S5K6AAFX_REG_WR, 0x03FF},
+	/* param_end - SARR_usGammaLutRGBIndoor */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x1000},
+	{S5K6AAFX_REG_WR, 0x003F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0474},
+	{S5K6AAFX_REG_WR, 0x0112/*0x010F*//*0x0114*/},
+	{S5K6AAFX_REG_WR, 0x00EF/*0x00F1*//*0x00F9*/},
+
+	{S5K6AAFX_REG_W_ADDL, 0x2180},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x1006},
+	{S5K6AAFX_REG_WR, 0x001F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x108E},
+	{S5K6AAFX_REG_WR, 0x00C7},
+	{S5K6AAFX_REG_WR, 0x00F7},
+	{S5K6AAFX_REG_WR, 0x0107},
+	{S5K6AAFX_REG_WR, 0x0142},
+	{S5K6AAFX_REG_WR, 0x017A},
+	{S5K6AAFX_REG_WR, 0x01A0},
+	{S5K6AAFX_REG_WR, 0x01B6},
+
+	{S5K6AAFX_REG_WR, 0x0100/*0x0112*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0122*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0136*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00F6*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00FE*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+
+	/* param_start - TVAR_wbt_pBaseCcms */
+	{S5K6AAFX_REG_W_ADDL, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x01FA}, /* H */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* A */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* WW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* CW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x0276/*0x028D*/}, /* D50 */	         
+	{S5K6AAFX_REG_WR, 0xFFCA/*0xFFBC*/},                     
+	{S5K6AAFX_REG_WR, 0xFFCF/*0xFFA9*/},                     
+	{S5K6AAFX_REG_WR, 0x010D/*0x0124*/},                     
+	{S5K6AAFX_REG_WR, 0x010E/*0x0115*/},                     
+	{S5K6AAFX_REG_WR, 0xFF6D/*0xFF1B*/},                     
+	{S5K6AAFX_REG_WR, 0xFE97/*0xFEC5*/},                     
+	{S5K6AAFX_REG_WR, 0x0144/*0x01F8*/},                     
+	{S5K6AAFX_REG_WR, 0xFF9E/*0xFF4B*/},                     
+	{S5K6AAFX_REG_WR, 0xFE8A/*0xFEA4*/},                     
+	{S5K6AAFX_REG_WR, 0x0137/*0x0198*/},                     
+	{S5K6AAFX_REG_WR, 0x0131/*0x00D0*/},                     
+	{S5K6AAFX_REG_WR, 0xFFF3/*0xFFE7*/},                     
+	{S5K6AAFX_REG_WR, 0xFFF3/*0xFFB1*/},                     
+	{S5K6AAFX_REG_WR, 0x0193/*0x016E*/},                     
+	{S5K6AAFX_REG_WR, 0x0269/*0x0217*/},                     
+	{S5K6AAFX_REG_WR, 0xFFBD/*0xFF43*/},                     
+	{S5K6AAFX_REG_WR, 0x0162/*0x019E*/},                     
+                                                           
+                                                           
+	{S5K6AAFX_REG_WR, 0x01A0}, /* D65 */                     
+	{S5K6AAFX_REG_WR, 0xFFC4},                               
+	{S5K6AAFX_REG_WR, 0xFF8F},                               
+	{S5K6AAFX_REG_WR, 0x00FC},                               
+	{S5K6AAFX_REG_WR, 0x012D},                               
+	{S5K6AAFX_REG_WR, 0xFF21},                               
+	{S5K6AAFX_REG_WR, 0xFF5C},                               
+	{S5K6AAFX_REG_WR, 0x0169},                               
+	{S5K6AAFX_REG_WR, 0xFF92},                               
+	{S5K6AAFX_REG_WR, 0xFF60},                               
+	{S5K6AAFX_REG_WR, 0x013C},                               
+	{S5K6AAFX_REG_WR, 0x0171},                               
+	{S5K6AAFX_REG_WR, 0x0004},                               
+	{S5K6AAFX_REG_WR, 0xFFD3},                               
+	{S5K6AAFX_REG_WR, 0x01DF},                               
+	{S5K6AAFX_REG_WR, 0x01A4},                               
+	{S5K6AAFX_REG_WR, 0xFF97},                               
+	{S5K6AAFX_REG_WR, 0x016E},                               
+	/* param_end - TVAR_wbt_pBaseCcms */
+
+	/* param_start - TVAR_wbt_pOutdoorCcm */
+	{S5K6AAFX_REG_W_ADDL, 0x2380},
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x019D*/}, /* TVAR_wbt_pOutdoorCcm[0] */
+	{S5K6AAFX_REG_WR, 0xFFC3/*0xFFc3*//*0xFFC8*/}, /* TVAR_wbt_pOutdoorCcm[1] */
+	{S5K6AAFX_REG_WR, 0xFFE3/*0xFFe3*//*0x000C*/}, /* TVAR_wbt_pOutdoorCcm[2] */
+	{S5K6AAFX_REG_WR, 0x00F9/*0x00F9*//*0x008D*/}, /* TVAR_wbt_pOutdoorCcm[3] */
+	{S5K6AAFX_REG_WR, 0x013F/*0x013F*//*0x00CD*/}, /* TVAR_wbt_pOutdoorCcm[4] */
+	{S5K6AAFX_REG_WR, 0xFF6E/*0xFF6E*//*0xFF3F*/}, /* TVAR_wbt_pOutdoorCcm[5] */
+	{S5K6AAFX_REG_WR, 0xFEBB/*0xFEbb*//*0xFEDD*/}, /* TVAR_wbt_pOutdoorCcm[6] */
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x01C6*/}, /* TVAR_wbt_pOutdoorCcm[7] */
+	{S5K6AAFX_REG_WR, 0xFEFA/*0xFEFA*//*0xFF77*/}, /* TVAR_wbt_pOutdoorCcm[8] */
+	{S5K6AAFX_REG_WR, 0xFF37/*0xFF37*//*0xFEAB*/}, /* TVAR_wbt_pOutdoorCcm[9] */
+	{S5K6AAFX_REG_WR, 0x01A2/*0x01A2*//*0x015D*/}, /* TVAR_wbt_pOutdoorCcm[10] */
+	{S5K6AAFX_REG_WR, 0x0126/*0x0126*//*0x0082*/}, /* TVAR_wbt_pOutdoorCcm[11] */
+	{S5K6AAFX_REG_WR, 0xFFE0/*0xFFE0*//*0xFFCA*/}, /* TVAR_wbt_pOutdoorCcm[12] */
+	{S5K6AAFX_REG_WR, 0xFFBF/*0xFFBF*//*0xFFA2*/}, /* TVAR_wbt_pOutdoorCcm[13] */
+	{S5K6AAFX_REG_WR, 0x01E6/*0x01E6*//*0x016F*/}, /* TVAR_wbt_pOutdoorCcm[14] */
+	{S5K6AAFX_REG_WR, 0x0186/*0x0186*//*0x0171*/}, /* TVAR_wbt_pOutdoorCcm[15] */
+	{S5K6AAFX_REG_WR, 0xFF4B/*0xFF4B*//*0xFF35*/}, /* TVAR_wbt_pOutdoorCcm[16] */
+	{S5K6AAFX_REG_WR, 0x01B1/*0x01B1*//*0x013E*/}, /* TVAR_wbt_pOutdoorCcm[17] */
+	/* param_end - TVAR_wbt_pOutdoorCcm */
+
+	{S5K6AAFX_REG_W_ADDL, 0x06D4},
+	{S5K6AAFX_REG_WR, 0x2380},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06E8},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23C8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23EC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2410},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2434},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2458},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x06DA},
+	{S5K6AAFX_REG_WR, 0x00BF}, /* SARR_AwbCcmCord[0] */
+	{S5K6AAFX_REG_WR, 0x00E6}, /* SARR_AwbCcmCord[1] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* SARR_AwbCcmCord[2] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* SARR_AwbCcmCord[3] */
+	{S5K6AAFX_REG_WR, 0x0178}, /* SARR_AwbCcmCord[4] */
+	{S5K6AAFX_REG_WR, 0x01A3}, /* SARR_AwbCcmCord[5] */
+
+	/* param_start - SARR_uNormBrInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07E8},
+	{S5K6AAFX_REG_WR, 0x0016/*0x000A*/}, /* SARR_uNormBrInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0028/*0x0019*/}, /* SARR_uNormBrInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0096/*0x0096*/}, /* SARR_uNormBrInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x01F4/*0x01F4*/}, /* SARR_uNormBrInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x07D0/*0x07D0*/}, /* SARR_uNormBrInDoor[4] */
+	/* param_end - SARR_uNormBrInDoor */
+
+	/* param_start - afit_uNoiseIndInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07D0},
+	{S5K6AAFX_REG_WR, 0x0030}, /* afit_uNoiseIndInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0046}, /* afit_uNoiseIndInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0088}, /* afit_uNoiseIndInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x0205}, /* afit_uNoiseIndInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x02BC}, /* afit_uNoiseIndInDoor[4] */
+	/* param_end - afit_uNoiseIndInDoor */
+
+	{S5K6AAFX_REG_W_ADDL, 0x07E6},
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_bUseNoiseInd */
+
+	/* param_start - TVAR_afit_pBaseVals */
+	{S5K6AAFX_REG_W_ADDL, 0x0828},
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[0]     70000828 */
+	{S5K6AAFX_REG_WR, 0x0031}, /*TVAR_afit_pBaseVals[1]     7000082A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[2]     7000082C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[3]     7000082E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[4]     70000830 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[5]     70000832 */
+	{S5K6AAFX_REG_WR, 0x0021}, /*TVAR_afit_pBaseVals[6]     70000834 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[7]     70000836 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[8]     70000838 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[9]     7000083A */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[10]    7000083C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[11]    7000083E */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[12]    70000840 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[13]    70000842 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[14]    70000844 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[15]    70000846 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[16]    70000848 */
+	{S5K6AAFX_REG_WR, 0x0344}, /*TVAR_afit_pBaseVals[17]    7000084A */
+	{S5K6AAFX_REG_WR, 0x033A}, /*TVAR_afit_pBaseVals[18]    7000084C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[19]    7000084E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[20]    70000850 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[21]    70000852 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[22]    70000854 */
+	{S5K6AAFX_REG_WR, 0x001E}, /*TVAR_afit_pBaseVals[23]    70000856 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[24]    70000858 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[25]    7000085A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[26]    7000085C */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[27]    7000085E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[28]    70000860 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[29]    70000862 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[30]    70000864 */
+	{S5K6AAFX_REG_WR, 0x0C0F}, /*TVAR_afit_pBaseVals[31]    70000866 */
+	{S5K6AAFX_REG_WR, 0x0C0F}, /*TVAR_afit_pBaseVals[32]    70000868 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[33]    7000086A */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[34]    7000086C */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[35]    7000086E */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[36]    70000870 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[37]    70000872 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[38]    70000874 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[39]    70000876 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[40]    70000878 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[41]    7000087A */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[42]    7000087C */
+	{S5K6AAFX_REG_WR, 0x0A03}, /*TVAR_afit_pBaseVals[43]    7000087E */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[44]    70000880 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[45]    70000882 */
+	{S5K6AAFX_REG_WR, 0x0500}, /*TVAR_afit_pBaseVals[46]    70000884 */
+	{S5K6AAFX_REG_WR, 0x0914}, /*TVAR_afit_pBaseVals[47]    70000886 */
+	{S5K6AAFX_REG_WR, 0x0012}, /*TVAR_afit_pBaseVals[48]    70000888 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[49]    7000088A */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[50]    7000088C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[51]    7000088E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[52]    70000890 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[53]    70000892 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[54]    70000894 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[55]    70000896 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[56]    70000898 */
+	{S5K6AAFX_REG_WR, 0x014C}, /*TVAR_afit_pBaseVals[57]    7000089A */
+	{S5K6AAFX_REG_WR, 0x014D}, /*TVAR_afit_pBaseVals[58]    7000089C */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[59]    7000089E */
+	{S5K6AAFX_REG_WR, 0xA020/*0x8020*/}, /*TVAR_afit_pBaseVals[60]    700008A0 */ //CKLIN_20100908 White level low brightness 2.5 pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[61]    700008A2 */
+	{S5K6AAFX_REG_WR, 0x0001/*0x000A*/}, /*TVAR_afit_pBaseVals[62]    700008A4 */ //CKLIN_20100908 Black Noise pass
+
+	{S5K6AAFX_REG_WR, 0xFFFE}, /*TVAR_afit_pBaseVals[63]    700008A6 */
+	{S5K6AAFX_REG_WR, 0x0031}, /*TVAR_afit_pBaseVals[64]    700008A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[65]    700008AA */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[66]    700008AC */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[67]    700008AE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[68]    700008B0 */
+	{S5K6AAFX_REG_WR, 0x000C}, /*TVAR_afit_pBaseVals[69]    700008B2 */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[70]    700008B4 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[71]    700008B6 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[72]    700008B8 */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[73]    700008BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[74]    700008BC */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[75]    700008BE */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[76]    700008C0 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[77]    700008C2 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[78]    700008C4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[79]    700008C6 */
+	{S5K6AAFX_REG_WR, 0x0114}, /*TVAR_afit_pBaseVals[80]    700008C8 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[81]    700008CA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[82]    700008CC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[83]    700008CE */
+	{S5K6AAFX_REG_WR, 0x0018}, /*TVAR_afit_pBaseVals[84]    700008D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[85]    700008D2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[86]    700008D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[87]    700008D6 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[88]    700008D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[89]    700008DA */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[90]    700008DC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[91]    700008DE */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[92]    700008E0 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[93]    700008E2 */
+	{S5K6AAFX_REG_WR, 0x050F}, /*TVAR_afit_pBaseVals[94]    700008E4 */
+	{S5K6AAFX_REG_WR, 0x0A1F}, /*TVAR_afit_pBaseVals[95]    700008E6 */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[96]    700008E8 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[97]    700008EA */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[98]    700008EC */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[99]    700008EE */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[100]   700008F0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[101]   700008F2 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[102]   700008F4 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[103]   700008F6 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[104]   700008F8 */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[105]   700008FA */
+	{S5K6AAFX_REG_WR, 0x1403}, /*TVAR_afit_pBaseVals[106]   700008FC */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[107]   700008FE */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[108]   70000900 */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[109]   70000902 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[110]   70000904 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[111]   70000906 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[112]   70000908 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[113]   7000090A */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[114]   7000090C */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[115]   7000090E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[116]   70000910 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[117]   70000912 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[118]   70000914 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[119]   70000916 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[120]   70000918 */
+	{S5K6AAFX_REG_WR, 0x0151}, /*TVAR_afit_pBaseVals[121]   7000091A */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[122]   7000091C */
+	{S5K6AAFX_REG_WR, 0x9820}, /*TVAR_afit_pBaseVals[123]   7000091E */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[124]   70000920 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[125]   70000922 */
+
+	{S5K6AAFX_REG_WR, 0xFFFB}, /*TVAR_afit_pBaseVals[126]   70000924 */
+	{S5K6AAFX_REG_WR, 0x0031}, /*TVAR_afit_pBaseVals[127]   70000926 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[128]   70000928 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[129]   7000092A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[130]   7000092C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[131]   7000092E */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[132]   70000930 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[133]   70000932 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[134]   70000934 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[135]   70000936 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[136]   70000938 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[137]   7000093A */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[138]   7000093C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[139]   7000093E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[140]   70000940 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[141]   70000942 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[142]   70000944 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[143]   70000946 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[144]   70000948 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[145]   7000094A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[146]   7000094C */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[147]   7000094E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[148]   70000950 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[149]   70000952 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[150]   70000954 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[151]   70000956 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[152]   70000958 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[153]   7000095A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[154]   7000095C */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[155]   7000095E */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[156]   70000960 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[157]   70000962 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[158]   70000964 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[159]   70000966 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[160]   70000968 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[161]   7000096A */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[162]   7000096C */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[163]   7000096E */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[164]   70000970 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[165]   70000972 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[166]   70000974 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[167]   70000976 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[168]   70000978 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[169]   7000097A */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[170]   7000097C */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[171]   7000097E */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[172]   70000980 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[173]   70000982 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[174]   70000984 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[175]   70000986 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[176]   70000988 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[177]   7000098A */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[178]   7000098C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[179]   7000098E */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[180]   70000990 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[181]   70000992 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[182]   70000994 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[183]   70000996 */
+	{S5K6AAFX_REG_WR, 0x0170}, /*TVAR_afit_pBaseVals[184]   70000998 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[185]   7000099A */
+	{S5K6AAFX_REG_WR, 0x8050/*0x8030*/}, /*TVAR_afit_pBaseVals[186]   7000099C */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[187]   7000099E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[188]   700009A0 */
+
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[189]   700009A2 */
+	{S5K6AAFX_REG_WR, 0x0031}, /*TVAR_afit_pBaseVals[190]   700009A4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[191]   700009A6 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[192]   700009A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[193]   700009AA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[194]   700009AC */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[195]   700009AE */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[196]   700009B0 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[197]   700009B2 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[198]   700009B4 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[199]   700009B6 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[200]   700009B8 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[201]   700009BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[202]   700009BC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[203]   700009BE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[204]   700009C0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[205]   700009C2 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[206]   700009C4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[207]   700009C6 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[208]   700009C8 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[209]   700009CA */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[210]   700009CC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[211]   700009CE */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[212]   700009D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[213]   700009D2 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[214]   700009D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[215]   700009D6 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[216]   700009D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[217]   700009DA */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[218]   700009DC */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[219]   700009DE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[220]   700009E0 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[221]   700009E2 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[222]   700009E4 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[223]   700009E6 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[224]   700009E8 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[225]   700009EA */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[226]   700009EC */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[227]   700009EE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[228]   700009F0 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[229]   700009F2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[230]   700009F4 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[231]   700009F6 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[232]   700009F8 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[233]   700009FA */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[234]   700009FC */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[235]   700009FE */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[236]   70000A00 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[237]   70000A02 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[238]   70000A04 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[239]   70000A06 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[240]   70000A08 */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[241]   70000A0A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[242]   70000A0C */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[243]   70000A0E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[244]   70000A10 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[245]   70000A12 */
+	{S5K6AAFX_REG_WR, 0x0170}, /*TVAR_afit_pBaseVals[246]   70000A14 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[247]   70000A16 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[248]   70000A18 */
+	{S5K6AAFX_REG_WR, 0x8070/*0x8068*/}, /*TVAR_afit_pBaseVals[249]   70000A1A */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[250]   70000A1C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[251]   70000A1E */
+
+	{S5K6AAFX_REG_WR, 0x0032/*0x0000*/}, /*TVAR_afit_pBaseVals[252]   70000A20 */ //CKLIN_20100908 White level high brightness 286~2292 pass
+	{S5K6AAFX_REG_WR, 0x0031}, /*TVAR_afit_pBaseVals[253]   70000A22 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[254]   70000A24 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[255]   70000A26 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[256]   70000A28 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[257]   70000A2A */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[258]   70000A2C */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[259]   70000A2E */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[260]   70000A30 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[261]   70000A32 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[262]   70000A34 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[263]   70000A36 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[264]   70000A38 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[265]   70000A3A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[266]   70000A3C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[267]   70000A3E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[268]   70000A40 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[269]   70000A42 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[270]   70000A44 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[271]   70000A46 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[272]   70000A48 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[273]   70000A4A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[274]   70000A4C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[275]   70000A4E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[276]   70000A50 */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[277]   70000A52 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[278]   70000A54 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[279]   70000A56 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[280]   70000A58 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[281]   70000A5A */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[282]   70000A5C */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[283]   70000A5E */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[284]   70000A60 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[285]   70000A62 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[286]   70000A64 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[287]   70000A66 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[288]   70000A68 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[289]   70000A6A */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[290]   70000A6C */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[291]   70000A6E */
+	{S5K6AAFX_REG_WR, 0x0880}, /*TVAR_afit_pBaseVals[292]   70000A70 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[293]   70000A72 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[294]   70000A74 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[295]   70000A76 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[296]   70000A78 */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[297]   70000A7A */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[298]   70000A7C */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[299]   70000A7E */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[300]   70000A80 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[301]   70000A82 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[302]   70000A84 */
+	{S5K6AAFX_REG_WR, 0x0408}, /*TVAR_afit_pBaseVals[303]   70000A86 */
+	{S5K6AAFX_REG_WR, 0x0406}, /*TVAR_afit_pBaseVals[304]   70000A88 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[305]   70000A8A */
+	{S5K6AAFX_REG_WR, 0x0608}, /*TVAR_afit_pBaseVals[306]   70000A8C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[307]   70000A8E */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[308]   70000A90 */
+	{S5K6AAFX_REG_WR, 0x0170}, /*TVAR_afit_pBaseVals[309]   70000A92 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[310]   70000A94 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[311]   70000A96 */
+	{S5K6AAFX_REG_WR, 0x7058/*0x7050*/}, /*TVAR_afit_pBaseVals[312]   70000A98 */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[313]   70000A9A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[314]   70000A9C */
+	/* param_end - TVAR_afit_pBaseVals */
+
+	/* param_start - afit_pConstBaseVals */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[0] */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[1] */
+	{S5K6AAFX_REG_WR, 0x0800}, /* afit_pConstBaseVals[2] */
+	{S5K6AAFX_REG_WR, 0x0600}, /* afit_pConstBaseVals[3] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[4] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[5] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[6] */
+	{S5K6AAFX_REG_WR, 0x0300}, /* afit_pConstBaseVals[7] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* afit_pConstBaseVals[8] */
+	{S5K6AAFX_REG_WR, 0x0400}, /* afit_pConstBaseVals[9] */
+	{S5K6AAFX_REG_WR, 0x0106}, /* afit_pConstBaseVals[10] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* afit_pConstBaseVals[11] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[12] */
+	{S5K6AAFX_REG_WR, 0x0703}, /* afit_pConstBaseVals[13] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[14] */
+	{S5K6AAFX_REG_WR, 0xFFD6}, /* afit_pConstBaseVals[15] */
+	{S5K6AAFX_REG_WR, 0x53C1}, /* afit_pConstBaseVals[16] */
+	{S5K6AAFX_REG_WR, 0xE1FE}, /* afit_pConstBaseVals[17] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* afit_pConstBaseVals[18] */
+	/* param_end - afit_pConstBaseVals */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x0488},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2174},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0490},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2178},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0498},
+	{S5K6AAFX_REG_WR, 0x01E8},
+	{S5K6AAFX_REG_WR, 0x0310/*0x0270*/},
+	{S5K6AAFX_REG_W_ADDL, 0x217C},
+	{S5K6AAFX_REG_WR, 0x0580},
+	{S5K6AAFX_REG_W_ADDL, 0x049C},
+	{S5K6AAFX_REG_WR, 0x0160},
+
+
+	/* WRITE #AWBBTune_EVT4_uMaxExp3     0000 */
+	/* WRITE #AWBBTune_EVT4_uCapMaxExp3  0000 */
+	/* WRITE #AWBBTune_EVT4_uMaxAnGain3  0000 */
+
+	{S5K6AAFX_REG_W_ADDL, 0x2170},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	/* AE Weight */
+	{S5K6AAFX_REG_W_ADDL, 0x100E},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+};
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tbl[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1B58},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tb2[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tbl[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x1700},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x02C2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x03E8},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0002},/* 0x02D4 value */
+	{S5K6AAFX_REG_WR, 0x0002},/* 0x02D4 value */
+
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0003},
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+
+	{S5K6AAFX_REG_W_ADDL, 0x01FA},
+	/* REG_TC_GP_PrevReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevInputWidthOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_WIDTH-S5K6AAFX_ADJ_FULL_SIZE_WIDTH)/2},
+	/* REG_TC_GP_PrevInputHeightOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_HEIGHT-S5K6AAFX_ADJ_FULL_SIZE_HEIGHT)/2},
+	{S5K6AAFX_REG_W_ADDL, 0x020A},
+	/* REG_TC_GP_PrevZoomReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevZoomReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevZoomReqInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_PrevZoomReqInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* REG_TC_GEP_InputsChangeRequest */
+	{S5K6AAFX_REG_W_ADDL, 0x021A},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tb2[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x1700},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0250},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0001},/* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* PREVIEW CONFIGURATION 1 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0268},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x0274},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x026E},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0278},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0276},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x027A},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+	{S5K6AAFX_REG_W_ADDL, 0x0288}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0001}, /* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0001}, /* 0x0288 value */
+
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0001},/*Preview: 3 : VGA 30fps. 1:Full size 15fps*/
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+};
+
+
+struct s5k6aafx_reg s5k6aafx_regs = {
+	.reset_init = &reset_init_tbl[0],
+	.reset_init_size = ARRAY_SIZE(reset_init_tbl),
+	.TP_init = &TP_init_tbl[0],
+	.TP_init_size = ARRAY_SIZE(TP_init_tbl),
+	.analog_setting_init = &analog_setting_init_tbl[0],
+	.analog_setting_init_size = ARRAY_SIZE(analog_setting_init_tbl),
+	.register_init = &register_init_tbl[0],
+	.register_init_size = ARRAY_SIZE(register_init_tbl),
+	.clk_init = &clk_init_tbl[0],
+	.clk_init_size = ARRAY_SIZE(clk_init_tbl),
+	.prev_snap_conf_init = &prev_snap_conf_init_tbl[0],
+	.prev_snap_conf_init_size = ARRAY_SIZE(prev_snap_conf_init_tbl),
+	/* for full-size preview */
+	.clk_init_tb2 = &clk_init_tb2[0],
+	.clk_init_tb2_size = ARRAY_SIZE(clk_init_tb2),
+	.prev_snap_conf_init_tb2 = &prev_snap_conf_init_tb2[0],
+	.prev_snap_conf_init_tb2_size = ARRAY_SIZE(prev_snap_conf_init_tb2),
+};
diff --git a/include/media/msm_camera.h b/include/media/msm_camera.h
index c016540..db7172e 100644
--- a/include/media/msm_camera.h
+++ b/include/media/msm_camera.h
@@ -1,19 +1,5 @@
-/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
+/*
+ * Copyright (C) 2008-2009 QUALCOMM Incorporated.
  */
 
 #ifndef __LINUX_MSM_CAMERA_H
@@ -91,6 +77,8 @@
 #define MSM_CAMERA_LED_OFF  0
 #define MSM_CAMERA_LED_LOW  1
 #define MSM_CAMERA_LED_HIGH 2
+#define MSM_CAMERA_LED_LOW_FOR_SNAPSHOT 3
+#define MSM_CAMERA_LED_DEATH_RAY 4
 
 #define MSM_CAM_IOCTL_FLASH_LED_CFG \
 	_IOW(MSM_CAM_IOCTL_MAGIC, 22, unsigned *)
@@ -104,11 +92,6 @@
 #define MSM_CAM_IOCTL_ENABLE_OUTPUT_IND \
 	_IOW(MSM_CAM_IOCTL_MAGIC, 25, uint32_t *)
 
-#define MSM_CAM_IOCTL_AF_CTRL \
-	_IOR(MSM_CAM_IOCTL_MAGIC, 26, struct msm_ctrl_cmt_t *)
-#define MSM_CAM_IOCTL_AF_CTRL_DONE \
-	_IOW(MSM_CAM_IOCTL_MAGIC, 27, struct msm_ctrl_cmt_t *)
-
 #define MAX_SENSOR_NUM  3
 #define MAX_SENSOR_NAME 32
 
@@ -146,6 +129,7 @@ struct msm_vfe_evt_msg {
 	unsigned short msg_id;
 	unsigned int len; /* size in, number of bytes out */
 	void *data;
+	unsigned short exttype;
 };
 
 #define MSM_CAM_RESP_CTRL         0
@@ -178,6 +162,52 @@ struct msm_camera_cfg_cmd {
 	void *value;
 };
 
+#ifdef CONFIG_720P_CAMERA
+#define CMD_GENERAL 0
+#define CMD_AXI_CFG_SNAP    	    1
+#define CMD_AXI_CFG_PREVIEW		    2
+#define CMD_AXI_CFG_VIDEO		    3
+#define CMD_RAW_PICT_AXI_CFG        4
+
+#define CMD_FRAME_BUF_RELEASE       5
+#define CMD_PREV_BUF_CFG            6
+#define CMD_SNAP_BUF_RELEASE        7
+#define CMD_SNAP_BUF_CFG            8
+#define CMD_STATS_DISABLE           9
+#define CMD_STATS_AEC_AWB_ENABLE   10
+#define CMD_STATS_AF_ENABLE        11
+#define CMD_STATS_AEC_ENABLE       12
+#define CMD_STATS_AWB_ENABLE       13
+#define CMD_STATS_ENABLE           14
+
+#define CMD_STATS_AXI_CFG          15
+#define CMD_STATS_AEC_AXI_CFG      16
+#define CMD_STATS_AF_AXI_CFG       17
+#define CMD_STATS_AWB_AXI_CFG      18
+#define CMD_STATS_RS_AXI_CFG       19
+#define CMD_STATS_CS_AXI_CFG       20
+#define CMD_STATS_IHIST_AXI_CFG    21
+#define CMD_STATS_SKIN_AXI_CFG     22
+
+#define CMD_STATS_BUF_RELEASE       23
+#define CMD_STATS_AEC_BUF_RELEASE   24
+#define CMD_STATS_AF_BUF_RELEASE    25
+#define CMD_STATS_AWB_BUF_RELEASE   26
+#define CMD_STATS_RS_BUF_RELEASE    27
+#define CMD_STATS_CS_BUF_RELEASE    28
+#define CMD_STATS_IHIST_BUF_RELEASE 29
+#define CMD_STATS_SKIN_BUF_RELEASE  30
+
+#define UPDATE_STATS_INVALID        31
+#else
+
+//Just for build pass (Horng test)
+//------------------------------------
+#define CMD_AXI_CFG_SNAP    	    1
+#define CMD_AXI_CFG_PREVIEW		    2
+#define CMD_AXI_CFG_VIDEO		    3
+//------------------------------------
+
 #define CMD_GENERAL			0
 #define CMD_AXI_CFG_OUT1		1
 #define CMD_AXI_CFG_SNAP_O1_AND_O2	2
@@ -199,30 +229,7 @@ struct msm_camera_cfg_cmd {
 #define CMD_STATS_ENABLE        18
 #define UPDATE_STATS_INVALID		19
 
-#define CMD_STATS_AEC_ENABLE		20
-#define CMD_STATS_AWB_ENABLE		21
-#define CMD_STATS_AEC_AXI_CFG		22
-#define CMD_STATS_AWB_AXI_CFG		23
-#define CMD_STATS_RS_AXI_CFG		24
-#define CMD_STATS_CS_AXI_CFG		25
-#define CMD_STATS_IHIST_AXI_CFG		26
-#define CMD_STATS_SKIN_AXI_CFG		27
-#define CMD_STATS_AEC_BUF_RELEASE	28
-#define CMD_STATS_AWB_BUF_RELEASE	29
-#define CMD_STATS_RS_BUF_RELEASE	30
-#define CMD_STATS_CS_BUF_RELEASE	31
-#define CMD_STATS_IHIST_BUF_RELEASE	32
-#define CMD_STATS_SKIN_BUF_RELEASE	33
-
-#define CMD_AXI_CFG_SNAP_GEMINI		34
-#define CMD_AXI_CFG_SNAP		35
-#define CMD_AXI_CFG_PREVIEW		36
-#define CMD_AXI_CFG_VIDEO		37
-
-#define CMD_STATS_IHIST_ENABLE 38
-#define CMD_STATS_RS_ENABLE 39
-#define CMD_STATS_CS_ENABLE 40
-#define CMD_AXI_CFG_O1_AND_O2	41 /* output1 and output2 */
+#endif
 
 /* vfe config command: config command(from config thread)*/
 struct msm_vfe_cfg_cmd {
@@ -236,6 +243,31 @@ struct camera_enable_cmd {
 	char name[MAX_CAMERA_ENABLE_NAME_LEN];
 };
 
+#ifdef CONFIG_720P_CAMERA
+
+#define MSM_PMEM_VIDEO        0
+#define MSM_PMEM_PREVIEW      1
+#define MSM_PMEM_THUMBNAIL    2
+#define MSM_PMEM_MAINIMG      3
+#define MSM_PMEM_RAW_MAINIMG  4
+#define MSM_PMEM_AEC_AWB      5
+#define MSM_PMEM_AF           6
+#define MSM_PMEM_AEC          7
+#define MSM_PMEM_AWB          8
+#define MSM_PMEM_RS           9
+#define MSM_PMEM_CS           10
+#define MSM_PMEM_IHIST        11
+#define MSM_PMEM_SKIN         12
+#define MSM_PMEM_MAX          13
+
+#else
+
+//Just for build pass (Horng test)
+//------------------------------------
+#define MSM_PMEM_VIDEO        0
+#define MSM_PMEM_PREVIEW      1
+//------------------------------------
+
 #define MSM_PMEM_OUTPUT1		0
 #define MSM_PMEM_OUTPUT2		1
 #define MSM_PMEM_OUTPUT1_OUTPUT2	2
@@ -244,20 +276,14 @@ struct camera_enable_cmd {
 #define MSM_PMEM_RAW_MAINIMG		5
 #define MSM_PMEM_AEC_AWB		6
 #define MSM_PMEM_AF			7
-#define MSM_PMEM_AEC			8
-#define MSM_PMEM_AWB			9
-#define MSM_PMEM_RS		    	10
-#define MSM_PMEM_CS	    		11
-#define MSM_PMEM_IHIST			12
-#define MSM_PMEM_SKIN			13
-#define MSM_PMEM_VIDEO			14
-#define MSM_PMEM_PREVIEW		15
-#define MSM_PMEM_MAX			16
+#define MSM_PMEM_MAX			8
+
+#endif
 
 #define FRAME_PREVIEW_OUTPUT1		0
 #define FRAME_PREVIEW_OUTPUT2		1
 #define FRAME_SNAPSHOT			2
-#define FRAME_THUMBNAIL		3
+#define FRAME_THUMBAIL			3
 #define FRAME_RAW_SNAPSHOT		4
 #define FRAME_MAX			5
 
@@ -280,24 +306,41 @@ struct outputCfg {
 	uint32_t window_height_lastline;
 };
 
+#ifndef CONFIG_720P_CAMERA
+
 #define OUTPUT_1	0
 #define OUTPUT_2	1
 #define OUTPUT_1_AND_2	2
 #define CAMIF_TO_AXI_VIA_OUTPUT_2		3
 #define OUTPUT_1_AND_CAMIF_TO_AXI_VIA_OUTPUT_2	4
 #define OUTPUT_2_AND_CAMIF_TO_AXI_VIA_OUTPUT_1	5
-#define OUTPUT_1_AND_3 6
-#define LAST_AXI_OUTPUT_MODE_ENUM = OUTPUT_1_AND_3            7   /* video */
+#define LAST_AXI_OUTPUT_MODE_ENUM = OUTPUT_2_AND_CAMIF_TO_AXI_VIA_OUTPUT_1 6
 
+#define MSM_FRAME_PREV_1	0
+#define MSM_FRAME_PREV_2	1
+#define MSM_FRAME_ENC		2
+
+#else
+
+#define OUTPUT_1 0
+#define OUTPUT_2 1
+#define OUTPUT_1_AND_2 2
+#define OUTPUT_1_AND_3 3
+#define CAMIF_TO_AXI_VIA_OUTPUT_2 4
+#define OUTPUT_1_AND_CAMIF_TO_AXI_VIA_OUTPUT_2 5
+#define OUTPUT_2_AND_CAMIF_TO_AXI_VIA_OUTPUT_1 6
+#define LAST_AXI_OUTPUT_MODE_ENUM = OUTPUT_2_AND_CAMIF_TO_AXI_VIA_OUTPUT_1 7
 
 #define MSM_FRAME_PREV_1	0
 #define MSM_FRAME_PREV_2	1
 #define MSM_FRAME_ENC		2
 
-#define OUTPUT_TYPE_P		1
-#define OUTPUT_TYPE_T		2
-#define OUTPUT_TYPE_S		3
-#define OUTPUT_TYPE_V		4
+#define OUTPUT_TYPE_P  1
+#define OUTPUT_TYPE_T  2
+#define OUTPUT_TYPE_S  3
+#define OUTPUT_TYPE_V  4
+
+#endif
 
 struct msm_frame {
 	int path;
@@ -312,13 +355,7 @@ struct msm_frame {
 
 #define STAT_AEAW	0
 #define STAT_AF		1
-#define STAT_AEC	2
-#define STAT_AWB	3
-#define STAT_RS		4
-#define STAT_CS		5
-#define STAT_IHIST	6
-#define STAT_SKIN	7
-#define STAT_MAX	8
+#define STAT_MAX	2
 
 struct msm_stats_buf {
 	int type;
@@ -334,8 +371,11 @@ struct msm_stats_buf {
 #define MSM_V4L2_GET_CTRL	5
 #define MSM_V4L2_SET_CTRL	6
 #define MSM_V4L2_QUERY		7
-#define MSM_V4L2_MAX		8
+#define MSM_V4L2_GET_CROP 8
+#define MSM_V4L2_SET_CROP 9
+#define MSM_V4L2_MAX 10
 
+#define V4L2_CAMERA_EXIT 43
 struct crop_info {
 	void *info;
 	int len;
@@ -380,7 +420,20 @@ struct msm_snapshot_pp_status {
 #define CFG_GET_PICT_P_PL		25
 #define CFG_GET_AF_MAX_STEPS		26
 #define CFG_GET_PICT_MAX_EXP_LC		27
-#define CFG_MAX				28
+#define CFG_I2C_IOCTL_R_OTP	28
+#define CFG_SET_OV_LSC	29 	/*vincent for LSC calibration*/
+#define CFG_SET_SHARPNESS 30
+#define CFG_SET_SATURATION 31
+#define CFG_SET_OV_LSC_RAW_CAPTURE 32/*20100330 vincent for LSC calibration*/
+#define CFG_SET_ISO			33
+#define CFG_SET_COORDINATE		34
+#define CFG_RUN_AUTO_FOCUS		35
+#define CFG_CANCEL_AUTO_FOCUS		36
+#define CFG_GET_EXP_FOR_LED		37
+#define CFG_UPDATE_AEC_FOR_LED		38
+#define CFG_SET_FRONT_CAMERA_MODE	39
+#define CFG_SET_QCT_LSC_RAW_CAPTURE 40 /* 20101011 QCT mesh LSC Calibration */
+#define CFG_MAX        			41
 
 #define MOVE_NEAR	0
 #define MOVE_FAR	1
@@ -388,6 +441,7 @@ struct msm_snapshot_pp_status {
 #define SENSOR_PREVIEW_MODE		0
 #define SENSOR_SNAPSHOT_MODE		1
 #define SENSOR_RAW_SNAPSHOT_MODE	2
+#define SENSOR_GET_EXP 3
 
 #define SENSOR_QTR_SIZE			0
 #define SENSOR_FULL_SIZE		1
@@ -415,11 +469,16 @@ struct sensor_pict_fps {
 struct exp_gain_cfg {
 	uint16_t gain;
 	uint32_t line;
+	uint16_t mul;
 };
 
 struct focus_cfg {
 	int32_t steps;
 	int dir;
+	int coarse_delay;
+	int fine_delay;
+	int step_dir;
+	int init_code_offset_max;
 };
 
 struct fps_cfg {
@@ -428,6 +487,79 @@ struct fps_cfg {
 	uint32_t pict_fps_div;
 };
 
+/*Becker for AWB calibration*/
+struct fuse_id{
+	uint32_t fuse_id_word1;
+	uint32_t fuse_id_word2;
+	uint32_t fuse_id_word3;
+	uint32_t fuse_id_word4;
+};
+
+/*Vincent for LSC calibration*/
+struct reg_addr_val_pair_struct {
+	uint16_t reg_addr;
+	uint8_t reg_val;
+};
+
+struct lsc_cfg{
+	struct reg_addr_val_pair_struct lsc_table[144]; /*OV LSC table*/
+};
+
+enum antibanding_mode{
+	CAMERA_ANTI_BANDING_50HZ,
+	CAMERA_ANTI_BANDING_60HZ,
+	CAMERA_ANTI_BANDING_AUTO,
+};
+
+enum brightness_t{
+	CAMERA_BRIGHTNESS_N3,
+	CAMERA_BRIGHTNESS_N2,
+	CAMERA_BRIGHTNESS_N1,
+	CAMERA_BRIGHTNESS_D,
+	CAMERA_BRIGHTNESS_P1,
+	CAMERA_BRIGHTNESS_P2,
+	CAMERA_BRIGHTNESS_P3,
+        CAMERA_BRIGHTNESS_P4,
+        CAMERA_BRIGHTNESS_N4,
+};
+
+enum frontcam_t{
+	CAMERA_MIRROR,
+	CAMERA_REVERSE,
+};
+
+enum wb_mode{
+	CAMERA_AWB_AUTO,/*auto*/
+	CAMERA_AWB_CLOUDY,/*Cloudy*/
+	CAMERA_AWB_INDOOR_HOME,/*Fluorescent*/
+	CAMERA_AWB_INDOOR_OFFICE,/*Incandescent*/
+	CAMERA_AWB_SUNNY,/*daylight*/
+};
+
+enum sharpness_mode{
+	CAMERA_SHARPNESS_X0,
+	CAMERA_SHARPNESS_X1,
+	CAMERA_SHARPNESS_X2,
+	CAMERA_SHARPNESS_X3,
+	CAMERA_SHARPNESS_X4,
+};
+
+enum saturation_mode{
+	CAMERA_SATURATION_X0,
+	CAMERA_SATURATION_X05,
+	CAMERA_SATURATION_X1,
+	CAMERA_SATURATION_X15,
+	CAMERA_SATURATION_X2,
+};
+
+enum contrast_mode{
+	CAMERA_CONTRAST_P2,
+	CAMERA_CONTRAST_P1,
+	CAMERA_CONTRAST_D,
+	CAMERA_CONTRAST_N1,
+	CAMERA_CONTRAST_N2,
+};
+
 struct sensor_cfg_data {
 	int cfgtype;
 	int mode;
@@ -447,6 +579,15 @@ struct sensor_cfg_data {
 		struct exp_gain_cfg exp_gain;
 		struct focus_cfg focus;
 		struct fps_cfg fps;
+		struct fuse_id fuse;
+		struct lsc_cfg lsctable;/*Vincent for LSC calibration*/
+		enum antibanding_mode antibanding_value;
+		enum brightness_t brightness_value;
+		enum frontcam_t frontcam_value;
+		enum wb_mode wb_value;
+		enum sharpness_mode sharpness_value;
+		enum saturation_mode saturation_value;
+		enum contrast_mode  contrast_value;
 	} cfg;
 };
 
